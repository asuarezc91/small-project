/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{isSome as e,isNone as t}from"../../core/maybe.js";import i from"../../core/Logger.js";import n from"../../core/Error.js";import{WGS84 as r,equals as a}from"../../geometry/support/spatialReferenceUtils.js";import o from"../../request.js";import{kebabDict as l}from"../support/fieldType.js";import s from"../graphics/OptimizedFeatureSet.js";import{convertToFeatureSet as d,convertFromGeometry as f,convertToGeometry as c}from"../graphics/featureConversionUtils.js";import m from"../support/FieldsIndex.js";import u from"../../tasks/support/FeatureSet.js";import{checkProjectionSupport as p,project as y}from"../graphics/data/projectionSupport.js";import{validateGeoJSON as g,inferLayerProperties as F,createOptimizedFeatures as j}from"../graphics/sources/geojson/geojson.js";import{createDrawingInfo as I}from"../graphics/sources/support/clientSideDefaults.js";const w=i.getLogger("esri.layers.graphics.sources.ogcfeature");async function T(e,t,i,a,s=5){try{await p(r,i.spatialReference)}catch{throw new n("ogc-feature-layer:projection-not-supported","Projection not supported")}const d=`${e}/collections/${t}/items`,{data:f}=await o(d,{signal:a,query:{limit:s,f:"json"}});await g(f);const c=F(f,{geometryType:i.geometryType}),u=i.fields||c.fields||[],y=null!=i.hasZ?i.hasZ:c.hasZ,j=c.geometryType,T=i.objectIdField||c.objectIdFieldName||"OBJECTID";let b=i.timeInfo;const h=u.find((e=>e.name===T));if(!h){if(!c.objectIdFieldType)throw new n("ogc-feature-layer:missing-feature-id","Collection geojson require a feature id as a unique identifier");u.unshift({name:T,alias:T,type:"esriFieldTypeOID",editable:!1,nullable:!1})}else h.type="esriFieldTypeOID",h.editable=!1,h.nullable=!1;if(T!==c.objectIdFieldName){const e=u.find((e=>e.name===c.objectIdFieldName));e&&(e.type="esriFieldTypeInteger")}if(!j)throw new n("ogc-feature-layer:missing-property","geometryType not set and couldn't be inferred from the provided features");u===c.fields&&c.unknownFields.length>0&&w.warn({name:"ogc-feature-layer:unknown-field-types",message:"Some fields types couldn't be inferred from the features and were dropped",details:{unknownFields:c.unknownFields}});for(const e of u){if(null==e.name&&(e.name=e.alias),null==e.alias&&(e.alias=e.name),"esriFieldTypeOID"!==e.type&&"esriFieldTypeGlobalID"!==e.type&&(e.editable=null==e.editable||!!e.editable,e.nullable=null==e.nullable||!!e.nullable),!e.name)throw new n("ogc-feature-layer:invalid-field-name","field name is missing",{field:e});if(-1===l.jsonValues.indexOf(e.type))throw new n("ogc-feature-layer:invalid-field-type",`invalid type for field "${e.name}"`,{field:e})}if(b){const e=new m(u);if(b.startTimeField){const t=e.get(b.startTimeField);t?(b.startTimeField=t.name,t.type="esriFieldTypeDate"):b.startTimeField=null}if(b.endTimeField){const t=e.get(b.endTimeField);t?(b.endTimeField=t.name,t.type="esriFieldTypeDate"):b.endTimeField=null}if(b.trackIdField){const t=e.get(b.trackIdField);t?b.trackIdField=t.name:(b.trackIdField=null,w.warn({name:"ogc-feature-layer:invalid-timeInfo-trackIdField",message:"trackIdField is missing",details:{timeInfo:b}}))}b.startTimeField||b.endTimeField||(w.warn({name:"ogc-feature-layer:invalid-timeInfo",message:"startTimeField and endTimeField are missing",details:{timeInfo:b}}),b=null)}return{drawingInfo:I(j),geometryType:j,fields:u,hasZ:!!y,objectIdField:T,timeInfo:b}}async function b(e,t,i){const n=`${e}/collections/${t}`,{data:r}=await o(n,{signal:i,query:{f:"json"}});return r}async function h(e,t){const i=`${e}/collections`,{data:n}=await o(i,{signal:t,query:{f:"json"}});return n}async function $(e,t){const i=`${e}/conformance`,{data:n}=await o(i,{signal:t,query:{f:"json"}});return n}async function x(e,t){const{data:i}=await o(e,{signal:t,query:{f:"json"}});return i}async function k(e,t,i){const n=await S(e,t,i);return u.fromJSON(n)}async function S(e,t,i){const n=await q(e,t,i);return d(n)}async function q(i,n,l){var d;const{capabilities:{query:{maxRecordCount:m}},collectionId:u,layerDefinition:p,url:g}=i,F=`${g}/collections/${u}/items`,{geometry:I,num:w,start:T,timeExtent:b,where:h}=n,$=e(n.outSpatialReference)?n.outSpatialReference:r,x=function(e){if(t(e))return null;const{xmin:i,ymin:n,xmax:r,ymax:a}=e;return`${i},${n},${r},${a}`}(y(I,r)),k=function(e){if(t(e))return null;const{start:i,end:n}=e;return`${i?i.toISOString():".."}/${n?n.toISOString():".."}`}(b),S=function(e){if(t(e)||!e||"1=1"===e)return null;return e}(h),q=null!=w?w:null!=T&&void 0!==T?10:m,{data:v}=await o(F,{...l,query:{bbox:x,datetime:k,query:S,limit:q,startindex:T,f:"json"}}),D=null==(d=v.links)?void 0:d.filter((e=>"next"===e.rel)),O=0!==(null==D?void 0:D.length),{fields:N,globalIdField:Z,hasM:R,hasZ:C,objectIdField:E}=p,L=p.geometryType,J=j(v,{geometryType:L,hasZ:C,objectIdFieldName:E});if(!a($,r))for(const e of J)e.geometry&&(e.geometry=f(y(c(e.geometry,L,C,!1),r,$)));for(const e of J)e.objectId=e.attributes[E];const M=new s;return M.exceededTransferLimit=O,M.features=J,M.fields=N,M.geometryType=L,M.globalIdFieldName=Z,M.hasM=R,M.hasZ=C,M.objectIdFieldName=E,M.spatialReference=$||r,M}export{T as getCollectionDefinition,b as getServerCollection,h as getServerCollections,$ as getServerConformance,x as getServerLandingPage,k as queryFeatureSet,S as queryFeatureSetJSON,q as queryOptimizedFeatureSet};
