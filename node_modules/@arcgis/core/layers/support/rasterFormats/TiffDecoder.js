/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{Z as e}from"../../../chunks/Zlib.js";import{J as t}from"../../../chunks/Jpg.js";import{bytesToUTF8 as n}from"../rasterDatasets/byteStreamUtils.js";import{decode as a}from"./Lzw.js";import i from"./TiffTags.js";import{isPlatformLittleEndian as s}from"./utils.js";const r=[0,1,1,2,4,8,1,1,2,4,8,4,8,-1,-1,-1,8,8,8];function l(e,t){let n="unknown";return 3===e?n="f32":1===e?1===t?n="u1":2===t?n="u2":4===t?n="u4":t<=8?n="u8":t<=16?n="u16":t<=32&&(n="u32"):2===e&&(t<=8?n="s8":t<=16?n="s16":t<=32&&(n="s32")),n}function o(e){let t=null;switch(e?e.toLowerCase():"f32"){case"u1":case"u2":case"u4":case"u8":t=Uint8Array;break;case"u16":t=Uint16Array;break;case"u32":t=Uint32Array;break;case"s8":t=Int8Array;break;case"s16":t=Int16Array;break;case"s32":t=Int32Array;break;default:t=Float32Array}return t}function f(e,t){return{x:t[0]*e.x+t[1]*e.y+t[2],y:t[3]*e.x+t[4]*e.y+t[5]}}function u(e,t){const n=e.get(t);return n&&n.values}function c(e,t){const n=e.get(t);return n&&n.values[0]}function h(e,t,n,a=0,s=i.TIFF_TAGS,r=4){const l=8===r,o=l?T(new DataView(e,n,8),0,t):new DataView(e,n,2).getUint16(0,t),f=4+2*r,u=l?8:2,c=u+o*f;if(n+c>e.byteLength)return{success:!1,ifd:null,nextIFD:null,requiredBufferSize:c};const h=n+c+4<=e.byteLength?E(new DataView(e,n+c,8===r?8:4),0,t,8===r):null,g=n+u,p=new Map;let I,d,y,m,A,S,M;for(let n=0;n<o;n++)d=new DataView(e,g+f*n,f),y=d.getUint16(0,t),A=d.getUint16(2,t),m=i.getTagName(y,s),2===r?(S=d.getUint16(4,t),M=d.getUint16(6,t)):4===r?(S=d.getUint32(4,t),M=d.getUint32(8,t)):8===r&&(S=E(d,4,t,!0),M=E(d,12,t,!0)),I={id:y,type:A,valueCount:S,valueOffset:M,values:null},w(e,t,I,a,!1,r),p.set(m,I);return{success:!0,ifd:p,nextIFD:h,requiredBufferSize:c}}const g=function(n,i,r,f,u){const h=s===i,g=c(r,"BITSPERSAMPLE"),w=l(c(r,"SAMPLEFORMAT")||1,g),p=c(r,"COMPRESSION")||1,I=o(w);let T,d,E,y,m,A,S;if(1===p)E=n.slice(f,f+u),y=new Uint8Array(E);else if(8===p||32946===p)y=new Uint8Array(n,f,u),A=new e(y),S=A.getBytes(),E=new ArrayBuffer(S.length),y=new Uint8Array(E),y.set(S);else if(6===p){y=new Uint8Array(n,f,u);const e=new t;e.parse(y);const a=e.getData(e.width,e.height,!0);E=new ArrayBuffer(a.length),y=new Uint8Array(E),y.set(a)}else 5===p&&(y=a(n,f,u,i),E=y.buffer);if("u8"===w||"s8"===w||h)d=new I(E);else{switch(E=new ArrayBuffer(y.length),m=new Uint8Array(E),w){case"u16":case"s16":for(T=0;T<y.length;T+=2)m[T]=y[T+1],m[T+1]=y[T];break;case"u32":case"s32":case"f32":for(T=0;T<y.length;T+=4)m[T]=y[T+3],m[T+1]=y[T+2],m[T+2]=y[T+1],m[T+3]=y[T]}d=new I(E)}return d};function w(e,t,n,a=0,i=!1,s=4){if(n.values)return!0;const l=n.type,o=n.valueCount;let f=n.valueOffset,u=[];const c=r[l],h=8*c,g=o*c,w=o*r[l]*8;let p,I;const E=8===s?64:32;if(w>E){if(g>(i?e.byteLength:e?e.byteLength-f+a:0))return n.offlineOffsetSize=[f,g],n.values=null,!1}if(w<=E)if(t||(f>>>=32-w),1===o)u=[f];else if(64===E){const e=f>>>0,t=Math.round((f-e)/4294967296);let n=e,a=32;for(I=1;I<=o;I++){const e=32-h*I%32;if(a<h){const i=n<<e>>>32-a,s=t<<32-a>>>32-a;n=t,u.push(i+s*Math.pow(2,h-a)),a-=32-(h-a)}else u.push(n<<e>>>32-h),a-=h;0===a&&(a=32,n=t)}}else for(I=1;I<=o;I++){const e=32-h*I;u.push(f<<e>>>32-h)}else{f-=a,i&&(f=0);for(let n=f;n<f+g;n+=c){switch(l){case 1:case 2:p=new DataView(e,n,1).getUint8(0);break;case 3:p=new DataView(e,n,2).getUint16(0,t);break;case 4:p=new DataView(e,n,4).getUint32(0,t);break;case 5:p=new DataView(e,n,4).getUint32(0,t)/new DataView(e,n+4,4).getUint32(0,t);break;case 6:p=new DataView(e,n,1).getInt8(0);break;case 7:p=new DataView(e,n,1).getUint8(0);break;case 8:p=new DataView(e,n,2).getInt16(0,t);break;case 9:p=new DataView(e,n,4).getInt32(0,t);break;case 10:p=new DataView(e,n,4).getInt32(0,t)/new DataView(e,n+4,4).getInt32(0,t);break;case 11:p=new DataView(e,n,4).getFloat32(0,t);break;case 12:p=new DataView(e,n,8).getFloat64(0,t);break;case 16:case 18:p=T(new DataView(e,n,8),0,t);break;case 17:p=d(new DataView(e,n,8),0,t);break;default:p=null}u.push(p)}}if(2===l){let e="";const t=u;for(u=[],I=0;I<t.length;I++)0===t[I]&&""!==e?(u.push(e),e=""):e+=String.fromCharCode(t[I]);""===e&&0!==u.length||u.push(e)}return n.values=u,!0}function p(e){const t=e[0],n=c(t,"TILEWIDTH"),a=c(t,"TILELENGTH"),i=c(t,"IMAGEWIDTH"),s=c(t,"IMAGELENGTH"),r=c(t,"BITSPERSAMPLE"),o=c(t,"SAMPLESPERPIXEL"),h=c(t,"SAMPLEFORMAT")||1,g=l(h,r),w=!!u(t,"PLANARCONFIGURATION")&&2===u(t,"PLANARCONFIGURATION")[0],p=u(t,"GDAL_NODATA");let I;null!=p&&("string"==typeof p[0]?(I=p.map((e=>parseFloat(e))),I.some((e=>isNaN(e)))&&(I=null)):"number"==typeof p[0]&&(I=p));const T=c(t,"COMPRESSION")||1;let d;switch(T){case 1:d="NONE";break;case 2:case 3:case 4:case 32771:d="CCITT";break;case 5:d="LZW";break;case 6:case 7:d="JPEG";break;case 32773:d="PACKBITS";break;case 8:case 32946:d="DEFLATE";break;case 34712:d="JPEG2000";break;default:d=String(T)}let E=!0,y="";1!==T&&5!==T&&6!==T&&8!==T&&32946!==T&&(E=!1,y+="unsupported tag compression "+T),h>3&&(E=!1,y+="unsupported tag sampleFormat "+h),r%8!=0&&(E=!1,y+="unsupported tag bitsPerSample "+r);const m=c(t,"GEOASCIIPARAMS");let A;if(m){const e=m.split("|").filter((e=>e.indexOf("ESRI PE String = ")>-1))[0],t=e?e.replace("ESRI PE String = ",""):"";A=0===t.indexOf("PROJCS")||0===t.indexOf("GEOGCS")?{wkid:null,wkt:t}:null}const S=u(t,"GEOTIEPOINTS"),M=u(t,"GEOPIXELSCALE"),x=u(t,"GEOTRANSMATRIX"),b=t.has("GEOKEYDIRECTORY")?t.get("GEOKEYDIRECTORY").data:null;let O,D,U=!1;if(b){U=2===c(b,"GTRasterTypeGeoKey");const e=c(b,"GTModelTypeGeoKey");if(2===e){const e=c(b,"GeographicTypeGeoKey");e>=1024&&e<=32766&&(A={wkid:e})}else if(1===e){const e=c(b,"ProjectedCSTypeGeoKey");e>=1024&&e<=32766&&(A={wkid:e})}}if(M&&S&&S.length>=6?(O=[M[0],0,S[3]-S[0]*M[0],0,-Math.abs(M[1]),S[4]-S[1]*M[1]],U&&(O[2]-=.5*O[0]+.5*O[1],O[5]-=.5*O[3]+.5*O[4])):x&&16===x.length&&(O=[x[0],x[1],x[3],x[4],x[5],x[7]]),O){const e=[{x:0,y:s},{x:0,y:0},{x:i,y:s},{x:i,y:0}];let t,n=Number.POSITIVE_INFINITY,a=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY,l=Number.NEGATIVE_INFINITY;for(let i=0;i<e.length;i++)t=f(e[i],O),n=t.x>n?n:t.x,r=t.x<r?r:t.x,a=t.y>a?a:t.y,l=t.y<l?l:t.y;D={xmin:n,xmax:r,ymin:a,ymax:l,spatialReference:A}}const N=e.filter((e=>1===c(e,"NEWSUBFILETYPE")));let k,L,G,P,R;N.length>0&&(k=Math.round(Math.log(i/c(N[0],"IMAGEWIDTH"))/Math.LN2),L=Math.round(Math.log(i/c(N[N.length-1],"IMAGEWIDTH"))/Math.LN2),G=c(N[N.length-1],"TILEWIDTH"),P=c(N[N.length-1],"TILEHEIGHT")),G=L>0?G||n:null,P=L>0?P||a:null,n&&(R=[{maxCol:Math.ceil(i/n)-1,maxRow:Math.ceil(s/a)-1,minRow:0,minCol:0}],N.forEach((e=>{R.push({maxCol:Math.ceil(c(e,"IMAGEWIDTH")/c(e,"TILEWIDTH"))-1,maxRow:Math.ceil(c(e,"IMAGELENGTH")/c(e,"TILELENGTH"))-1,minRow:0,minCol:0})})));const F=function(e){if(!e)return null;const t=e.match(/<Item(.*?)Item>/gi);if(!t||0===t.length)return null;const n=new Map;let a,i,s,r,l;for(let e=0;e<t.length;e++)a=t[e],i=a.slice("<Item ".length,a.indexOf(">")),r=a.indexOf("sample="),r>-1&&(l=a.slice(r+'sample="'.length,a.indexOf('"',r+'sample="'.length))),r=a.indexOf("name="),r>-1&&(i=a.slice(r+'name="'.length,a.indexOf('"',r+'name="'.length))),i&&(s=a.slice(a.indexOf(">")+1,a.indexOf("</Item>")).trim(),null!=l?n.has(i)?n.get(i)[l]=s:n.set(i,[s]):n.set(i,s)),l=null;const o=n.get("STATISTICS_MINIMUM"),f=n.get("STATISTICS_MAXIMUM"),u=n.get("STATISTICS_MEAN"),c=n.get("STATISTICS_STDDEV");let h=null;if(o&&f){h=[];for(let e=0;e<o.length;e++)h.push({min:parseFloat(o[e]),max:parseFloat(f[e]),avg:u&&parseFloat(u[e]),stddev:c&&parseFloat(c[e])})}const g=n.get("BandName"),w=n.get("WavelengthMin"),p=n.get("WavelengthMax");let I=null;if(g){I=[];for(let e=0;e<g.length;e++)I.push({BandName:g[e],WavelengthMin:w&&parseFloat(w[e]),WavelengthMax:p&&parseFloat(p[e])})}return{statistics:h,bandProperties:I,dataType:n.get("DataType"),rawMetadata:n}}(c(e[0],"GDAL_METADATA"));return{width:i,height:s,tileWidth:n,tileHeight:a,planes:o,isBSQ:w,pixelType:g,compression:d,noData:I,isSupported:E,message:y,extent:D,firstPyramidLevel:k,maximumPyramidLevel:L,pyramidBlockWidth:G,pyramidBlockHeight:P,tileBoundary:R,metadata:F}}function I(e){const{littleEndian:t,isBigTiff:n,firstIFD:a}=y(e);let s=a;const r=[];do{const a=m(e,t,s,0,i.TIFF_TAGS,n?8:4);if(!a.success)break;r.push(a.ifd),s=a.nextIFD}while(s>0);return{...p(r),littleEndian:t,isBigTiff:n,ifds:r}}function T(e,t,n){const a=e.getUint32(t,n),i=e.getUint32(t+4,n);return n?4294967296*i+a:4294967296*a+i}function d(e,t,n){let a=n?e.getInt32(t,n):e.getUint32(t,n),i=n?e.getUint32(t+4,n):e.getInt32(t+4,n);const s=(n?a:i)>=0?1:-1;n?a*=s:i*=s;return s*(n?4294967296*i+a:4294967296*a+i)}function E(e,t,n,a){return a?T(e,t,n):e.getUint32(t,n)}function y(e){const t=new DataView(e,0,16),n=t.getUint16(0,!1);let a=null;if(18761===n)a=!0;else{if(19789!==n)throw"unexpected endianess byte";a=!1}const i=t.getUint16(2,a);if(42!==i&&43!==i)throw"unexpected tiff identifier";let s=4;const r=43===i;if(r){const e=t.getUint16(s,a);if(s+=2,8!==e)throw"unsupported bigtiff version";if(0!==t.getUint16(s,a))throw"unsupported bigtiff version";s+=2}return{littleEndian:a,isBigTiff:r,firstIFD:E(t,s,a,r)}}function m(e,t,a,s=0,r=i.TIFF_TAGS,l=4){const o=h(e,t,a,s,r,l);let f;const u=o.ifd;if(u){if(i.ifdTags.forEach(((n,a)=>{u.has(a)&&(f=u.get(a),f.data=h(e,t,f.valueOffset-s,s,n).ifd)})),u.has("GEOKEYDIRECTORY")){f=u.get("GEOKEYDIRECTORY");const n=f.values;if(n&&n.length>4){const a=n[0]+"."+n[1]+"."+n[2];f.data=h(e,t,f.valueOffset+6-s,s,i.GEO_KEYS,2).ifd,f.data&&f.data.set("GEOTIFFVersion",{id:0,type:2,valueCount:1,valueOffset:null,values:[a]})}}if(u.has("XMP")){f=u.get("XMP");const e=f.values;"number"==typeof e[0]&&7===f.type&&(f.values=[n(new Uint8Array(e))])}}return o}function A(e,t){const{headerInfo:n,ifd:a}=t,i=g(e,n.littleEndian,a,t.offset||0,t.size||e.byteLength),{pixelType:s,isBSQ:r,planes:l}=n,f=o(s),u=i.length/l;let h;const w=[];for(let e=0;e<l;e++){if(h=new f(u),r)h=i.slice(u*e,u*(e+1));else for(let t=0;t<u;t++)h[t]=i[t*l+e];w.push(h)}const p=c(a,"TILEWIDTH"),I=c(a,"TILELENGTH"),T=n.noData?n.noData[0]:null,d=n.metadata?n.metadata.statistics:null,E=d?d.map((e=>e.min)):null,y=d?d.map((e=>e.max)):null;let m,A;if(null!=T)if(m=new Uint8Array(u),Math.abs(T)>1e24)for(A=0;A<u;A++)Math.abs((w[0][A]-T)/T)<1e-6?m[A]=0:m[A]=1;else for(A=0;A<u;A++)w[0][A]===T?m[A]=0:m[A]=1;else E&&y&&t.applyMinMaxConstraint&&(m=function(e,t,n){if(!(e&&e.length>0&&t&&n))return null;let a,i,s;const r=e[0].length,l=e.length,o=new Uint8Array(r);for(let f=0;f<l;f++)if(a=e[f],i=t[f],s=n[f],0===f)for(let e=0;e<r;e++)o[e]=a[e]<i||a[e]>s?0:1;else for(let e=0;e<r;e++)o[e]&&(o[e]=a[e]<i||a[e]>s?0:1);return o}(w,E,y));return{pixelType:s,width:p,height:I,pixels:w,mask:m,noDataValue:T}}function S(n,a){a=a||I(n);const{ifds:i,noData:r}=a;if(0===i.length)throw"no valid image file directory";let l,f;const c=i[0],h=r?r[0]:null;if(f=a.tileWidth?function(e,t,n){const a=u(n,"TILEOFFSETS");if(void 0===a)return null;const i=u(n,"TILEBYTECOUNTS"),s=t.tileWidth,r=t.tileHeight,{width:l,height:f,pixelType:c,isBSQ:h}=t,w=t.planes,p=l*f,I=u(n,"BITSPERSAMPLE")[0],T=o(c),d=[];for(let e=0;e<w;e++)d.push(new T(p));let E,y,m,A,S,M,x,b,O,D,U,N,k;const L=Math.ceil(l/s);if(I%8==0)for(E=0;E<a.length;E++)for(M=Math.floor(E/L)*r,x=E%L*s,b=M*l+x,m=g(e,t.littleEndian,n,a[E],i[E]),D=0,O=b,N=Math.min(s,l-x),U=Math.min(r,f-M),y=0;y<w;y++)if(k=d[y],h)for(A=0;A<U;A++)for(O=b+A*l,D=s*r*y+A*s,S=0;S<N;S++,O++,D++)k[O]=m[D];else for(A=0;A<U;A++)for(O=b+A*l,D=A*s*w+y,S=0;S<N;S++,O++,D+=w)k[O]=m[D];return{width:l,height:f,pixelType:c,pixels:d}}(n,a,c):function(n,a,i){const r=s===a.littleEndian,l=u(i,"STRIPOFFSETS");if(void 0===l)return null;const{width:f,height:c,pixelType:h}=a,g=a.planes,w=f*c,p=u(i,"BITSPERSAMPLE")[0],I=o(h),T=new I(w*g),d=u(i,"STRIPBYTECOUNTS"),E=u(i,"ROWSPERSTRIP")[0],y=u(i,"COMPRESSION")?u(i,"COMPRESSION")[0]:1;let m,A,S,M,x,b,O,D,U,N,k,L=E;if(p%8==0)for(m=0;m<l.length;m++){if(x=m*(E*f)*g,L=(m+1)*E>c?c-m*E:E,"u8"===h||"s8"===h||r){if(8===y||32946===y)O=new Uint8Array(n,l[m],d[m]),N=new e(O),k=N.getBytes(),b=new ArrayBuffer(k.length),O=new Uint8Array(b),O.set(k),O.length!==L*f*g*p/8&&console.log("strip byte counts is different than expected");else if(6===y){O=new Uint8Array(n,l[m],d[m]);const e=new t;e.parse(O);const a=e.getData(e.width,e.height,!0);b=new ArrayBuffer(a.length),O=new Uint8Array(b),O.set(a)}else 1===y&&(d[m]!==L*f*g*p/8&&console.log("strip byte counts is different than expected"),b=n.slice(l[m],l[m]+d[m]));M=new I(b)}else{switch(6===y||8===y||32946===y?(O=new Uint8Array(n,l[m],d[m]),N=new e(O),O=N.getBytes(),b=new ArrayBuffer(O.length),D=new Uint8Array(b),O.length!==L*f*g*p/8&&console.log("strip byte counts is different than expected")):1===y&&(d[m]!==L*f*g*p/8&&console.log("strip byte counts is different than expected"),b=new ArrayBuffer(d[m]),O=new Uint8Array(n,l[m],d[m]),D=new Uint8Array(b)),h){case"u16":case"s16":for(S=0;S<O.length;S+=2)D[S]=O[S+1],D[S+1]=O[S];break;case"u32":case"s32":case"f32":for(S=0;S<O.length;S+=4)D[S]=O[S+3],D[S+1]=O[S+2],D[S+2]=O[S+1],D[S+3]=O[S]}M=new I(b)}T.set(M,x)}const G=[];if(1===g)G.push(T);else for(m=0;m<g;m++){for(U=new I(w),A=0;A<w;A++)U[A]=T[A*g+m];G.push(U)}return{width:f,height:c,pixelType:h,pixels:G}}(n,a,c),null!==h){if(f.mask=new Uint8Array(f.width*f.height),Math.abs(h)>1e24)for(l=0;l<f.width*f.height;l++)Math.abs((f.pixels[0][l]-h)/h)<1e-6?f.mask[l]=0:f.mask[l]=1;else for(l=0;l<f.width*f.height;l++)f.pixels[0][l]===h?f.mask[l]=0:f.mask[l]=1;f.noDataValue=h}return f}export{S as decode,A as decodeTileOrStrip,p as getImageInfo,w as parseFieldValues,I as parseHeader,m as parseIFD,y as parseSignature};
