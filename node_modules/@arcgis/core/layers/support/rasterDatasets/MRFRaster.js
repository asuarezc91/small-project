/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{_ as t}from"../../../chunks/tslib.es6.js";import"../../../core/has.js";import{unwrap as e,isSome as r}from"../../../core/maybe.js";import"../../../core/Logger.js";import"../../../core/accessorSupport/ensureType.js";import{property as s}from"../../../core/accessorSupport/decorators/property.js";import{subclass as o}from"../../../core/accessorSupport/decorators/subclass.js";import i from"../../../core/Error.js";import"../../../core/urlUtils.js";import"../../../core/uuid.js";import"../../../portal/support/resourceExtension.js";import{all as a}from"../../../core/promiseUtils.js";import n from"../../../geometry/SpatialReference.js";import l from"../../../geometry/Point.js";import p from"../../../geometry/Extent.js";import"../../../geometry.js";import c from"../PixelBlock.js";import f from"../RasterInfo.js";import{isPlatformLittleEndian as m}from"../rasterFormats/utils.js";import{estimateStatisticsFromHistograms as h}from"../rasterFunctions/pixelUtils.js";import u from"../RasterStorageInfo.js";import g from"./BaseRaster.js";import{getElement as d,getElementValue as y}from"./xmlUtilities.js";import{parsePAMInfo as x}from"./pamParser.js";const w=new Map;w.set("Int8","s8"),w.set("UInt8","u8"),w.set("Int16","s16"),w.set("UInt16","u16"),w.set("Int32","s32"),w.set("UInt32","u32"),w.set("Float32","f32"),w.set("Float64","f32"),w.set("Double64","f32");const I=new Map;I.set("lerc",".lrc"),I.set("none",".til"),I.set("deflate",".pzp"),I.set("jpeg",".jzp");let b=class extends g{constructor(){super(...arguments),this._files=null,this._storageIndex=null,this.datasetFormat="MRF"}async open(t){var s;await this.init(),this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const o=t?e(t.signal):null,i=await this.request(this.url,{responseType:"xml",signal:o}),{rasterInfo:a,files:n}=this._parseHeader(i.data);if(-1===(null==(s=this.ioConfig.skipExtensions)?void 0:s.indexOf("aux.xml"))){const e=await this._fetchAuxiliaryData(t);var l;if(null!=e)a.statistics=null!=(l=e.statistics)?l:a.statistics,a.histograms=e.histograms,e.histograms&&!r(a.statistics)&&(a.statistics=h(e.histograms))}this._set("rasterInfo",a),this._files=n;const p=await this.request(n.index,{responseType:"array-buffer",signal:o});this._storageIndex=this._parseIndex(p.data);let c,f,m=0,u=-1;const{blockWidth:g,blockHeight:d,compression:y}=this.rasterInfo.storageInfo,x=this.rasterInfo.storageInfo.pyramidScalingFactor,{width:w,height:I,bandCount:b}=this.rasterInfo,M=[],j="none"===y?1:b;for(;m<this._storageIndex.length;)u++,c=Math.ceil(w/g/Math.pow(x,u)),f=Math.ceil(I/d/Math.pow(x,u)),m+=c*f*j*4,M.push({maxRow:f,maxCol:c,minCol:0,minRow:0});this.rasterInfo.storageInfo.blockBoundary=M,u>0&&(this.rasterInfo.storageInfo.firstPyramidLevel=1,this.rasterInfo.storageInfo.maximumPyramidLevel=u),this.updateTileInfo()}async fetchRawTile(t,e,r,s={}){const{blockWidth:o,blockHeight:i,blockBoundary:n,compression:l}=this.rasterInfo.storageInfo,p=n[t];if(!p||p.maxRow<e||p.maxCol<r||p.minRow>e||p.minCol>r)return null;const{bandCount:f,pixelType:m}=this.rasterInfo,{ranges:h,actualTileWidth:u,actualTileHeight:g}=this._getTileLocation(t,e,r);if(!h||0===h.length)return null;if(0===h[0].from&&0===h[0].to){const t=new Uint8Array(o*i);return new c({width:o,height:i,pixels:null,mask:t,validPixelCount:0})}const{bandIds:d}=this.ioConfig,y="none"===l?1:f,x=[];let w=0;for(w=0;w<y;w++)(!d||d.indexOf[w]>-1)&&x.push(this.request(this._files.data,{range:{from:h[w].from,to:h[w].to},responseType:"array-buffer",signal:s.signal}));const I=await a(x),b=I.map((t=>t.data.byteLength)).reduce(((t,e)=>t+e)),M=new Uint8Array(b);let j=0;for(w=0;w<y;w++)M.set(new Uint8Array(I[w].data),j),j+=I[w].data.byteLength;const A="lerc"===this.rasterInfo.storageInfo.compression?"lerc":"bip",R=await this.decodePixelBlock(M.buffer,{width:o,height:i,format:A,pixelType:m});let _=0,F=0;if(u!==o||g!==i){let t=R.mask;if(t)for(w=0;w<i;w++)if(F=w*o,w<g)for(_=u;_<o;_++)t[F+_]=0;else for(_=0;_<o;_++)t[F+_]=0;else for(t=new Uint8Array(o*i),R.mask=t,w=0;w<g;w++)for(F=w*o,_=0;_<u;_++)t[F+_]=1}return R}_parseIndex(t){if(t.byteLength%16>0)throw"invalid array buffer must be multiples of 16";let e,r,s,o,i,a;if(m){for(r=new Uint8Array(t),o=new ArrayBuffer(t.byteLength),s=new Uint8Array(o),i=0;i<t.byteLength/4;i++)for(a=0;a<4;a++)s[4*i+a]=r[4*i+3-a];e=new Uint32Array(o)}else e=new Uint32Array(t);return e}_getTileLocation(t,e,r){const{blockWidth:s,blockHeight:o,pyramidScalingFactor:i,compression:a}=this.rasterInfo.storageInfo,{width:n,height:l,bandCount:p}=this.rasterInfo,c="none"===a?1:p;let f,m,h,u=0,g=0;for(h=0;h<t;h++)g=Math.pow(i,h),f=Math.ceil(n/s/g),m=Math.ceil(l/o/g),u+=f*m;g=Math.pow(i,t),f=Math.ceil(n/s/g),m=Math.ceil(l/o/g),u+=e*f+r,u*=4*c;const d=this._storageIndex.subarray(u,u+4*c);let y=0,x=0;const w=[];for(let t=0;t<c;t++)y=d[4*t+0]*Math.pow(2,32)+d[4*t+1],x=y+d[4*t+2]*Math.pow(2,32)+d[4*t+3],w.push({from:y,to:x});return{ranges:w,actualTileWidth:r<f-1?s:Math.ceil(n/g)-s*(f-1),actualTileHeight:e<m-1?o:Math.ceil(l/g)-o*(m-1)}}_parseHeader(t){const e=d(t,"MRF_META/Raster");if(!e)throw new i("mrf:open","not a valid MRF format");const r=d(e,"Size"),s=parseInt(r.getAttribute("x"),10),o=parseInt(r.getAttribute("y"),10),a=parseInt(r.getAttribute("c"),10),c=(y(e,"Compression")||"none").toLowerCase();if(!c||-1===["none","lerc"].indexOf(c))throw new i("mrf:open","currently does not support compression "+c);const m=y(e,"DataType")||"UInt8",h=w.get(m);if(null==h)throw new i("mrf:open","currently does not support pixel type "+m);const g=d(e,"PageSize"),x=parseInt(g.getAttribute("x"),10),b=parseInt(g.getAttribute("y"),10),M=d(e,"DataValues");let j,A;M&&(A=M.getAttribute("NoData"),null!=A&&(j=A.trim().split(" ").map((t=>parseFloat(t)))));if(d(t,"MRF_META/CachedSource"))throw new i("mrf:open","currently does not support MRF referencing other data files");const R=d(t,"MRF_META/GeoTags"),_=d(R,"BoundingBox");if(null==_)throw new i("mrf:open","missing node MRF_META/GeoTags/BoundingBox");const F=parseFloat(_.getAttribute("minx")),T=parseFloat(_.getAttribute("miny")),k=parseFloat(_.getAttribute("maxx")),C=parseFloat(_.getAttribute("maxy")),U=y(R,"Projection"),S=y(t,"datafile"),v=y(t,"IndexFile");let L;"LOCAL_CS[]"!==U&&(L=new n({wkt:U}));const B=new p(F,T,k,C);B.spatialReference=L;const E=d(t,"MRF_META/Rsets"),H=parseInt(E&&E.getAttribute("scale")||"2",10),P=new u({origin:new l({x:B.xmin,y:B.ymax,spatialReference:L}),blockWidth:x,blockHeight:b,pyramidBlockWidth:x,pyramidBlockHeight:b,compression:c,pyramidScalingFactor:H}),D=new l({x:(k-F)/s,y:(C-T)/o,spatialReference:L});return{rasterInfo:new f({width:s,height:o,extent:B,spatialReference:L,bandCount:a,pixelType:h,pixelSize:D,noDataValue:j,storageInfo:P}),files:{mrf:this.url,index:v||this.url.replace(".mrf",".idx"),data:S||this.url.replace(".mrf",I.get(c))}}}async _fetchAuxiliaryData(t){try{const{data:e}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:null==t?void 0:t.signal});return x(e)}catch{return null}}};t([s()],b.prototype,"_files",void 0),t([s()],b.prototype,"_storageIndex",void 0),t([s({type:String,json:{write:!0}})],b.prototype,"datasetFormat",void 0),b=t([o("esri.layers.support.rasterIO.MRFRaster")],b);var M=b;export default M;
