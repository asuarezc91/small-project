/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{isSome as e}from"../../../core/maybe.js";import t from"../../../geometry/Point.js";import"../../../geometry.js";import n from"./EphemeralBlockCache.js";import{projectExtent as o,projectResolution as r,snapPyramid as l}from"../rasterFunctions/rasterProjectionHelper.js";const c=new Map,a=new n;function i(e,t){return null==t?e:`${e}?sliceId=${t}`}function s(e,t){const n={extent:null,rasterInfo:t,cache:new Map};if(c.has(e)){const t=c.get(e);return t.push(n),t.length-1}return c.set(e,[n]),0}function u(e,t){if(c.has(e)){c.get(e)[t]=null}}function f(e){c.delete(e)}function h(e,t,n){if(!c.has(e))return null==t?a.decreaseRefCount(e,n):0;const o=c.get(e);if(null==o[t])return a.decreaseRefCount(e,n);const r=o[t].cache;if(r.has(n)){const e=r.get(n);if(e.refCount--,0===e.refCount){r.delete(n);for(let e=0;e<o.length;e++)o[e]&&o[e].cache.has(n)&&o[e].cache.delete(n);e.controller&&e.controller.abort()}return e.refCount}return 0}function m(e,t,n){if(!c.has(e))return null==t?a.getBlock(e,n):null;const o=c.get(e);if(null==o[t]){for(let e=0;e<o.length;e++)if(o[e]&&o[e].cache.has(n)){const t=o[e].cache.get(n);return t.refCount++,t.block}return a.getBlock(e,n)}const r=o[t].cache;if(r.has(n)){const e=r.get(n);return e.refCount++,e.block}for(let e=0;e<o.length;e++)if(e!==t&&o[e]&&o[e]&&o[e].cache.has(n)){const t=o[e].cache.get(n);return t.refCount++,r.set(n,t),t.block}return null}function x(e,t,n,o,r=null){if(!c.has(e))return void(null==t&&a.putBlock(e,n,o,r));const l=c.get(e);if(null==l[t])return void a.putBlock(e,n,o,r);const i={refCount:1,block:o,isResolved:!1,isRejected:!1,controller:r};o.then((()=>i.isResolved=!0)).catch((()=>i.isRejected=!0)),l[t].cache.set(n,i)}function d(e,t,n){if(!c.has(e))return void(null==t&&a.deleteBlock(e,n));const o=c.get(e);null!=o[t]?o[t].cache.delete(n):a.deleteBlock(e,n)}function y(n,a,i,s,u,f,h=null){const m=function(e,t){if(!c.has(e))return null;const n=c.get(e);return null==n[t]?null:n[t]}(n,a),x=m.extent,{cache:d,rasterInfo:y}=m;if(x&&x.xmin===i.xmin&&x.xmax===i.xmax&&x.ymin===i.ymin&&x.ymax===i.ymax)return;const g=i.clone().normalize(),{spatialReference:p,transform:k}=y,M=new Set;for(let n=0;n<g.length;n++){const c=g[n];if(c.xmax-c.xmin<=s||c.ymax-c.ymin<=s)continue;let a=o(c,p,h);e(k)&&(a=k.inverseTransform(a));const i=new t({x:s,y:s,spatialReference:c.spatialReference});if(null===u&&!(u=r(i,p,c,h)))return;const{pyramidLevel:m,pyramidResolution:x,excessiveReading:d}=l(u,y,f||"closest");if(d)return;const{storageInfo:R}=y,{origin:C}=R,j={x:Math.max(0,Math.floor((a.xmin-C.x)/x.x)),y:Math.max(0,Math.floor((C.y-a.ymax)/x.y))},v=Math.ceil((a.xmax-a.xmin)/x.x-.1),B=Math.ceil((a.ymax-a.ymin)/x.y-.1),b=m>0?R.pyramidBlockWidth:R.blockWidth,w=m>0?R.pyramidBlockHeight:R.blockHeight,$=1,I=Math.max(0,Math.floor(j.x/b)-$),H=Math.max(0,Math.floor(j.y/w)-$),E=Math.floor((j.x+v-1)/b)+$,P=Math.floor((j.y+B-1)/w)+$;for(let e=H;e<=P;e++)for(let t=I;t<=E;t++)M.add(`${m}/${e}/${t}`)}d.forEach(((e,t)=>{if(!M.has(t)){const e=d.get(t);(null==e||e.isResolved||e.isRejected)&&d.delete(t)}})),m.extent={xmin:i.xmin,ymin:i.ymin,xmax:i.xmax,ymax:i.ymax}}export{h as decreaseRefCount,d as deleteBlock,f as deleteRaster,m as getBlock,i as getRasterId,x as putBlock,s as register,u as unregister,y as update};
