/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{resolve as r}from"../../core/promiseUtils.js";import t from"../../geometry/Extent.js";import"../../geometry.js";import e from"./PixelBlock.js";import{decode as o}from"./rasterFormats/RasterCodec.js";import{estimateStatisticsHistograms as s,split as i,mosaic as m,approximateTransform as l}from"./rasterFunctions/pixelUtils.js";import n from"../../renderers/support/RasterSymbolizer.js";export default class{async decode(r){const t=await o(r.data,r.options);return t&&t.toJSON()}symbolize(o){o.pixelBlock=e.fromJSON(o.pixelBlock),o.extent=o.extent?t.fromJSON(o.extent):null;const s=this.symbolizer.symbolize(o);return r(s&&s.toJSON())}async updateSymbolizer(r){var t;this.symbolizer=n.fromJSON(r.symbolizerJSON),r.histograms&&"rasterStretch"===(null==(t=this.symbolizer)?void 0:t.rendererJSON.type)&&(this.symbolizer.rendererJSON.histograms=r.histograms)}stretch(t){const o=this.symbolizer.simpleStretch(e.fromJSON(t.srcPixelBlock),t.stretchParams);return r(o&&o.toJSON())}estimateStatisticsHistograms(t){const o=s(e.fromJSON(t.srcPixelBlock));return r(o)}split(t){const o=i(e.fromJSON(t.srcPixelBlock),t.tileSize,t.maximumPyramidLevel);return o&&o.forEach(((r,t)=>{o.set(t,null==r?void 0:r.toJSON())})),r(o)}async mosaicAndTransform(r){const t=r.srcPixelBlocks.map((r=>r?new e(r):null)),o=m(t,r.srcMosaicSize);if(!r.coefs)return o&&o.toJSON();const s=l(o,r.destDimension,r.coefs,r.sampleSpacing,r.interpolation);return s&&s.toJSON()}}
