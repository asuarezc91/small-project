/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import r from"../../core/Error.js";import{all as e,resolve as o}from"../../core/promiseUtils.js";import t from"./PixelBlock.js";import{open as n}from"../../core/workers/workers.js";export default class{constructor(){this._workerThread=null,this._destroyed=!1}async initialize(){const r=await n("RasterWorker");this._destroyed?r.close():this._workerThread=r}destroy(){this._destroyed=!0,this._workerThread&&(this._workerThread.close(),this._workerThread=null)}async decode(e,o){if(!this._workerThread)throw new r("raster-jobhandler:no-connection","no available worker connection");const n=await this._workerThread.invoke("decode",e,o);return n?new t(n):null}async symbolize(e,o){if(!this._workerThread)throw new r("raster-jobhandler:no-connection","no available worker connection");const n={extent:e.extent&&e.extent.toJSON(),pixelBlock:e.pixelBlock.toJSON(),simpleStretchParams:e.simpleStretchParams,bandIds:e.bandIds},i=await this._workerThread.invoke("symbolize",n,o);return i?new t(i):null}async updateSymbolizer(o,t){var n;if(!this._workerThread)throw new r("raster-jobhandler:no-connection","no available worker connection");const i=null==o||null==(n=o.rendererJSON)?void 0:n.histograms;await e(this._workerThread.broadcast("updateSymbolizer",{symbolizerJSON:o.toJSON(),histograms:i},t))}async stretch(e,o){if(!this._workerThread)throw new r("raster-jobhandler:no-connection","no available worker connection");if(null==e||!e.pixelBlock)return null;const n={srcPixelBlock:e.pixelBlock.toJSON(),stretchParams:e.stretchParams},i=await this._workerThread.invoke("stretch",n,o);return i?new t(i):null}async split(e,n){if(!this._workerThread)throw new r("raster-jobhandler:no-connection","no available worker connection");if(null==e||!e.pixelBlock)return null;const i={srcPixelBlock:e.pixelBlock.toJSON(),tileSize:e.tileSize,maximumPyramidLevel:e.maximumPyramidLevel},a=await this._workerThread.invoke("split",i,n);return a&&a.forEach(((r,e)=>{a.set(e,r?t.fromJSON(r):null)})),o(a)}async estimateStatisticsHistograms(e,t){if(!this._workerThread)throw new r("raster-jobhandler:no-connection","no available worker connection");if(null==e||!e.pixelBlock)return null;const n={srcPixelBlock:e.pixelBlock.toJSON()},i=await this._workerThread.invoke("estimateStatisticsHistograms",n,t);return o(i)}async mosaicAndTransform(e,o){var n;if(!this._workerThread)throw new r("raster-jobhandler:no-connection","no available worker connection");if(null==e||null==(n=e.srcPixelBlocks)||!n.length)return null;const i={...e,srcPixelBlocks:e.srcPixelBlocks.map((r=>r?r.toJSON():null))},a=await this._workerThread.invoke("mosaicAndTransform",i,o);return a?new t(a):null}}
