/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{_ as e}from"../chunks/tslib.es6.js";import"../core/has.js";import"../core/Logger.js";import"../core/accessorSupport/ensureType.js";import{property as r}from"../core/accessorSupport/decorators/property.js";import{subclass as t}from"../core/accessorSupport/decorators/subclass.js";import"../core/urlUtils.js";import"../core/uuid.js";import"../portal/support/resourceExtension.js";import{resolve as s}from"../core/promiseUtils.js";import o from"../request.js";import{normalizeCentralMeridian as i}from"../geometry/support/normalizeUtils.js";import a from"./Task.js";import{createQueryParamsHelper as p}from"../core/queryUtils.js";import{NAServiceDescriptionMixin as l}from"./mixins/NAServiceDescription.js";import c from"./support/ServiceAreaSolveResult.js";const n=p({accumulateAttributes:{name:"accumulateAttributeNames"},attributeParameterValues:!0,defaultBreaks:!0,facilities:!0,outSpatialReference:{name:"outSR",getter:e=>e.outSpatialReference.wkid},pointBarriers:{name:"barriers"},polylineBarriers:!0,polygonBarriers:!0,restrictionAttributes:{name:"restrictionAttributeNames"},returnPointBarriers:{name:"returnBarriers"},travelMode:!0});let u=class extends(l(a)){constructor(e){super(e),this.url=null}solve(e,r){const t=[],a=[],p={},l={};return e.facilities&&e.facilities.features&&this._collectGeometries(e.facilities.features,a,"facilities.features",p),e.pointBarriers&&e.pointBarriers.features&&this._collectGeometries(e.pointBarriers.features,a,"pointBarriers.features",p),e.polylineBarriers&&e.polylineBarriers.features&&this._collectGeometries(e.polylineBarriers.features,a,"polylineBarriers.features",p),e.polygonBarriers&&e.polygonBarriers.features&&this._collectGeometries(e.polygonBarriers.features,a,"polygonBarriers.features",p),i(a).then((e=>{for(const r in p){const s=p[r];t.push(r),l[r]=e.slice(s[0],s[1])}return this._isInputGeometryZAware(l,t)?this.getServiceDescription():s({dontCheck:!0})})).then((s=>{("dontCheck"in s?s.dontCheck:s.hasZ)||this._dropZValuesOffInputGeometry(l,t);for(const r in l)l[r].forEach(((t,s)=>{e.get(r)[s].geometry=t}));let i={query:{...this.parsedUrl.query,f:"json",...n.toQueryParams(e)}};return(this.requestOptions||r)&&(i={...this.requestOptions,...r,...i}),o(`${this.parsedUrl.path}/solveServiceArea`,i)})).then((e=>c.fromJSON(e.data)))}_collectGeometries(e,r,t,s){s[t]=[r.length,r.length+e.length],e.forEach((e=>{r.push(e.geometry)}))}};e([r()],u.prototype,"url",void 0),u=e([t("esri.tasks.ServiceAreaTask")],u);var m=u;export default m;
