/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import"../../core/has.js";import{isSome as e}from"../../core/maybe.js";import l from"../../core/Error.js";import{px2pt as s}from"../../core/screenUtils.js";import n from"../../renderers/visualVariables/SizeVariable.js";import{getScale as a}from"../../geometry/support/scaleUtils.js";import{createLayerAdapter as i,getLayerTypeLabels as t}from"../support/adapters/support/layerUtils.js";import o from"./scaleRange.js";const r=[10,8,4,2],c=[100,100,60,30],u=[2,1,.75,.5],m=[32,18,12,6],p=[{level:0,resolution:156543.03392800014,scale:591657527.591555},{level:1,resolution:78271.51696399994,scale:295828763.795777},{level:2,resolution:39135.75848200009,scale:147914381.897889},{level:3,resolution:19567.87924099992,scale:73957190.948944},{level:4,resolution:9783.93962049996,scale:36978595.474472},{level:5,resolution:4891.96981024998,scale:18489297.737236},{level:6,resolution:2445.98490512499,scale:9244648.868618},{level:7,resolution:1222.992452562495,scale:4622324.434309},{level:8,resolution:611.4962262813797,scale:2311162.217155},{level:9,resolution:305.74811314055756,scale:1155581.108577},{level:10,resolution:152.87405657041106,scale:577790.554289},{level:11,resolution:76.43702828507324,scale:288895.277144},{level:12,resolution:38.21851414253662,scale:144447.638572},{level:13,resolution:19.10925707126831,scale:72223.819286},{level:14,resolution:9.554628535634155,scale:36111.909643},{level:15,resolution:4.77731426794937,scale:18055.954822},{level:16,resolution:2.388657133974685,scale:9027.977411},{level:17,resolution:1.1943285668550503,scale:4513.988705},{level:18,resolution:.5971642835598172,scale:2256.994353},{level:19,resolution:.29858214164761665,scale:1128.497176}];function v(e,l){const{view:s}=e,n=l.minScale||1e8,a=s.constraints&&"effectiveLODs"in s.constraints&&s.constraints.effectiveLODs||p,i=[];for(const e in a){if(a[e].scale>n)continue;const l=Number(e),s=[l-3,l,l+3,l+6];for(const e of s)e>-1&&e<a.length&&i.push(a[e].scale);break}return i.sort(((e,l)=>e-l))}function f(e,i){const{spatialStatistics:t,minScale:o,maxScale:r}=i;if(!("avgSize"in t)||!t.avgSize)throw new l("size-range:insufficient-info","average polygon size is invalid");const c=t.avgSize,{resolution:u,scale:m}=e.view,p=u/m,{scales:v,fullExtentScale:f}=function(e,l){const{view:s,layerAdapter:n}=e,i=n.fullExtent,t=n.minScale||1128.497176,o=n.maxScale||591657527.591555,r=l.minScale||0,c=l.maxScale||0;let u=i?a(s,i):0;return u=u<t&&u>o?u:0,{scales:[t,o,r,c,u].map(Math.round).sort(((e,l)=>e-l)).filter(((e,l,s)=>!!e&&s.indexOf(e)===l)).filter(((e,l,s)=>!l||Math.abs(e-s[l-1])>5)),fullExtentScale:u}}(e,{minScale:o,maxScale:r}),w=[],g=[];v.forEach(((e,l)=>{const{min:n,max:a}=function(e,l){const s=Math.ceil(e/l);let n=Math.ceil(s/4);n<4?n=4:n>16&&(n=16);const a=5*n;return{min:n,max:a<50?50:a}}(c,p*e),i=v.indexOf(f),t=i>-1&&l>i?2:1;w.push({value:e,size:s(n/t)}),g.push({value:e,size:s(a/t)})}));return{minSize:new n({valueExpression:"$view.scale",stops:w}),maxSize:new n({valueExpression:"$view.scale",stops:g})}}async function w(a){const p=await async function(s){const{view:n}=s;if(!(s&&n&&s.layer))throw new l("size-range:missing-parameters","'view' and 'layer' parameters are required");const a=[0,2,3,1],{layer:o,...r}=s,c=i(o,a),u={layerAdapter:c,...r};if(!c)throw new l("size-range:invalid-parameters","'layer' must be one of these types: "+t(a).join(", "));await n.when();const m=e(u.signal)?{signal:u.signal}:null;await c.load(m);const p=c.geometryType;if("point"!==p&&"multipoint"!==p&&"polyline"!==p&&"polygon"!==p)throw new l("size-range:not-supported",`sizeRange is not supported for geometryType: ${p}`);return u}(a),{view:w,layerAdapter:g,signal:S}=p,h=await o({layer:g,view:w,signal:S});switch(g.geometryType){case"point":case"multipoint":return function(e,a){const{minScale:i,maxScale:t}=a,o=v(e,{minScale:i,maxScale:t});if(!o.length)throw new l("scale-range:insufficient-info","not enough scale values");return{minSize:new n({valueExpression:"$view.scale",stops:o.map(((e,l)=>({value:e,size:s(r[l])})))}),maxSize:new n({valueExpression:"$view.scale",stops:o.map(((e,l)=>({value:e,size:s(c[l])})))})}}(p,h);case"polyline":return function(e,a){const{minScale:i,maxScale:t}=a,o=v(e,{minScale:i,maxScale:t});if(!o.length)throw new l("scale-range:insufficient-info","not enough scale values");return{minSize:new n({valueExpression:"$view.scale",stops:o.map(((e,l)=>({value:e,size:s(u[l])})))}),maxSize:new n({valueExpression:"$view.scale",stops:o.map(((e,l)=>({value:e,size:s(m[l])})))})}}(p,h);case"polygon":return f(p,h);case"mesh":case"multipatch":return null}return null}export default w;
