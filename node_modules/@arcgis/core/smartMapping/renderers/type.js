/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{clone as e}from"../../core/lang.js";import{isSome as r}from"../../core/maybe.js";import s from"../../core/Error.js";import{all as l}from"../../core/promiseUtils.js";import{fetchMessageBundle as o}from"../../intl/messages.js";import"../../renderers/PointCloudRenderer.js";import{LegendOptions as i}from"../../renderers/support/LegendOptions.js";import"../../renderers/PointCloudClassBreaksRenderer.js";import"../../renderers/PointCloudRGBRenderer.js";import"../../renderers/PointCloudStretchRenderer.js";import t from"../../renderers/PointCloudUniqueValueRenderer.js";import"../../renderers/Renderer.js";import"../../renderers/ClassBreaksRenderer.js";import n from"../../renderers/UniqueValueRenderer.js";import"../../renderers/DictionaryRenderer.js";import"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/SimpleRenderer.js";import"../../renderers/support/jsonUtils.js";import{getFieldsList as a}from"../support/utils.js";import{createUniqueValueLabel as p,calculateDateFormatInterval as u}from"../../renderers/support/utils.js";import{createLayerAdapter as m,getLayerTypeLabels as d}from"../support/adapters/support/layerUtils.js";import c from"../heuristics/outline.js";import y from"../heuristics/sizeRange.js";import{getPointSizeAlgorithm as f,verifyBasicFieldValidity as b,isValidPointSize as h,createColors as v,getSymbolSizeFromScheme as g,getSymbolOutlineFromScheme as w,createSymbol as T,getBasemapInfo as j}from"./support/utils.js";import E from"../statistics/uniqueValues.js";import{c as x,g as I}from"../../chunks/type.js";async function V(e){let s=e.typeScheme,l=null,o=null;const i=await j(e.basemap,e.view);if(l=r(i.basemapId)?i.basemapId:null,o=r(i.basemapTheme)?i.basemapTheme:null,s)return{scheme:x(s),basemapId:l,basemapTheme:o};const t=I({basemap:l,basemapTheme:o,geometryType:e.geometryType,theme:e.theme,worldScale:e.worldScale,view:e.view});return t&&(s=t.primaryScheme,l=t.basemapId,o=t.basemapTheme),{scheme:s,basemapId:l,basemapTheme:o}}function z(e,r){let s;return s=e.label<r.label?-1:e.label>r.label?1:0,s}function M(e,r){let s;return s=e.value<r.value?-1:e.value>r.value?1:0,s}function S(e,r){let s=r.count-e.count;return 0===s&&(s=z(e,r)),s}function q(e,r){let s=r.count-e.count;return 0===s&&(s=M(e,r)),s}function R(e,r,s){let l;"count"===r?(l=q,s&&s.codedValues&&(l=S)):"value"===r&&(l=M,s&&s.codedValues&&(l=z)),l&&e.sort(l)}async function O(e,r){const s=e.uniqueValueInfos,l=await V({basemap:"gray",theme:"point-cloud-class",geometryType:"point",typeScheme:r}),o=l&&l.scheme,i="point-cloud-class"===o.theme,t=i?o.colors:v(o.colors,s.length);return R(s,"value"),s.map(((e,r)=>{const s=e.value;let l=null;return i?(l=t[s],l||(l=t[t.length-1])):l=t[r],{values:[s],color:l,label:e.label}}))}async function C(t){const f=await async function(l){if(!l||!l.layer||!l.field&&!l.valueExpression)throw new s("type-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(l.valueExpression&&!l.view)throw new s("type-renderer:missing-parameters","View is required when 'valueExpression' is specified");const o={...l};o.symbolType=o.symbolType||"2d",o.numTypes=null==o.numTypes?10:o.numTypes,o.defaultSymbolEnabled=null==o.defaultSymbolEnabled||o.defaultSymbolEnabled,o.sortBy=null==o.sortBy?"count":o.sortBy,o.sortEnabled=null==o.sortEnabled||o.sortEnabled,o.statistics=e(o.statistics);const i=[0,2,1,3],t=m(o.layer,i);if(o.layer=t,!t)throw new s("type-renderer:invalid-parameters","'layer' must be one of these types: "+d(i).join(", "));const n=r(o.signal)?{signal:o.signal}:null;await t.load(n);const p=t.geometryType;if(o.outlineOptimizationEnabled="polygon"===p&&o.outlineOptimizationEnabled,o.sizeOptimizationEnabled=("point"===p||"multipoint"===p||"polyline"===p)&&o.sizeOptimizationEnabled,"mesh"===p)o.symbolType="3d-volumetric",o.colorMixMode=o.colorMixMode||"replace",o.edgesType=o.edgesType||"none";else{if("3d-volumetric-uniform"===o.symbolType&&"point"!==p)throw new s("type-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(o.symbolType.indexOf("3d-volumetric")>-1&&(!o.view||"3d"!==o.view.type))throw new s("type-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const u=await a({field:o.field,valueExpression:o.valueExpression}),c=b(t,u,"type-renderer:invalid-parameters");if(c)throw c;return o}(t),{layer:h,view:j,signal:I}=f,z={layer:h,field:f.field,valueExpression:f.valueExpression,returnAllCodedValues:f.returnAllCodedValues,view:j,signal:I},[M,S,q]=await l([null!=f.statistics?f.statistics:E(z),f.outlineOptimizationEnabled?c({layer:h,view:j,signal:I}):null,f.sizeOptimizationEnabled?y({layer:h,view:j,signal:I}):null]);return async function(e,r,s,l){const t=await o("esri/smartMapping/t9n/smartMapping"),a=e.uniqueValueInfos,m=r.layer,d=r.field,c=d?m.getField(d):null,y=c?m.getFieldDomain(c.name):null,f=-1===r.numTypes?a.length:r.numTypes,b=m.geometryType,h=await V({basemap:r.basemap,geometryType:b,typeScheme:r.typeScheme,worldScale:r.symbolType.indexOf("3d-volumetric")>-1,view:r.view}),j=h.scheme,E=new n({field:d});let I,z=-1;const M={value:null,domain:y,fieldInfo:c};if(a.forEach(((e,r)=>{M.value=e.value,e.label=p(M),null===e.value&&(z=r)})),z>-1&&(I=a.splice(z,1)[0]),!1!==r.sortEnabled&&R(a,r.sortBy,y),c&&"date"===c.type){const e=a.filter(((e,r)=>r<f)).map((e=>e.value));M.dateFormatInterval=u(e)}const S=s&&s.opacity;let q=v(j.colors,a.length);const O=g(j,b),C=w(j,b,S);a.forEach(((e,s)=>{M.value=e.value,e.label=p(M),e.symbol=T(b,{type:r.symbolType,color:q[s],size:O,outline:C,meshInfo:{colorMixMode:r.colorMixMode,edgesType:r.edgesType}})})),r.valueExpression&&(E.valueExpression=r.valueExpression,E.valueExpressionTitle=r.valueExpressionTitle),r.legendOptions&&(E.legendOptions=new i(r.legendOptions)),q=v(j.colors,f);for(let e=0;e<f;e++){const s=a[e];s&&E.addUniqueValueInfo({value:s.value,label:s.label,symbol:T(b,{type:r.symbolType,color:q[e],size:O,outline:C,meshInfo:{colorMixMode:r.colorMixMode,edgesType:r.edgesType}})})}r.defaultSymbolEnabled&&(E.defaultSymbol=T(b,{type:r.symbolType,color:j.noDataColor,size:O,outline:C,meshInfo:{colorMixMode:r.colorMixMode,edgesType:r.edgesType}}),E.defaultLabel=t.other),I&&(I.symbol=T(b,{type:r.symbolType,color:j.noDataColor,size:O,outline:C,meshInfo:{colorMixMode:r.colorMixMode,edgesType:r.edgesType}}),a.push(I));const U=[],B=E.uniqueValueInfos.length===a.length?-1:E.uniqueValueInfos.length;if(B>-1)for(let e=B;e<a.length;e++)U.push({...a[e]});return s&&s.visualVariables&&s.visualVariables.length&&(E.visualVariables=s.visualVariables.map((e=>e.clone()))),l&&l.minSize&&(E.visualVariables?E.visualVariables.push(l.minSize):E.visualVariables=[l.minSize]),{renderer:E,uniqueValueInfos:a,excludedUniqueValueInfos:U,typeScheme:x(j),basemapId:h.basemapId,basemapTheme:h.basemapTheme}}(M,f,S,q)}async function U(l){const o=await async function(l){if(!(l&&l.layer&&l.field))throw new s("type-point-cloud-class-renderer:missing-parameters","'layer' and 'field' parameters are required");const o={...l};o.statistics=e(o.statistics);const i=[4],t=m(o.layer,i);if(o.layer=t,o.density=o.density||25,o.size=o.size||"100%",!h(o.size))throw new s("type-point-cloud-class-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'");if(!t)throw new s("type-point-cloud-class-renderer:invalid-parameters","'layer' must be one of these types: "+d(i).join(", "));const n=r(o.signal)?{signal:o.signal}:null;await t.load(n);const p=await a({field:o.field}),u=b(t,p,"type-point-cloud-class-renderer:invalid-parameters");if(u)throw u;return o}(l),i=null!=o.statistics?o.statistics:await E({layer:o.layer,field:o.field,signal:o.signal});return{renderer:new t({field:o.field,pointsPerInch:o.density,pointSizeAlgorithm:f(o.size),colorUniqueValueInfos:await O(i,o.typeScheme)})}}export{U as createPCClassRenderer,C as createRenderer};
