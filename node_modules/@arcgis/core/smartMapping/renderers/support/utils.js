/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import"../../../core/has.js";import{isSome as e}from"../../../core/maybe.js";import t from"../../../core/Error.js";import{all as o}from"../../../core/promiseUtils.js";import{formatDate as n,convertDateFormatToIntlOptions as i}from"../../../intl/date.js";import s from"../../../Color.js";import l from"../../../symbols/ExtrudeSymbol3DLayer.js";import r from"../../../symbols/SimpleLineSymbol.js";import a from"../../../symbols/FillSymbol3DLayer.js";import m from"../../../symbols/IconSymbol3DLayer.js";import u from"../../../symbols/LineSymbol3DLayer.js";import c from"../../../symbols/ObjectSymbol3DLayer.js";import f from"../../../symbols/PathSymbol3DLayer.js";import d from"../../../symbols/LineSymbol3D.js";import p from"../../../symbols/MeshSymbol3D.js";import y from"../../../symbols/PointSymbol3D.js";import h from"../../../symbols/PolygonSymbol3D.js";import b from"../../../symbols/SimpleFillSymbol.js";import w from"../../../symbols/SimpleMarkerSymbol.js";import"../../../chunks/symbols.js";import g from"../../../renderers/support/pointCloud/PointSizeSplatAlgorithm.js";import{getBasemapId as D,getBasemapGroup as j,defaultBasemapGroups as v}from"../../support/utils.js";import{round as x}from"../../../renderers/support/numberUtils.js";import S from"../../statistics/summaryStatistics.js";import z from"../../heuristics/outline.js";import V from"../../statistics/classBreaks.js";import{getBackgroundColorTheme as L}from"../../../views/support/colorUtils.js";const U=/^(\d+(\.\d+)?)\s*(%)$/i,k=[0,0,0,.4],I=["hours","minutes","seconds"],T=[].concat(v.light).concat(v.dark);function B(e,t,o){if("string"==typeof e){const t=o.getField(e);if(t&&"date"===t.type)return t.alias||t.name}else if("number"==typeof e||e instanceof Date){const o=I.indexOf(t)>-1?"short-date-short-time":"short-date";return n(e,i(o))}return e}function F(e,o){return new t(e,o)}function M(e,t,o){return e+t>0&&0>e-t&&o<0?0:e}function C(e,t,o,n,i=!0){const s="90-10"===o&&t?{min:t.classBreakInfos[0].maxValue,max:t.classBreakInfos[t.classBreakInfos.length-1].minValue,avg:null,stddev:null}:e,{avg:l,stddev:r,min:a,max:m}=s,u=P(s,n,i);let c=u?u[0]:a,f=u?u[1]:m;return u?{minDataValue:c,maxDataValue:f,defaultValuesUsed:!0}:("above"===o?c=M(l,r,a):"below"===o&&(f=M(l,r,a)),{minDataValue:c,maxDataValue:f,defaultValuesUsed:!1})}function P(e,t,o){let n,i;const s=function(e){let t,o,n=e&&e.statistics;n||(n={});if(null==n.min)if(e.isDate){const e=A();t=e[0],o=e[1]}else t=0,o=100;else if(n.min===n.max)if(e.isDate){const e=A(n.min);t=e[0],o=e[1]}else n.min<0?(t=2*n.min,o=0):n.min>0?(t=0,o=2*n.min):(t=0,o=100);return{min:null!=t?t:n.min,max:null!=o?o:n.max,defaultValuesUsed:null!=t||null!=o}}({statistics:e,isDate:t});return s.defaultValuesUsed?(n=s.min,i=s.max):!o||null!=e.avg&&e.stddev||(n=e.min,i=e.max),null!=n?[n,i]:null}function A(e){const t=("number"==typeof e?new Date(e):new Date).getUTCFullYear();let o=Date.UTC(t,0,1,12,0,0,0),n=Date.UTC(t,11,31,12,0,0,0);return"number"==typeof e&&(e<o&&(o=e),e>n&&(n=e)),[o,n]}function O(e,t){const o=[],n=e.length;for(let i=0;i<t;i++)o.push(new s(e[i%n]));return o}function R(e,t,o,n=!0){const{minDataValue:i,maxDataValue:s,defaultValuesUsed:l}=e;return l||"above"===o||"below"===o||"90-10"===o?E(i,s,5):W(t,n)}function Y(e){const{avg:t,stddev:o,min:n,max:i}=e;if(null==t||null==o)return E(n,i,5);const s=M(t,o,n),l=i-s,r=s-n,a=Math.max(l,r);return x([s-a,s-a/2,s,a/2+s,s+a],{strictBounds:!0})}function E(e,t,o){const n=(t-e)/(o-1),i=[e];for(let t=1;t<=o-2;t++)i.push(e+t*n);return i.push(t),x(i,{strictBounds:!0})}function W(e,t=!0){let o=e.avg,n=o-e.stddev,i=o+e.stddev;n<e.min&&(n=e.min),i>e.max&&(i=e.max),t&&(o=n+(i-n)/2);let s=x([n,i],{strictBounds:!0});return n=s[0],i=s[1],s=[n,n+(o-n)/2,o,o+(i-o)/2,i],x(s,{strictBounds:!0})}function q(e,t,o){switch(t){case"point":case"multipoint":return o?"noDataSize"in e?e.noDataSize:null:"size"in e?e.size:null;case"polyline":return o?"noDataWidth"in e?e.noDataWidth:null:"width"in e?e.width:null;case"polygon":return"size"in e?e.size:null;case"mesh":default:return}}function N(e,t,o){switch(t){case"point":case"multipoint":case"polygon":{if(!("outline"in e))return null;const t={color:e.outline.color,width:e.outline.width};if(null!=o&&t.color){const e=t.color.clone();e.a=o,t.color=e}return t}case"polyline":case"mesh":default:return}}function $(e,t){const{type:o,size:n,color:i,outline:s}=t;let g;switch(e){case"point":case"multipoint":if("2d"===o)g=new w({color:i,size:n,outline:{color:s.color,width:s.width}});else if("3d-flat"===o)g=new y({symbolLayers:[new m({size:n,resource:{primitive:"circle"},material:{color:i},outline:{color:s.color,size:s.width}})]});else if(o.indexOf("3d-volumetric")>-1){const e="3d-volumetric-uniform"===o,s=new c({height:n,resource:{primitive:e?"sphere":"cylinder"},material:{color:i}});e||(s.width=t.widthAndDepth,s.depth=t.widthAndDepth),g=new y({symbolLayers:[s]})}break;case"polyline":"2d"===o?g=new r({color:i,width:n}):"3d-flat"===o?g=new d({symbolLayers:[new u({size:n,material:{color:i}})]}):"3d-volumetric"===o&&(g=new d({symbolLayers:[new f({size:n,material:{color:i}})]}));break;case"polygon":"2d"===o?g=new b({color:i,outline:{color:s.color,width:s.width}}):"3d-flat"===o?g=new h({symbolLayers:[new a({material:{color:i},outline:{color:s.color,size:s.width}})]}):"3d-volumetric"===o&&(g=new h({symbolLayers:[new l({size:n,material:{color:i}})]}));break;case"mesh":{const e=t.meshInfo&&t.meshInfo.colorMixMode,o=t.meshInfo&&t.meshInfo.edgesType;g=new p({symbolLayers:[new a({material:{color:i,colorMixMode:e},edges:null==o||"none"===o?null:{type:o,color:k}})]});break}}return g}function G(e,t,o){const n=function(e){const t=e.layer;return e.fields.filter((e=>!t.getField(e)))}({layer:e,fields:t});if(n.length)return F(o,"Unknown fields: "+n.join(", ")+". You can only use fields defined in the layer schema");const i=function(e){const t=e.layer;return e.fields.filter((e=>{const o=t.getFieldUsageInfo(e);return!o||!o.supportsRenderer}))}({layer:e,fields:t});return i.length?F(o,"Unsupported fields: "+i.join(", ")+". You can only use fields that are accessible to the renderer i.e. FieldUsageInfo.supportsRenderer must be true"):void 0}async function H(e,t){const n={layer:e.layer,view:e.view,signal:e.signal},[i,s]=await o([V(e),t?z(n):null]),l=P({min:i.minValue,max:i.maxValue,avg:null,stddev:null},!1,!1);return{result:l?await V({...e,classificationMethod:"equal-interval",numClasses:1,analyzeData:!1,minValue:l[0],maxValue:l[1],normalizationTotal:l[0]+l[1]}):i,defaultValuesUsed:!!l,outlineResult:s}}function J(e){return S(e)}function K(e,t){let{minSize:o,maxSize:n}=e;if("height"===t){o=((n-o)/2+o)/(2*2.3),n*=2}return{minSize:o,maxSize:n}}function Q(e){return U.test(e)}function X(e){const t=e.match(U),o=Number(t[1]);if("%"===t[3])return new g({scaleFactor:o/100})}function Z(e,t,o,n){e.startTime=t instanceof Date?t.getTime():t,e.endTime=o instanceof Date?o.getTime():o,e.units=n,e.field="string"==typeof t?t:"string"==typeof o?o:null}async function _(t,o){let n=null,i=null;if(!t&&!o)return{basemapId:n,basemapTheme:i};var s;!t&&o&&(t=o&&(null==(s=o.map)?void 0:s.basemap));if(t&&(n=D(t,T,!1),n)){const t=j(n);e(t)&&(i=t)}return n||"2d"!==(null==o?void 0:o.type)||(i=await L(o),e(i)&&(n="dark"===i?"dark-gray":"gray")),{basemapId:n,basemapTheme:i}}export{O as createColors,R as createDataValues,E as createDefaultStopValues,F as createError,W as createStopValues,Y as createStopValuesForAboveBelow,$ as createSymbol,B as formatDate,M as getBaseValueForAboveBelow,_ as getBasemapInfo,H as getClassBreaks,C as getDataRange,P as getDefaultDataRange,X as getPointSizeAlgorithm,K as getSizeRangeForAxis,J as getSummaryStatistics,N as getSymbolOutlineFromScheme,q as getSymbolSizeFromScheme,Q as isValidPointSize,Z as updateAgeRendererAuthoringInfoVV,G as verifyBasicFieldValidity};
