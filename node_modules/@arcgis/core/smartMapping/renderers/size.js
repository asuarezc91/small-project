/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{isSome as e}from"../../core/maybe.js";import i from"../../core/Error.js";import{all as a}from"../../core/promiseUtils.js";import{toPt as s}from"../../core/screenUtils.js";import{substitute as n}from"../../intl/substitute.js";import{fetchMessageBundle as l}from"../../intl/messages.js";import r from"../../renderers/support/AuthoringInfoVisualVariable.js";import o from"../../renderers/support/AuthoringInfo.js";import"../../renderers/Renderer.js";import t from"../../renderers/visualVariables/SizeVariable.js";import m from"../../renderers/ClassBreaksRenderer.js";import"../../renderers/UniqueValueRenderer.js";import"../../renderers/DictionaryRenderer.js";import"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/SimpleRenderer.js";import"../../renderers/support/jsonUtils.js";import{getFieldsList as p,getNormalizationType as u}from"../support/utils.js";import{setLabelsForClassBreaks as d}from"../../renderers/support/utils.js";import{createLayerAdapter as y,getLayerTypeLabels as c}from"../support/adapters/support/layerUtils.js";import{getAgeExpressions as b,verifyDates as f,supportedAgeUnits as w}from"../statistics/support/ageUtils.js";import v from"../heuristics/ageUnit.js";import h from"../heuristics/outline.js";import z from"../heuristics/sizeRange.js";import{getSummaryStatistics as g,getClassBreaks as x,formatDate as T,updateAgeRendererAuthoringInfoVV as S,verifyBasicFieldValidity as E,getDataRange as V,getSizeRangeForAxis as j,createSymbol as k,getSymbolOutlineFromScheme as O,getSymbolSizeFromScheme as I,getBasemapInfo as q}from"./support/utils.js";import{c as F,g as U}from"../../chunks/size.js";const D=Math.pow(2,53)-1;function M(e){const i={...e},a=i.symbolType.indexOf("3d-volumetric")>-1,s=i;return s.worldScale=a,a&&(s.axis="3d-volumetric-uniform"===i.symbolType?"all":"height"),delete i.symbolType,delete i.defaultSymbolEnabled,s}async function R(i){let a=i.sizeScheme,s=null,n=null;const l=await q(i.basemap,i.view);if(s=e(l.basemapId)?l.basemapId:null,n=e(l.basemapTheme)?l.basemapTheme:null,a)return{scheme:F(a),basemapId:s,basemapTheme:n};const r=U({basemap:s,basemapTheme:n,geometryType:i.geometryType,worldScale:i.worldScale,view:i.view});return r&&(a=r.primaryScheme,s=r.basemapId,n=r.basemapTheme),{scheme:a,basemapId:s,basemapTheme:n}}function B(e,i){let a;switch(i){case"point":case"multipoint":{const i=e;a=[i.minSize,i.maxSize];break}case"polyline":{const i=e;a=[i.minWidth,i.maxWidth];break}case"polygon":{const i=e;a=[i.marker.minSize,i.marker.maxSize];break}}return a}async function A(e,i,a,s,n){const r=await l("esri/smartMapping/t9n/smartMapping"),o=n.layer,t=n.field,p=o.geometryType,u=n.defaultSymbolEnabled,d=F(e.sizeScheme),y="polygon"===p,c=y?d.marker:d,b=y?d.background:null,f=y?"point":p,w=i&&i.opacity,v=e.visualVariables.map((e=>e.clone()));i&&i.visualVariables&&i.visualVariables.length&&v.push(...i.visualVariables.map((e=>e.clone())));return{renderer:new m({backgroundFillSymbol:b&&k(p,{type:n.symbolType,color:b.color,outline:O(b,p,w)}),classBreakInfos:[{minValue:-D,maxValue:D,symbol:k(f,{type:n.symbolType,color:c.color,size:I(c,f),outline:O(c,f,w)})}],defaultLabel:u?r.other:null,defaultSymbol:u?k(f,{type:n.symbolType,color:c.noDataColor,size:I(c,f,!0),outline:O(c,f,w)}):null,field:t,normalizationField:s,normalizationType:a,valueExpression:n.valueExpression,valueExpressionTitle:n.valueExpressionTitle,visualVariables:v,authoringInfo:e.authoringInfo&&e.authoringInfo.clone()}),visualVariables:e.visualVariables.map((e=>e.clone())),statistics:e.statistics,defaultValuesUsed:e.defaultValuesUsed,sizeScheme:F(e.sizeScheme),basemapId:e.basemapId,basemapTheme:e.basemapTheme}}async function C(e,i){const a=await l("esri/smartMapping/t9n/smartMapping"),n=e.layer,r=e.defaultSymbolEnabled,t=n.geometryType,p="polygon"===t,u=e.symbolType.indexOf("3d-volumetric")>-1,y=await R({basemap:e.basemap,geometryType:t,sizeScheme:e.sizeScheme,worldScale:u,view:e.view}),c=y.scheme,{result:b,outlineResult:f}=i,w=b.classBreakInfos,v=e.classificationMethod,h=e.normalizationType,z=p?c.marker:c,g=p?c.background:null,x=p?"point":t,T=B(z,x),S=u&&j({minSize:T[0],maxSize:T[1]},"height"),E=function(e,i){const a=s(e.minSize),n=(s(e.maxSize)-a)/(i>=4?i-1:i),l=[];for(let e=0;e<i;e++)l.push(a+n*e);return l}({minSize:T[0],maxSize:u?S.maxSize:T[1]},w.length),V=f&&f.opacity,q=new m({backgroundFillSymbol:g&&k(t,{type:e.symbolType,color:g.color,outline:O(g,t,V)}),classBreakInfos:w.map(((i,a)=>({minValue:i.minValue,maxValue:i.maxValue,symbol:k(x,{type:e.symbolType,color:z.color,size:E[a],widthAndDepth:S&&S.minSize,outline:O(z,x,V)}),label:i.label}))),defaultLabel:r?a.other:null,defaultSymbol:r?k(x,{type:e.symbolType,color:z.noDataColor,size:I(z,x,!0),widthAndDepth:S&&S.minSize,outline:O(z,x,V)}):null,field:e.field,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,normalizationType:h,normalizationField:e.normalizationField,normalizationTotal:"percent-of-total"===h?b.normalizationTotal:void 0,legendOptions:e.legendOptions,authoringInfo:new o({type:"class-breaks-size",classificationMethod:v,standardDeviationInterval:e.standardDeviationInterval})});return"standard-deviation"!==v&&d({classBreakInfos:q.classBreakInfos,classificationMethod:v,normalizationType:h,round:!0}),f&&f.visualVariables&&f.visualVariables.length&&(q.visualVariables=f.visualVariables.map((e=>e.clone()))),{renderer:q,sizeScheme:F(c),classBreaksResult:b,defaultValuesUsed:i.defaultValuesUsed,basemapId:y.basemapId,basemapTheme:y.basemapTheme}}async function W(s){const n=await async function(a){if(!(a&&a.layer&&(a.field||a.valueExpression||a.sqlExpression)))throw new i("size-visual-variable:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(a.valueExpression&&!a.sqlExpression&&!a.view)throw new i("size-visual-variable:missing-parameters","View is required when 'valueExpression' is specified");const s={...a};if("90-10"===s.theme)throw new i("size-visual-variable:not-supported","Only 'high-to-low', 'above', 'below' themes are supported.");const n=[0,2,1,3],l=y(s.layer,n);if(s.layer=l,!l)throw new i("size-visual-variable:invalid-parameters","'layer' must be one of these types: "+c(n).join(", "));"height"===s.axis&&(s.sizeOptimizationEnabled=!1);const r=e(s.signal)?{signal:s.signal}:null;await l.load(r);const o=l.geometryType;if("mesh"===o)throw new i("size-visual-variable:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(s.worldScale){if("polyline"===o||"polygon"===o)throw new i("size-visual-variable:not-supported","'worldScale' sizing is not supported for polyline and polygon layers");if(!s.view||"3d"!==s.view.type)throw new i("size-visual-variable:invalid-parameters","'view' parameter should be an instance of SceneView when 'worldScale' parameter is true")}const t=await p({field:s.field,normalizationField:s.normalizationField,valueExpression:s.valueExpression}),m=E(l,t,"size-visual-variable:invalid-parameters");if(m)throw m;return s}(s),{view:l,field:m,valueExpression:u,minValue:d,maxValue:b,layer:f,normalizationField:w,signal:v,statistics:h}=n,T=w?"field":void 0,[S,k,O]=await a([h||g({layer:f,field:m,valueExpression:u,sqlExpression:n.sqlExpression,sqlWhere:n.sqlWhere,normalizationType:T,normalizationField:w,minValue:d,maxValue:b,view:l,signal:v}),"90-10"===n.theme?x({layer:f,field:m,normalizationField:w,valueExpression:u,classificationMethod:"quantile",minValue:d,maxValue:b,view:l,numClasses:10,signal:v}):null,n.sizeOptimizationEnabled?z({view:l,layer:f,signal:v}):null]);return async function(e,a,s,n){const{theme:l,field:m,normalizationField:p,minValue:u,maxValue:d,axis:y}=e,c=e.layer,b=m&&"function"!=typeof m?c.getField(m):null,f=b&&"date"===b.type,w=c.geometryType,v=await R({basemap:e.basemap,geometryType:w,sizeScheme:e.sizeScheme,worldScale:e.worldScale,view:e.view}),h=v.scheme;if(!h)throw new i("size-visual-variable:insufficient-info","Unable to find size scheme");const z=n&&[n.minSize,n.maxSize]||B(h,w),{minDataValue:g,maxDataValue:x,defaultValuesUsed:T}=V(a,s,l,f,"above"===l||"below"===l),S=[],E="height"===y,k=E?y:void 0,O=z[0];let I=z[1];if(E&&"number"==typeof O&&"number"==typeof I){const e=j({minSize:O,maxSize:I},k);S.push(new t({axis:"width-and-depth",minSize:e.minSize})),I=e.maxSize}const q=new t({field:m,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,valueUnit:"unknown",normalizationField:p,axis:k,minSize:O,maxSize:I,minDataValue:g,maxDataValue:x,legendOptions:e.legendOptions});!function(e,i){"clamped-linear"===e.transformationType&&"below"===i&&e.flipSizes()}(q,l),S.unshift(q);const U=new r({type:"size",theme:l,minSliderValue:null!=u?u:a.min,maxSliderValue:null!=d?d:a.max}),D=new o({visualVariables:[U]});return{basemapId:v.basemapId,basemapTheme:v.basemapTheme,visualVariables:S,statistics:a,defaultValuesUsed:T,sizeScheme:F(h),authoringInfo:D}}(n,S,null==k?void 0:k.result,O)}async function L(s){const n=await async function(a){if(!(a&&a.layer&&(a.field||a.valueExpression||a.sqlExpression)))throw new i("size-continuous-renderer:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(a.valueExpression&&!a.sqlExpression&&!a.view)throw new i("size-continuous-renderer:missing-parameters","View is required when 'valueExpression' is specified");const s={...a};s.symbolType=s.symbolType||"2d",s.defaultSymbolEnabled=null==s.defaultSymbolEnabled||s.defaultSymbolEnabled;const n=[0,2,1,3],l=y(s.layer,n);if(s.layer=l,!l)throw new i("size-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+c(n).join(", "));const r=e(s.signal)?{signal:s.signal}:null;await l.load(r);const o=l.geometryType,t=s.symbolType.indexOf("3d")>-1;if(s.outlineOptimizationEnabled="polygon"===o&&s.outlineOptimizationEnabled,"mesh"===o)throw new i("size-continuous-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(t&&("polyline"===o||"polygon"===o))throw new i("size-continuous-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(s.symbolType.indexOf("3d-volumetric")>-1&&(!s.view||"3d"!==s.view.type))throw new i("size-continuous-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");const m=await p({field:s.field,normalizationField:s.normalizationField,valueExpression:s.valueExpression}),u=E(l,m,"size-continuous-renderer:invalid-parameters");if(u)throw u;return s}(s),l={layer:n.layer,view:n.view,signal:n.signal},[r,o]=await a([W(M(n)),n.outlineOptimizationEnabled?h(l):null]),t=n.normalizationField;return A(r,o,t?"field":void 0,t,n)}async function $(a){const s=await async function(a){if(!a||!a.layer||!a.field&&!a.valueExpression)throw new i("size-class-breaks-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(a.valueExpression&&!a.view)throw new i("size-class-breaks-renderer:missing-parameters","View is required when 'valueExpression' is specified");const s={...a};s.symbolType=s.symbolType||"2d",s.defaultSymbolEnabled=null==s.defaultSymbolEnabled||s.defaultSymbolEnabled,s.classificationMethod=s.classificationMethod||"equal-interval",s.normalizationType=u(s);const n=[0,2,1,3],l=y(s.layer,n);if(s.layer=l,!l)throw new i("size-class-breaks-renderer:invalid-parameters","'layer' must be one of these types: "+c(n).join(", "));if(!(null!=s.minValue&&null!=s.maxValue||null==s.minValue&&null==s.maxValue))throw new i("size-class-breaks-renderer:missing-parameters","Both 'minValue' and 'maxValue' are required when specifying custom data range");const r=e(s.signal)?{signal:s.signal}:null;await l.load(r);const o=l.geometryType,t=s.symbolType.indexOf("3d")>-1;if(s.outlineOptimizationEnabled="polygon"===o&&s.outlineOptimizationEnabled,"mesh"===o)throw new i("size-class-breaks-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(t&&("polyline"===o||"polygon"===o))throw new i("size-class-breaks-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(s.symbolType.indexOf("3d-volumetric")>-1&&(!s.view||"3d"!==s.view.type))throw new i("size-class-breaks-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");const m=await p({field:s.field,normalizationField:s.normalizationField}),d=E(l,m,"size-class-breaks-renderer:invalid-parameters");if(d)throw d;return s}(a);return C(s,await x(function(e){const i={...e};delete i.basemap,delete i.sizeScheme,delete i.legendOptions,delete i.symbolType,delete i.defaultSymbolEnabled;const a=i;return a.analyzeData=!(null!=i.minValue&&null!=i.maxValue),a}(s),s.outlineOptimizationEnabled))}async function H(s){const r=await async function(a){if(!(a&&a.layer&&a.view&&a.startTime&&a.endTime))throw new i("size-age-renderer:missing-parameters","'layer', 'view', 'startTime', 'endTime' parameters are required");const s={...a};s.symbolType=s.symbolType||"2d",s.defaultSymbolEnabled=null==s.defaultSymbolEnabled||s.defaultSymbolEnabled;const n=[0,2,1,3],l=y(s.layer,n);if(s.layer=l,!l)throw new i("size-age-renderer:invalid-parameters","'layer' must be one of these types: "+c(n).join(", "));const r=e(s.signal)?{signal:s.signal}:null;await l.load(r);const o=l.geometryType,t=s.symbolType.indexOf("3d")>-1;if(s.outlineOptimizationEnabled="polygon"===o&&s.outlineOptimizationEnabled,"mesh"===o)throw new i("size-age-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(t&&("polyline"===o||"polygon"===o))throw new i("size-age-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(s.symbolType.indexOf("3d-volumetric")>-1&&(!s.view||"3d"!==s.view.type))throw new i("size-age-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");const m=f(l,s.startTime,s.endTime,"size-age-renderer:invalid-parameters");if(m)throw m;if(s.unit&&-1===w.indexOf(s.unit))throw new i("size-age-renderer:invalid-unit",`Supported units are: ${w.join(", ")}`);return s}(s),{defaultSymbolEnabled:o,view:t,startTime:m,endTime:p,symbolType:u,minValue:d,maxValue:z,signal:g}=r,x=r.layer,E={layer:r.layer,view:r.view,signal:g},[V,j]=await a([r.unit?{unit:r.unit,statistics:null,valueExpression:null}:await v({view:t,layer:x,startTime:m,endTime:p,minValue:d,maxValue:z,signal:g}),r.outlineOptimizationEnabled?h(E):null]),{unit:k,statistics:O}=V,I=b({layer:x,startTime:m,endTime:p,unit:k}).valueExpression,q=await l("esri/smartMapping/t9n/smartMapping"),F=n(q[`ageInfo_${k}`],{unit:k,startTime:T(m,k,x),endTime:T(p,k,x)}),U=await W(M({layer:x,basemap:r.basemap,valueExpression:I,symbolType:u,statistics:O,legendOptions:{title:F},theme:r.theme,sizeScheme:r.sizeScheme,sizeOptimizationEnabled:r.sizeOptimizationEnabled,view:r.view,minValue:d,maxValue:z,signal:g})),D={layer:x,valueExpression:I,defaultSymbolEnabled:o,symbolType:u},R=await A(U,j,null,null,D);return R.renderer.authoringInfo.visualVariables.forEach((e=>S(e,m,p,k))),{...R,unit:k}}export{H as createAgeRenderer,$ as createClassBreaksRenderer,L as createContinuousRenderer,W as createVisualVariables};
