/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import"../../../core/has.js";import{unwrap as t}from"../../../core/maybe.js";import a from"../../../core/Logger.js";import"../../../core/accessorSupport/ensureType.js";import{property as r}from"../../../core/accessorSupport/decorators/property.js";import{subclass as i}from"../../../core/accessorSupport/decorators/subclass.js";import s from"../../../core/Error.js";import"../../../core/urlUtils.js";import"../../../core/uuid.js";import"../../../portal/support/resourceExtension.js";import{pickRandom as n}from"../../../core/arrayUtils.js";import{reject as o,resolve as l,createAbortController as u,timeout as m,eachAlways as c,throwIfAborted as p}from"../../../core/promiseUtils.js";import{isWrappable as d,getInfo as h}from"../../../geometry/support/spatialReferenceUtils.js";import f from"../../../geometry/Point.js";import"../../../geometry.js";import{isNumericField as y,isDateField as g}from"../../../layers/support/fieldUtils.js";import{whenFalseOnce as F}from"../../../core/watchUtils.js";import{isHostedAgolService as v}from"../../../layers/support/arcgisLayerUrl.js";import x from"../../../tasks/support/QuantizationParameters.js";import w from"../../../tasks/support/StatisticDefinition.js";import S from"../../../tasks/GenerateRendererTask.js";import{toQuantizationTransform as _,quantizePoint as z}from"../../../geometry/support/quantizationUtils.js";import{getFieldsList as E}from"../utils.js";import{getRangeExpr as q,getSQLFilterForNormalization as T,mergeWhereClauses as V}from"../../statistics/support/utils.js";import{getArcadeForPredominantCategory as L,getSQLForPredominantCategoryName as Q,noDominantCategoryField as j}from"../../statistics/support/predominanceUtils.js";import B from"./LayerAdapter.js";import{processSummaryStatisticsResult as b,msSinceUnixEpochSQL as M,getFieldExpr as R,statisticTypes as k,getSummaryStatisticsFromFeatureSet as C,calculateStatsFromMemory as D,createUVResult as I,getUniqueValuesFromFeatureSet as G,calculateUniqueValuesFromMemory as N,getEqualIntervalBins as P,getHistogramFromFeatureSet as U,createCBDefn as O,generateBinParams as A,calculateHistogramFromMemory as W,resolveCBResult as Z,calculateClassBreaksFromMemory as H,calculateHeatmapStats as J,getMissingFields as K}from"./support/utils.js";import X from"../../../tasks/support/GenerateRendererParameters.js";import Y from"../../../tasks/support/UniqueValueDefinition.js";const $=a.getLogger("esri.smartMapping.support.adapters.FeatureLayerAdapter");let ee=class extends B{constructor(e){super(e)}destroy(){this._hasLocalSource=null}_isStatsSupportedOnService(){const e=this.layer;return!e.get("capabilities.query.supportsStatistics")||"multipatch"===this.geometryType&&!v(e.url)&&e.version<10.5?o(new s("feature-layer-adapter:not-supported","Layer does not support statistics query")):l()}async _fetchFeaturesFromMemory(e,t,a){const r=this.layer;if(this._hasLocalSource){return(await r.queryFeatures(t)).features}if(!e)throw new s("feature-layer-adapter:insufficient-data","layerView is required to fetch the features");const i=u(),n=F(e,"updating",i.signal);await m(n,5e3,i).catch((e=>{throw $.warn("LayerView is taking too long to update. Aborting fetch from layerView."),e}));return(await e.queryFeatures(t,{signal:a})).features}_fetchFeaturesFromService(e,t){return this.layer.queryFeatures(e,{signal:t}).then((e=>e&&e.features))}_fetchFeaturesForStats(e){return E({field:e.field,normalizationField:e.normalizationField,valueExpression:e.valueExpression}).then((t=>this.getSampleFeatures({sampleSize:-1,view:e.view,returnGeometry:e.returnGeometry,requiredFields:t,signal:e.signal})))}_summaryStatsFromGenRend(e){const t=e.normalizationType,a=e.normalizationField;return this.classBreaks({field:e.field,numClasses:5,classificationMethod:"standard-deviation",standardDeviationInterval:.25,normalizationType:t,normalizationField:"field"===t?a:void 0,minValue:e.minValue,maxValue:e.maxValue,signal:e.signal}).then((e=>{let t,a,r;if(e.classBreakInfos.some((e=>(e.hasAvg&&(t=e),!!t))),t){const e=t.maxValue-t.minValue;a=t.minValue+e/2,r=4*e}const i={min:e.minValue,max:e.maxValue,avg:a,stddev:r};return b(i)}))}_getSummaryStatsQuery(e,t){const{field:a,normalizationType:r,normalizationField:i,normalizationTotal:s}=e,n=this.supportsSQLExpression&&t?M(this,a):e.sqlExpression,o=R({field:a,normalizationType:r,normalizationField:i,normalizationTotal:s,layer:this}),l=n||o,u=l?q(l,e.minValue,e.maxValue):null,m=T({field:a,normalizationField:i,normalizationType:r}),c=V(e.sqlWhere,m),p=V(c,u),d=this.layer.createQuery();return d.where=V(d.where,p),d.sqlFormat=n?"standard":null,d.outStatistics=k.map((e=>{const t=new w;return t.statisticType="variance"===e?"var":e,t.onStatisticField=l,t.outStatisticFieldName=e+"_value",t})),d}async _summaryStatsFromServiceQuery(e,t){await this._isStatsSupportedOnService(),"percent-of-total"===e.normalizationType&&(e.normalizationTotal=await this._getNormalizationTotal(e.field,e.normalizationType));const a=this._getSummaryStatsQuery(e,t),r=await this.layer.queryFeatures(a,{signal:e.signal}),i=C(r,t);return b(i)}async _summaryStatsFromClientQuery(e,t){const a=this._getSummaryStatsQuery(e,t),r=await this.layer.queryFeatures(a,{signal:e.signal}),i=C(r,t);return b(i)}async _summaryStatsFromMemory(e,t){const a=e.field,r=e.valueExpression,i=e.view,n={field:a,valueExpression:r,normalizationField:e.normalizationField,view:i,signal:e.signal},o=e.features||await this._fetchFeaturesForStats(n);if(!(o&&o.length))throw new s("feature-layer-adapter:insufficient-data","No features are available to calculate statistics");const l={...e};if("percent-of-total"===l.normalizationType){const e=(await D({field:a},o)).sum;if(null==e)throw new s("feature-layer-adapter:invalid","invalid normalizationTotal");l.normalizationTotal=e}const u=await D(l,o,t);return b(u)}_uvFromGenRenderer(e,t){const a=e.field,r=new Y;r.attributeField=a;const i=new X;return i.classificationDefinition=r,this.generateRenderer(i,e.signal).then((e=>{const t={},r=this.getField(a);return e.uniqueValues.forEach((e=>{let a=e.value;null!=a&&""!==a&&("string"!=typeof a||""!==a.trim()&&"<null>"!==a.toLowerCase())||(a=null),null==t[a]?t[a]={count:e.count,data:y(r)&&a?Number(a):a}:t[a].count=t[a].count+e.count})),{count:t}})).then((a=>I(a,t,e.returnAllCodedValues)))}_getUVQuery(e){const t=e.field,a=e.sqlExpression,r="countOF"+(t||"Expr"),i=new w;i.statisticType="count",i.onStatisticField=a?"1":t,i.outStatisticFieldName=r;const s=this.layer.createQuery();return s.where=V(s.where,e.sqlWhere),s.sqlFormat=a?"standard":null,s.outStatistics=[i],s.groupByFieldsForStatistics=[t||a],s}_uvFromServiceQuery(e,t){return this._isStatsSupportedOnService().then((()=>this.layer.queryFeatures(this._getUVQuery(e),{signal:e.signal}))).then((t=>G(t,this,e.field,null,e.signal))).then((a=>I(a,t,e.returnAllCodedValues)))}async _uvFromClientQuery(e,t){const{signal:a}=e,r=this._getUVQuery(e),i=await this.layer.queryFeatures(r,{signal:a}),s=await G(i,this,e.field,null,a);return I(s,t,e.returnAllCodedValues)}async _uvFromMemory(e,t){const{field:a,valueExpression:r,view:i,signal:s}=e,n={field:a,valueExpression:r,view:i,signal:s},o=e.features?e.features:await this._fetchFeaturesForStats(n);return N(e,o,t)}_calcBinsSQL(e,t){const a=[],r=t.length;return t.forEach(((t,i)=>{const s=t[0],n=t[1],o=V(e+" >= "+s,e+(i===r-1?" <= ":" < ")+n);a.push("WHEN ("+o+") THEN "+(i+1))})),["CASE",a.join(" "),"ELSE 0","END"].join(" ")}_getNormalizationTotal(e,t,a){return e&&"percent-of-total"===t?this.summaryStatistics({field:e,signal:a}).then((e=>e.sum)):l(null)}_getQueryParamsForExpr(e,t){const a=e.valueExpression||e.sqlExpression,r=e.signal;if(!a){const a=e.field,i=a?this.getField(a):null,s=g(i),n={field:a,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:t,layer:this};return{sqlExpression:s?M(this,a):R(n),sqlWhere:s?null:e.sqlWhere||T(e),signal:r}}return{valueExpression:e.valueExpression,sqlExpression:e.sqlExpression,sqlWhere:e.sqlWhere,signal:r}}_getDataRange(e,t,a){return null!=t&&null!=a?l({min:t,max:a}):this.summaryStatistics(e).then((e=>({min:e.min,max:e.max})))}_histogramForExpr(e){return this._getNormalizationTotal(e.field,e.normalizationType,e.signal).then((t=>{const a=this._getQueryParamsForExpr(e,t);return this._getDataRange(a,e.minValue,e.maxValue).then((r=>{const{min:i,max:s}=r,n=e.numBins||10,o=P(i,s,n),l=this._calcBinsSQL(a.sqlExpression,o),u=new w({statisticType:"count",outStatisticFieldName:"countOFExpr",onStatisticField:"1"}),m=this.layer.createQuery();return m.where=V(m.where,a.sqlWhere),m.sqlFormat="standard",m.outStatistics=[u],m.groupByFieldsForStatistics=[l],m.orderByFields=[l],this._isStatsSupportedOnService().then((()=>this.layer.queryFeatures(m,{signal:a.signal}))).then((e=>U(e,i,s,n,t)))}))}))}_histogramForField(e){let t=null;return t=null!=e.minValue&&null!=e.maxValue?l({min:e.minValue,max:e.maxValue}):this.summaryStatistics(e).then((e=>{if(!e.count)throw new s("feature-layer-adapter:insufficient-data","Either the layer has no features or none of the features have data for the field");return{min:e.min,max:e.max}})),t.then((t=>this._getBins({min:t.min,max:t.max},e.field,e.numBins,e.signal)))}_getBins(e,t,a=10,r){const{min:i,max:s,normTotal:n,excludeZerosExpr:o}=e,l=e.intervals||P(i,s,a),u=e.sqlExpr||t;return this._queryBins(l,u,o,r).then((e=>({bins:e.map(((e,t)=>({minValue:l[t][0],maxValue:l[t][1],count:e.value}))),minValue:i,maxValue:s,normalizationTotal:n})))}_queryBins(e,t,a,r){const i=[],s=e.length;for(let r=0;r<s;r++){const n=V(a,V(t+" >= "+e[r][0],null!==e[r][1]?t+(r===s-1?" <= ":" < ")+e[r][1]:""));i.push(n)}return c(i.map((e=>this.queryFeatureCount(e,r))))}_binParamsFromGenRend(e,t){const{field:a,normalizationType:r,normalizationField:i,signal:s}=e,n=T({field:a,normalizationType:r,normalizationField:i}),o=new X({classificationDefinition:O({field:a,normalizationType:r,normalizationField:i,classificationMethod:e.classificationMethod,standardDeviationInterval:e.standardDeviationInterval,breakCount:e.numBins||10}),where:V(n,t)});return this.generateRenderer(o,s).then((e=>{const{normalizationTotal:t,classBreaks:s}=e;return A({field:a,normalizationType:r,normalizationField:i,normalizationTotal:t,classBreaks:s,where:n,layer:this})}))}_histogramFromMemory(e){const{field:t,normalizationField:a,normalizationType:r,valueExpression:i,classificationMethod:n,minValue:u,maxValue:m,view:c,signal:p}=e,d={field:t,valueExpression:i,normalizationField:a,view:c,signal:p};return(e.features?l(e.features):this._fetchFeaturesForStats(d)).then((a=>{if(!(a&&a.length))throw new s("feature-layer-adapter:insufficient-data","No features are available to calculate histogram");let d=null;if((!n||"equal-interval"===n)&&!r)d=null!=u&&null!=m?l({min:u,max:m,source:"parameters"}):this.summaryStatistics({field:t,valueExpression:i,features:a,view:c,signal:p}).then((e=>e.count?{min:e.min,max:e.max}:o(new s("feature-layer-adapter:insufficient-data","No features are available to calculate histogram"))));else{const t={...e};t.features=a,d=this._getBinParamsFromMemory(t)}return d.then((t=>W(e,t,a)))}))}async _getBinParamsFromMemory(e){const{field:t,valueExpression:a,classificationMethod:r,standardDeviationInterval:i,normalizationType:s,normalizationField:n,minValue:o,maxValue:l,features:u,view:m,signal:c}=e;return this._classBreaksFromMemory({field:t,valueExpression:a,normalizationType:s,normalizationField:n,classificationMethod:r,standardDeviationInterval:i,minValue:o,maxValue:l,numClasses:e.numBins,features:u,view:m,signal:c}).then((e=>{const a=e.normalizationTotal,r=e.classBreakInfos,i=T({field:t,normalizationType:s,normalizationField:n});return A({field:t,normalizationType:s,normalizationField:n,normalizationTotal:a,classBreaks:r,where:i,layer:this})}))}_classBreaksFromGenRend(e){const{field:t,normalizationType:a,normalizationField:r,normalizationTotal:i,signal:s}=e,n=T({field:t,normalizationType:a,normalizationField:r}),o=R({field:t,normalizationType:a,normalizationField:r,normalizationTotal:i,layer:this}),l=q(o,e.minValue,e.maxValue),u=O({field:t,normalizationType:a,normalizationField:r,classificationMethod:e.classificationMethod,standardDeviationInterval:e.standardDeviationInterval,breakCount:e.numClasses||5}),m=new X;return m.classificationDefinition=u,m.where=V(n,l),this.generateRenderer(m,s).then((t=>Z(e,t)))}_classBreaksFromInterpolation(e){const{minValue:t,maxValue:a}=e,r=e.numClasses||5,i=[],s=(a-t)/r;for(let e=0;e<r;e++){const a=t+e*s;i.push({minValue:a,maxValue:a+s})}i[r-1].maxValue=a;const n={classBreaks:i,normalizationTotal:e.normalizationTotal},o=Z(e,n);return l(o)}async _classBreaksFromMemory(e){const{field:t,normalizationField:a,valueExpression:r,view:i,signal:n}=e,o={field:t,valueExpression:r,normalizationField:a,view:i,signal:n},l=e.features||await this._fetchFeaturesForStats(o);if(!(l&&l.length))throw new s("feature-layer-adapter:insufficient-data","No features are available to calculate statistics");const u={...e};if("percent-of-total"===u.normalizationType){const e=(await D({field:t},l)).sum;if(null==e)throw new s("feature-layer-adapter:invalid","invalid normalizationTotal");u.normalizationTotal=e}return H(u,l)}async _heatmapStatsFromMemory(e,t){const{blurRadius:a,field:r,view:i,signal:n}=e,{resolution:o,size:l}=i.state,u=new x({extent:i.extent,tolerance:o}),m=this._quantizeFeatures(e.features||await this._fetchFeaturesForStats({field:r,view:i,returnGeometry:!0,signal:n}),u,i);if(!m||!m.length)return{count:0,min:null,max:null,avg:null,stddev:null};const c=J(m,a,t,r,l[0],l[1]);if(c)return{count:c.count,min:c.min,max:c.max,avg:c.mean,stddev:c.stdDev};throw new s("feature-layer-adapter:invalid","unable to calculate heatmap statistics")}_quantizeFeatures(e,a,r){const i=_(a),{spatialReference:s,size:n}=r,o=d(s)?h(s):null,l=o?Math.round((o.valid[1]-o.valid[0])/i.scale[0]):null;return e.map((e=>{const a=new f(t(e.geometry));return z(i,a,a,a.hasZ,a.hasM),e.geometry=o?this._wrapPoint(a,l,n[0]):a,e}))}_wrapPoint(e,t,a){return e.x<0?e.x+=t:e.x>a&&(e.x-=t),e}getField(e=""){return this.layer.getField(e)}getFieldUsageInfo(e){return this.getField(e)?{supportsLabelingInfo:!0,supportsRenderer:!0,supportsPopupTemplate:!0,supportsLayerQuery:!0,supportsStatistics:!0}:null}getFieldDomain(e,t){return this.layer.getFieldDomain(e,t)}summaryStatistics(e){const t=e.field,a=t?this.getField(t):null,r=g(a),i=e.valueExpression||e.sqlExpression,n=i&&!e.sqlExpression,l=this._hasLocalSource||e.features,u=e.view,m=u&&"3d"===u.type;if(l||n)return n||e.features||m?this._summaryStatsFromMemory(e,r):this._summaryStatsFromClientQuery(e,r);if(!this.supportsSQLExpression&&(r||i))return o(new s("feature-layer-adapter:not-supported","Layer does not support standardized SQL expression for queries"));return(e.normalizationType&&!this.supportsSQLExpression?this._summaryStatsFromGenRend(e):this._summaryStatsFromServiceQuery(e,r)).catch((()=>(p(e.signal),this._summaryStatsFromMemory(e,r))))}uniqueValues(e){const{field:t,valueExpression:a,sqlExpression:r,signal:i}=e,s=(t?this.getField(t):null)&&this.getFieldDomain(t),n=a&&(!r||!this.supportsSQLExpression),o=this._hasLocalSource||e.features||n,l=e.view,u=l&&"3d"===l.type;return o?n||e.features||u?this._uvFromMemory(e,s):this._uvFromClientQuery(e,s):this._uvFromServiceQuery(e,s).catch((t=>(p(i),e.field?this._uvFromGenRenderer(e,s):t))).catch((()=>(p(i),n||e.features||u?this._uvFromMemory(e,s):this._uvFromClientQuery(e,s))))}histogram(e){const{field:t,normalizationType:a,normalizationField:r,classificationMethod:i,signal:n}=e,l=t?this.getField(t):null,u=g(l),m=e.valueExpression||e.sqlExpression,c=m&&!e.sqlExpression,p=this._hasLocalSource||e.features||c,d=this.supportsSQLExpression,h=!i||"equal-interval"===i,f=e.minValue,y=e.maxValue,F=null!=f&&null!=y,v=e.numBins||10;return p?this._histogramFromMemory(e):(m||d)&&h?m&&!d?o(new s("feature-layer-adapter:not-supported","Layer does not support standardized SQL expression for queries")):this._histogramForExpr(e):u&&h?o(new s("feature-layer-adapter:not-supported","Normalization and date field are not allowed when layer does not support standardized SQL expression for queries")):a||!h?this._binParamsFromGenRend(e).then((i=>{if(!F)return this._getBins(i,t,v,n);if(f>i.max||y<i.min)throw new s("histogram:insufficient-data","Range defined by 'minValue' and 'maxValue' does not intersect available data range of the field");if(h)return this._getBins({min:f,max:y,sqlExpr:i.sqlExpr,excludeZerosExpr:i.excludeZerosExpr},t,v,n);{const s={field:t,normalizationType:a,normalizationField:r,normalizationTotal:i.normTotal,layer:this},o=R(s),l=q(o,f,y);return this._binParamsFromGenRend(e,l).then((e=>this._getBins(e,t,v,n)))}})):this._histogramForField(e)}classBreaks(e){const t=!1!==e.analyzeData,a=this._hasLocalSource||e.features||e.valueExpression;if(t&&a)return this._classBreaksFromMemory(e);return(t?this._classBreaksFromGenRend(e):this._classBreaksFromInterpolation(e)).catch((()=>(p(e.signal),this._classBreaksFromMemory(e))))}queryFeatureCount(e,t){if(this._hasLocalSource)return o(new s("feature-layer-adapter:not-supported","Layer does not support count query"));const a=this.layer,r=a.createQuery();return r.where=V(r.where,e),a.queryFeatureCount(r,{signal:t})}generateRenderer(e,t){const a=this.layer;if(this._hasLocalSource||a.version<10.1)return o(new s("feature-layer-adapter:not-supported","Layer does not support generateRenderer operation (requires ArcGIS Server version 10.1+)"));const r=new S({url:a.parsedUrl.path,source:a.dynamicDataSource,gdbVersion:a.gdbVersion}),i=a.createQuery();return e.where=V(e.where,i.where),r.execute(e,{signal:t})}heatmapStatistics(e){const{field:t,fieldOffset:a,signal:r}=e;return(t&&null==a?this.summaryStatistics({field:t,signal:r}):l(null)).then((t=>{let r=a||0;if(t){const{count:e,min:a,max:i}=t;e?a===i&&0===a?r=1:i<=0?r="abs":a<0&&(r=-1.01*a):r=1}return this._heatmapStatsFromMemory(e,r).then((e=>({...e,summaryStatistics:t,fieldOffset:r})))}))}async predominantCategories(e){if(!this._hasLocalSource&&!this.supportsSQLExpression)throw new s("feature-layer-adapter:not-supported","Layer does not support advanced SQL expressions and standardized queries");const{fields:t,view:a,signal:r}=e,i=L(t),n=Q(t),o=(a&&this._hasLocalSource?await this._uvFromMemory({valueExpression:i,view:a,signal:r}):await this._uvFromServiceQuery({sqlExpression:n.expression,valueExpression:i,signal:r})).uniqueValueInfos,l=o.map((e=>e.value)),u=t.filter((e=>-1===l.indexOf(e)));for(const e of u)o.push({value:e,count:0});o.sort(((e,a)=>t.indexOf(e.value)-t.indexOf(a.value)));for(const e of o)e.value===j&&(e.value=null);return{predominantCategoryInfos:o}}async getSampleFeatures(e){const{view:t,sampleSize:a,requiredFields:r,returnGeometry:i,signal:s}=e,o=this.layer.createQuery();o.outSpatialReference=e.spatialReference||t&&t.spatialReference,o.returnGeometry=!!i,o.outFields=r;let l=[],u=!1;if(t)try{const e=await t.whenLayerView(this.layer);if(u=!(await K(this,r,e)).length,u&&(l=await this._fetchFeaturesFromMemory(e,o,s),l.length&&a>0&&a<=l.length))return n(l,a,1)}catch(e){p(s)}try{if(this._hasLocalSource)return u?l:this._fetchFeaturesFromService(o,s);const r=await this.queryFeatureCount(null,s),i=this.layer.capabilities.query.maxRecordCount;let m=-1===a?r:a;if(m=i&&m>i?i:m,r<=l.length||l.length>=i)return l;const c=t.extent.width/t.width/t.scale*4e5;if(o.maxAllowableOffset=e.resolution||c,r<=m)return this._fetchFeaturesFromService(o,s);if(r<=2e4){const e=await this.layer.queryObjectIds();return o.objectIds=n(e,m,1),this._fetchFeaturesFromService(o,s)}return this.layer.get("capabilities.query.supportsPagination")&&(o.num=Math.min(m,2e4)),this._fetchFeaturesFromService(o,s)}catch(e){return p(s),l}}load(e){const t=this.layer.load(e).then((e=>{this.geometryType=e.geometryType,this.objectIdField=e.objectIdField,this.supportsSQLExpression=e.get("capabilities.query.supportsSqlExpression"),this._hasLocalSource=!e.url&&!!e.source,this.hasQueryEngine=this._hasLocalSource,this.minScale=e.minScale,this.maxScale=e.maxScale,this.fullExtent=e.fullExtent}));return this.addResolvingPromise(t),l(this)}};e([r({constructOnly:!0})],ee.prototype,"layer",void 0),ee=e([i("esri.smartMapping.support.adapters.FeatureLayerAdapter")],ee);var te=ee;export default te;
