/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{throwIfAborted as n,resolve as t}from"../../../../core/promiseUtils.js";import{loadArcade as a}from"../../../../support/arcadeOnDemand.js";import e from"../../../../tasks/support/ClassBreaksDefinition.js";import{createGenerateRendererClassBreaks as o}from"../../../../tasks/support/generateRendererUtils.js";import{isIntegerField as i,castIntegerFieldToFloat as l,getDateDiffSQL as r}from"../../utils.js";import{createKernel as u,createValueFunction as s}from"../../../../renderers/support/heatmapUtils.js";const c=/_value$/i,m=/\s*(\+|-)?((\d+(\.\d+)?)|(\.\d+))\s*/gi,f=Math.LOG10E,d=["min","max","avg","stddev","count","sum","variance"];let p=null;async function v(n,t,a){const e=[];if(t)for(const o of t){const t=n.getField(o);"availableFields"in a&&-1===a.availableFields.indexOf(t.name)&&e.push(t.name)}return e}function h(n,t){const a=n&&n.features,e=a&&a[0]&&a[0].attributes,o={};for(const n in e)o[n.replace(c,"").toLowerCase()]=e[n];return o.min===o.max&&null!=o.min&&null==o.stddev&&(o.stddev=o.variance=0),t&&(["min","max","avg","stddev","sum","variance"].forEach((n=>{null!=o[n]&&(o[n]=Math.ceil(o[n]))})),o.min===o.max&&null!=o.min&&(o.avg=o.min,o.stddev=o.variance=0)),o}async function x(n,t,a){let e=await y(n,t);e=V(e,n.minValue,n.maxValue);const o=function(n,t){let a=Number.POSITIVE_INFINITY,e=Number.NEGATIVE_INFINITY,o=null,i=null,l=null,r=null;for(const t of n)o+=t,a=Math.min(a,t),e=Math.max(e,t);const u=n.length;if(u){i=o/u;let a=0;for(const t of n)a+=Math.pow(t-i,2);r=t?u>1?a/(u-1):0:u>0?a/u:0,l=Math.sqrt(r)}else a=null,e=null;return{avg:i,count:u,max:e,min:a,stddev:l,sum:o,variance:r}}(e,!n.normalizationType);return a&&["avg","stddev","variance"].forEach((n=>{null!=o[n]&&(o[n]=Math.ceil(o[n]))})),o}function V(n,t,a){return t=null==t?-1/0:t,a=null==a?1/0:a,n.filter((n=>null!=n&&j(n)&&n>=t&&n<=a))}async function y(n,t){const e=n.field,o="function"==typeof e,i=n.valueExpression,l=n.normalizationType,r=n.normalizationField,u=n.normalizationTotal,s=[],c=n.view;let m=null,f=null;if(i){if(!p){const{arcadeUtils:n}=await a();p=n}m=p.createFunction(i),f=c&&p.getViewInfo({viewingMode:"2d"===c.type?"map":c.viewingMode,scale:c.scale,spatialReference:c.spatialReference})}return t?(t.forEach((n=>{const t=n.attributes;let a;if(i){const t=p.createExecContext(n,f);a=p.executeFunction(m,t)}else o?a=e.call(null,n):t&&(a=t[e]);if(l&&null!=a&&j(a)){const n=t&&parseFloat(t[r]);"log"===l&&0!==a?a=Math.log(a)*Math.LOG10E:"percent-of-total"===l&&j(u)&&0!==u?a=a/u*100:"field"===l&&j(n)&&0!==n&&(a/=n)}s.push(a)})),s):s}function T(n){let t;for(t in n)d.indexOf(t)>-1&&(j(n[t])||(n[t]=null));return n}function z(n){const t=n.field,a=n.classificationMethod||"equal-interval",o=n.normalizationType,i=n.normalizationField,l=new e;return l.classificationField=t,l.breakCount=n.breakCount,l.classificationMethod=a,l.standardDeviationInterval="standard-deviation"===a?n.standardDeviationInterval||1:void 0,l.normalizationType=o,l.normalizationField="field"===o?i:void 0,l}function b(n,t=10,a,e,o,i){const l=new Float64Array(o*i),r=u(t),c=Math.round(3*t);let m=Number.POSITIVE_INFINITY,f=Number.NEGATIVE_INFINITY,d=0,p=0,v=0,h=0;const x=s(e,a);for(const{geometry:t,attributes:a}of n){const n=t.x-c,e=t.y-c,u=Math.max(0,n),s=Math.max(0,e),V=Math.min(i,t.y+c),y=Math.min(o,t.x+c),T=+x(a);for(let t=s;t<V;t++){const a=r[t-e];for(let e=u;e<y;e++){const i=r[e-n],u=t*o+e,s=l[u];d=l[u]+=a*i*T;const c=d-s;p+=c,v+=c*c,d<m&&(m=d),d>f&&(f=d),h++}}}if(!h)return{mean:0,stddev:0,min:0,max:0,mid:0,count:0};const V=(f-m)/2;return{mean:p/h,stdDev:Math.sqrt((v-p*p/h)/h),min:m,max:f,mid:V,count:h}}async function g(n,t){const a=n.normalizationTotal,e=z({field:n.field,normalizationType:n.normalizationType,normalizationField:n.normalizationField,classificationMethod:n.classificationMethod,standardDeviationInterval:n.standardDeviationInterval,breakCount:n.numClasses||5});let i=await y(n,t);i=V(i,n.minValue,n.maxValue);return I(n,o({definition:e,values:i,normalizationTotal:a}))}function I(n,t){let a=t.classBreaks;const e=a.length,o=a[0].minValue,i=a[e-1].maxValue,l="standard-deviation"===n.classificationMethod,r=m;return a=a.map((n=>{const t=n.label,a={minValue:n.minValue,maxValue:n.maxValue,label:t};if(l&&t){const n=t.match(r).map((n=>+n.trim()));2===n.length?(a.minStdDev=n[0],a.maxStdDev=n[1],n[0]<0&&n[1]>0&&(a.hasAvg=!0)):1===n.length&&(t.indexOf("<")>-1?(a.minStdDev=null,a.maxStdDev=n[0]):t.indexOf(">")>-1&&(a.minStdDev=n[0],a.maxStdDev=null))}return a})),{minValue:o,maxValue:i,classBreakInfos:a,normalizationTotal:t.normalizationTotal}}function F(n,t,a){const e=(t-n)/a,o=[];let i,l=n;for(let n=1;n<=a;n++)i=l+e,i=Number(i.toFixed(16)),o.push([l,i]),l=i;return o}function E(n){const t=[],a=n.classBreaks,e=a[0].minValue,o=a[a.length-1].maxValue;a.forEach((n=>{t.push([n.minValue,n.maxValue])}));const i={field:n.field,normalizationType:n.normalizationType,normalizationField:n.normalizationField,normalizationTotal:n.normalizationTotal,layer:n.layer};return{min:e,max:o,intervals:t,sqlExpr:M(i),excludeZerosExpr:n.where,normTotal:n.normalizationTotal}}function M(n){const{field:t,normalizationType:a,normalizationField:e,normalizationTotal:o,layer:r}=n,u=i(r,t);let s=t;return"percent-of-total"===a?s=`((${u?l(t):t} / ${o}) * 100)`:"log"===a?s=`(log(${t}) * ${f})`:"field"===a&&(s=`(${u?l(t):t} / ${e})`),s}async function w(n,t,a){const{min:e,max:o,normTotal:i}=t,l=n.numBins||10,r=t.intervals||F(e,o,l),u=r.map(((n,t)=>({minValue:r[t][0],maxValue:r[t][1],count:0}))),s=await y(n,a);for(const n of s)if(null!=n&&n>=e&&n<=o){const t=N(r,n);t>-1&&u[t].count++}return{bins:u,minValue:e,maxValue:o,normalizationTotal:i}}function N(n,t){let a=-1;for(let e=n.length-1;e>=0;e--){if(t>=n[e][0]){a=e;break}}return a}function D(n,t){let a;if(t=t.toLowerCase(),n)for(const e in n)if(e.toLowerCase()!==t){a=n[e];break}return a}function C(n,t){let a;if(t=t.toLowerCase(),n)for(const e in n)if(e.toLowerCase()===t){a=n[e];break}return a}function O(n,t,a,e,o){const i={},l="countOFExpr";n&&n.features&&n.features.forEach((n=>{const t=n.attributes,a=D(t,l),e=C(t,l);0!==a&&(i[a]=e)}));const r=[];return F(t,a,e).forEach(((n,t)=>{const a=(t+1).toString();r.push({minValue:n[0],maxValue:n[1],count:i.hasOwnProperty(a)?i[a]:0})})),{bins:r,minValue:t,maxValue:a,normalizationTotal:o}}function k(a,e,o,i,l){const r=a&&a.features,u="countOF"+(o||"Expr"),s={};let c=!1;if(r.forEach((n=>{const t=n.attributes,a=C(t,u);let e=o?C(t,o):D(t,u);null===e&&0===a&&(c=!0),(null==e||"string"==typeof e&&""===e.trim())&&(e=null),null==s[e]?s[e]={count:a,data:e}:s[e].count=s[e].count+a})),o&&c){const t=o+" is NULL";return e.queryFeatureCount(t,l).then((n=>(n=n||0,s.null.count=s.null.count+n,L(s,i)))).catch((()=>(n(l),L(s,i))))}return t(L(s,i))}function L(n,t){if(t)for(const a in n)n[a].label=t[a];return{count:n}}function S(n,t,a){const e=n.count,o=[];if(a&&t&&"coded-value"===t.type){t.codedValues.forEach((n=>{const t=n.code;e.hasOwnProperty(t)||(e[t]={data:t,count:0})}))}for(const n in e){const t=e[n];o.push({value:t.data,count:t.count,label:t.label})}return{uniqueValueInfos:o}}async function q(n,t,a){const e=await y(n,t),o={};for(let n of e)(null==n||"string"==typeof n&&""===n.trim())&&(n=null),null==o[n]?o[n]={count:1,data:n}:o[n].count++;return S({count:o},a,n.returnAllCodedValues)}function $(n,t){return r(n,new Date(0),t,"milliseconds").sqlExpression}function j(n){return"number"==typeof n&&!isNaN(n)&&n!==1/0&&n!==-1/0}export{g as calculateClassBreaksFromMemory,b as calculateHeatmapStats,w as calculateHistogramFromMemory,x as calculateStatsFromMemory,q as calculateUniqueValuesFromMemory,z as createCBDefn,S as createUVResult,E as generateBinParams,y as getDataValues,F as getEqualIntervalBins,M as getFieldExpr,O as getHistogramFromFeatureSet,v as getMissingFields,h as getSummaryStatisticsFromFeatureSet,k as getUniqueValuesFromFeatureSet,j as isValidNumber,$ as msSinceUnixEpochSQL,T as processSummaryStatisticsResult,I as resolveCBResult,d as statisticTypes};
