/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import e from"../../../core/ObjectPool.js";import{removeUnordered as t}from"../../../core/arrayUtils.js";import{createAbortController as i}from"../../../core/promiseUtils.js";import{log2 as s}from"../../../core/mathUtils.js";import{c as n,u as r}from"../../../chunks/vec3f64.js";import{g as a,f as o,o as h,d as l,a as d,b as u,l as p}from"../../../chunks/vec3.js";import{getReferenceEllipsoid as g}from"../../../geometry/projectionEllipsoid.js";import{create as c,equals as f}from"../../../geometry/support/aaBoundingRect.js";import{a as m}from"../../../chunks/vec2f64.js";import{a as _}from"../../../chunks/vec4f64.js";import{c as y,s as v}from"../../../chunks/vec2.js";import{t as A}from"../../../chunks/vec4.js";import{MAX_PATCH_TESSELATION as M,ELEVATION_DESIRED_RESOLUTION_LEVEL as L}from"./TerrainConst.js";import{getGpuMemoryUsage as I}from"../../webgl/Util.js";import{ImageWithType as j}from"../support/StreamDataLoader.js";import{VectorTile as D}from"../../2d/engine/vectorTiles/VectorTile.js";import U from"./RasterTile.js";import B from"./TileTexture.js";import{getLayerWithExtentRange as T,weakAssert as x}from"./terrainUtils.js";import{ElevationBounds as C}from"./ElevationBounds.js";import{tile2str as S,fallsWithinLayer as b}from"./tileUtils.js";import{TILE_AGENT_DONE as R}from"./TileAgent.js";import w from"./ElevationTileAgent.js";import P from"./MapTileAgent.js";import{TilePerLayerInfo as q}from"./TilePerLayerInfo.js";const E=x,W=n(),V=n(),k=n(),O=_();class N{constructor(){this.fovX=0,this.fovY=0,this.relativeWidthLimit=0,this.relativeHeightLimit=0,this.maxLod=0,this.angledSplitBias=0,this.aboveGround=!0}}function z(e,t,i,s){const n=0===i?X.acquire():F.acquire();return n.init(e,t,i,s),n}function H(e){e.dispose(),e instanceof w?X.release(e):e instanceof P&&F.release(e)}function G(){F.prune(0),X.prune(0)}const F=new e(P),X=new e(w),$=new C,Y=-1;export default class{constructor(e){this._numSubdivisionAtLevel=e,this.lij=[0,0,0],this._children=[null,null,null,null],this._dirty=!0,this._previouslyRendered=!1,this.extent=c(),this._elevationBounds=m(),this.layerInfo=new Array(2),this.extentInRadians=c(),this.centerAtSeaLevel=n(),this._center=[n(),n(),n()],this.up=r(),this._isWithinClippingArea=!0,this._intersectsClippingArea=!0,this._clippingArea=null,this._maxTesselation=0,this._usedMemory=Y,this._mapTileMemory=0,this._mapDataRefCount=0,this._screenDepth=0,this.renderOrder=0,this._edgeLen=0,this._edgeLen2=0,this._radius=0,this._curvatureHeight=0}get usedMemory(){return this._usedMemory===Y&&this._updateMemoryUsed(),this._usedMemory+(this.isCached?0:this.mapTileMemory)}get cachedMemory(){return this.isCached?this.mapTileMemory:0}get mapTileMemory(){this._usedMemory===Y&&this._updateMemoryUsed();let e=this._mapTileMemory;for(const{data:t}of this.layerInfo[1])t instanceof D&&(e+=t.getMemoryUsage());return e}get isCached(){return!this.shouldRender&&this._mapDataRefCount<=0}get maxTesselation(){return this._maxTesselation}get numSubdivisionsAtLevel(){return this._numSubdivisionAtLevel}get isWithinClippingArea(){return this._isWithinClippingArea}get intersectsClippingArea(){return this._intersectsClippingArea}get clippingArea(){return this._clippingArea}get parent(){return this._parent}get children(){return this._children}get surface(){return this._surface}get elevationBounds(){return this._elevationBounds}get level(){return this.lij[0]}get edgeLen(){return this._edgeLen}get radius(){return this._radius}get screenDepth(){return this._screenDepth}get visible(){if(this._dirty){const e=this._isVisible();e!==this._visible&&(this._visible=e,this.updateAgentSuspension(),this.surface.emit("tiles-visibility-changed"),this.surface.renderer.setNeedsRender()),this._dirty=!1}return this._visible}get rendered(){const e=!!this.renderData;return e!==this._previouslyRendered&&(this.surface.emit("tiles-visibility-changed"),this._previouslyRendered=e,this.surface.renderer.setNeedsRender()),e}get shouldRender(){if(!this.visible)return!1;if(1===this.surface.lodSnapping){const e=this.level-this._surface.snapLevel;if(0===e)return!0;if(1===e)return!1}return this.isLeaf}init(e,t,i){this.lij[0]=e[0],this.lij[1]=e[1],this.lij[2]=e[2],this.ellipsoid=g(i.tilingScheme.spatialReference),i.tilingScheme.getExtent(e[0],e[1],e[2],this.extent),i.tilingScheme.convertExtentToRadians(this.extent,this.extentInRadians),this._isWithinClippingArea=!0,this._intersectsClippingArea=!0,this._clippingArea=null,this._mapDataRefCount=0,i.upsampleMapCache.pop(S(this)),this._edgeLen=0,this._edgeLen2=0,this._radius=0,this.vlevel=e?e[0]:0,t&&t._elevationBounds?y(this._elevationBounds,t.elevationBounds):v(this._elevationBounds,0,0),this._pendingUpdates=0,this.renderData=null,this._screenDepth=0,this._visible=!1,this._previouslyRendered=!1,this._parent=t,this.unsetChildren(),this._surface=i,this.updateVisibility();for(let e=0;e<2;e++){const t=i.numLayers(e);let s=this.layerInfo[e];this.layerInfo[e]?s.length=t:(s=new Array(t),this.layerInfo[e]=s);for(let i=0;i<t;i++)s[i]=q.makeEmptyLayerInfo(e,this._surface.upsampleInfoPool,s[i]),0===e&&this.findElevationBoundsForLayer(i,-1)}this.computeElevationBounds(),this._maxTesselation=Math.min(i.tilingScheme.pixelSize,M)}release(){E(!this.renderData,"tile.renderData was not unloaded"),this._surface.upsampleMapCache.pop(S(this));for(let e=0;e<2;e++)for(const t of this.layerInfo[e])t.dispose();this._parent=null,this._surface=null,this._usedMemory=Y}refMapData(){++this._mapDataRefCount,this.isCached||this._surface.upsampleMapCache.pop(S(this))}unrefMapData(){if(--this._mapDataRefCount,this.isCached){const e=this.cachedMemory;e>0&&(this._surface.upsampleMapCache.put(S(this),this,e),this.setMemoryDirty())}}setMemoryDirty(){this._usedMemory=Y}get cpuImageMemorySize(){const e=this._surface.tilingScheme.pixelSize;return e*e*4}_updateMemoryUsed(){this._usedMemory=0,this._mapTileMemory=0;const e=this.cpuImageMemorySize;for(const t of this.layerInfo[1]){const i=t.data;i instanceof B?this._mapTileMemory+=I(i.texture):i instanceof HTMLImageElement||i instanceof j?this._mapTileMemory+=e:i instanceof U&&(this._mapTileMemory+=i.getMemoryUsage())}for(const t of this.layerInfo[0])this._usedMemory+=t.data?e:0;if(this.renderData){this._usedMemory+=this.renderData.estimatedGeometryMemoryUsage;const e=this.renderData.textureDescriptor;e&&(this._mapTileMemory+=I(e))}this.isCached&&this._surface.upsampleMapCache.updateSize(S(this),this,this.cachedMemory)}getUsedMemoryForLayer(e,t){const i=this.layerInfo[e][t];if(!i||!i.data)return 0;if(1!==e||this.isCached){if(0===e)return this.cpuImageMemorySize}else{const e=i.data;if(e instanceof B)return I(e.texture);if(e instanceof HTMLImageElement||e instanceof j)return this.cpuImageMemorySize;if(e instanceof D||e instanceof U)return e.getMemoryUsage()}return 0}updateScreenDepth(e){a(O,this._center[0]),O[3]=1,A(O,O,e),this._screenDepth=O[2]<0?0:O[2]/O[3]}shouldSplit(e,t,i){const n=this.level;o(W,this._center[0],t);let r=h(W),a=0;o(V,this._center[1],t);const g=h(V);g<r&&(r=g,a=1),o(V,this._center[2],t);const c=h(V);if(c<r&&(r=c,a=2),this._edgeLen2>r&&n<e.maxLod)return 2;const f=Math.sqrt(r),m=e.fovX*f*2,_=this._edgeLen/m,y=()=>{const t=n+Math.ceil(-s(e.relativeWidthLimit/_));return t!==this.vlevel?(this.vlevel=t,4):1};if(1===i){if(1===this._surface.snapLevel-n)return n>=e.maxLod?y():2}const v=l(this.up,W),A=this._elevationBounds[1]-this._elevationBounds[0],M=A/this.edgeLen;if(e.aboveGround&&v>0&&M<.001){if(v/f-Math.sin(this._curvatureHeight/(this.edgeLen*Math.SQRT1_2)*Math.PI)-M>0)return 0}if(_<e.relativeWidthLimit)return this.vlevel!==this.level?(this.vlevel=this.level,4):0;if(n>=e.maxLod)return y();if(n>6){o(V,this._center[a],t),d(k,this.up,v),o(k,k,V);const i=h(k);if(i>this._radius*this._radius){d(k,k,this._radius/Math.sqrt(i)),u(k,k,this._center[a]),o(k,t,k);const s=Math.min(1,(Math.abs(l(k,this.up))+.5*A+this._curvatureHeight)/p(k)),n=.1/e.angledSplitBias,r=e.fovY*f*2;if(s*(this._edgeLen/r)<n*e.relativeHeightLimit)return 0}}return 2}setChildren(e,t,i,s){E(!!(e&&t&&i&&s),"Null child passed"),this._children[0]=e,this._children[1]=t,this._children[2]=i,this._children[3]=s}unsetChildren(){this._children[0]=null,this._children[1]=null,this._children[2]=null,this._children[3]=null}load(e){this.refMapData();for(let e=0;e<2;e++){this.layerInfo[e]&&this._createOrUpdateAgents(0,e)}e.loadTile(this)}unload(e){e.unloadTile(this);for(let e=0;e<2;e++){const t=this.layerInfo[e];for(const e of t)e.loadingAgent&&e.loadingAgent!==R&&(H(e.loadingAgent),e.loadingAgent=null),e.pendingUpdates=0}this.resetPendingUpdate(32),this.resetPendingUpdate(64),this.unrefMapData()}unloadMapData(){const e=this.layerInfo[1];for(const t of e)t.loadingAgent&&t.loadingAgent!==R&&(H(t.loadingAgent),t.loadingAgent=null),t.pendingUpdates=0;this.renderData&&this.renderData.releaseTexture(),this.setMemoryDirty()}updateClippingStatus(e){if(f(e,this._clippingArea))return!1;const t=this._intersectsClippingArea,i=this._isWithinClippingArea;e?(this._intersectsClippingArea=this.intersectsExtent(e),this._isWithinClippingArea=this.isWithinExtent(e)):(this._intersectsClippingArea=!0,this._isWithinClippingArea=!0),this._clippingArea=e,this.updateVisibility();const s=i&&this._isWithinClippingArea,n=!(i||t||this._isWithinClippingArea||this._intersectsClippingArea);return!this.renderData||s||n||this.setPendingUpdate(32),!0}updateVisibility(){this._dirty=!0,this._surface.setTileTreeDirty()}getLayerInfo(e,t){return this.layerInfo[t][e]}hasLayerData(e,t){const i=this.layerInfo[t][e];return!(!i||!i.data||i.dataInvalidated)}get updating(){if(this.hasPendingUpdates)return!0;for(let e=0;e<2;e++){const t=this.layerInfo[e];for(const e of t)if(e.loadingAgent&&e.loadingAgent!==R&&e.loadingAgent.updating)return!0}return!1}isSuspended(e){return!!this.hasPendingUpdate(2)||0!==e&&!this.visible}get hasPendingUpdates(){return 0!==this._pendingUpdates}hasPendingUpdate(e){return(this._pendingUpdates&e)===e}setPendingUpdate(e){this._pendingUpdates|=e,2===e||8===e?this._surface.setTileTreeDirty():this._surface.pendingUpdates=!0}resetPendingUpdate(e){return!!this.hasPendingUpdate(e)&&(this._pendingUpdates&=~e,!0)}requestLayerData(e,t,s){const n=this.layerInfo[t][e];if(n.waitingAgents.indexOf(s)>-1)return console.warn("agent already requested this piece of map data (tile %s, agent tile %s, layer: %d/%d)",this.lij.toString(),s.tile.lij.toString(),t,e),!0;if(n.waitingAgents.push(s),n.data&&!n.dataInvalidated)return console.warn("agent requested existing data (tile %s, agent tile %s, layer: %d/%d)",this.lij.toString(),s.tile.lij.toString(),t,e),s.dataArrived(this),!0;if(n.requestPromise)return!0;n.requestAbort=i();const r=this._surface.requestTileData(this,e,t,n.requestAbort);if(!r)return n.requestAbort=null,!1;const a=()=>{n.requestPromise===r&&(n.requestPromise=null,n.requestAbort=null)};return n.requestPromise=r,r.then(a,a),!!n.requestPromise}get isLeaf(){return null==this._children[0]}hasLij(e){return this.lij[0]===e[0]&&this.lij[1]===e[1]&&this.lij[2]===e[2]}findByLij(e){if(this.hasLij(e))return this;if(this.isLeaf)return null;const t=this._children[0].findByLij(e)||this._children[1].findByLij(e)||this._children[2].findByLij(e)||this._children[3].findByLij(e);return t||null}distanceToSquared(e){return h(o(k,this._center[0],e))}containsPoint(e){const t=this.extent;return e[0]>=t[0]&&e[1]>=t[1]&&e[0]<=t[2]&&e[1]<=t[3]}unrequestLayerData(e,i,s){const n=this.layerInfo[i][e],r=n.waitingAgents,a=null!=t(r,s);E(a,"agent has not requested this piece of map data"),r.length<1&&(n.abortRequest(),this._updateMemoryUsed())}dataArrived(e,t,i){const s=this.layerInfo[t][e];s.data=i,s.dataInvalidated=!1;for(let e=0;e<s.waitingAgents.length;e++)s.waitingAgents[e].dataArrived(this);s.waitingAgents.length=0,this._updateMemoryUsed()}dataMissing(e,t,i){i.notInTilemap||console.error(`Tile ${this.lij.toString()} layer ${t}/${e} error ${i}`);const s=this.layerInfo[t][e];s.dataMissing=!0;for(let e=0;e<s.waitingAgents.length;e++)s.waitingAgents[e].dataMissing();s.waitingAgents.length=0,this._updateMemoryUsed()}updateRenderData(e){switch(e){case 1:return this.updateTexture();case 0:return this.updateGeometry()}}updateTexture(){this.renderData&&this.setPendingUpdate(64)}updateGeometry(){this.setPendingUpdate(32);for(const e of this.layerInfo[0])e.pendingUpdates|=32}invalidateLayerData(e,t){this.layerInfo[t][e].invalidateSourceData(),this.restartAgents(t)}computeElevationBounds(){v(this._elevationBounds,Number.MAX_VALUE,-Number.MAX_VALUE);const e=this.layerInfo[0];let t=!0;for(const i of e)i.elevationBounds&&(this._elevationBounds[0]=Math.min(this._elevationBounds[0],i.elevationBounds.min),this._elevationBounds[1]=Math.max(this._elevationBounds[1],i.elevationBounds.max),i.elevationBounds.hasNoDataValues||(t=!1));t&&(this._elevationBounds[0]=Math.min(this._elevationBounds[0],0),this._elevationBounds[1]=Math.max(this._elevationBounds[1],0)),this.updateRadiusAndCenter(),this.surface.setTileTreeDirty()}_updateCenter(){const e=.5*(this._elevationBounds[0]+this._elevationBounds[1]);d(k,this.up,e),u(this._center[0],this.centerAtSeaLevel,k),d(k,this.up,this._elevationBounds[0]),u(this._center[1],this.centerAtSeaLevel,k),d(k,this.up,this._elevationBounds[1]),u(this._center[2],this.centerAtSeaLevel,k)}findElevationBoundsForLayer(e,t){const i=this.layerInfo[0][e];if(!i.elevationBounds||i.elevationBounds.level<t){const t=this._surface.layerViewByIndex(e,0),s=T(t);if(b(this,s,!1)){const t=$;let s=!1;if(i.data){const e=i.data;t.min=e.bounds[0],t.max=e.bounds[1],t.hasNoDataValues=e.hasNoDataValues,t.level=this.lij[0],s=!0}else{let i,n,r=0;for(let t=this._parent;t&&(!n||r<L)&&(r=this.vlevel-t.level,i=n||i,n=t.layerInfo[0][e].data,!(!n&&i&&r>=L));t=t._parent);n=n||i,n&&(n.computeMinMaxValue(this.lij[0],this.lij[1],this.lij[2],t),t.min!==1/0&&(t.level=n.level,s=!0))}s&&(i.elevationBounds||(i.elevationBounds=new C),i.elevationBounds.copyFrom(t))}}}modifyLayers(e,t,i){const s=this.layerInfo[i];for(const e of s)e.loadingAgent&&e.loadingAgent!==R&&(H(e.loadingAgent),e.loadingAgent=null),e.waitingAgents.length=0;if(1===i)for(let t=0;t<s.length;++t)void 0===e[t]&&s[t].dispose();const n=t.length,r=new Array(n);for(let e=0;e<n;e++){const n=t[e];r[e]=n>-1?s[n]:q.makeEmptyLayerInfo(i,this._surface.upsampleInfoPool)}this.layerInfo[i]=r,this._updateMemoryUsed()}restartAgents(e){this.renderData&&(this._createOrUpdateAgents(0,e),this.updateRenderData(e))}updateAgents(e){if(this.renderData){const t=this.layerInfo[e];for(let e=0;e<t.length;e++){const i=t[e];i.loadingAgent===R&&(i.loadingAgent=null)}this._createOrUpdateAgents(0,e)}}updateAgentSuspension(){for(let e=0;e<2;e++){const t=this.isSuspended(e);for(const i of this.layerInfo[e])i.loadingAgent&&i.loadingAgent!==R&&(i.loadingAgent.setSuspension(t),i.loadingAgent===R&&this.updateRenderData(e))}}removeLayerAgent(e,t){const i=this.layerInfo[t][e];i.loadingAgent&&i.loadingAgent!==R&&i.loadingAgent.dispose(),i.loadingAgent=null}agentDone(e,t){const i=this.layerInfo[t][e];i.loadingAgent=R,i.data||i.upsampleInfo||this._createOrUpdateAgents(e+1,t)}_createOrUpdateAgents(e,t){const i=this.isSuspended(t),s=this.layerInfo[t];for(let n=e;n<s.length;++n){const e=s[n];let r=!1;const a=this._surface.layerViewByIndex(n,t),o=T(a);if(e.loadingAgent?b(this,o,!1)?(e.loadingAgent!==R&&e.loadingAgent.setSuspension(i),e.loadingAgent!==R&&(r=e.loadingAgent.update())):e.dispose():b(this,o,!1)&&(e.loadingAgent=z(this,n,t,i),r=e.loadingAgent.startLoading(),r?e.loadingAgent===R&&this.setPendingUpdate(32):(H(e.loadingAgent),e.loadingAgent=R)),e.loadingAgent===R&&this.updateRenderData(t),r&&a.isOpaque)return}}isWithinExtent(e){const t=this.extent;return t[0]>=e[0]&&e[2]>=t[2]&&t[1]>=e[1]&&e[3]>=t[3]}intersectsExtent(e){const t=this.extent;return t[2]>=e[0]&&e[2]>=t[0]&&t[3]>=e[1]&&e[3]>=t[1]}get test(){return{cachedMemory:this.cachedMemory}}}export{N as SplitLimits,G as pruneAgents};
