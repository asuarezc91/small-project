/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{isSome as t}from"../../../core/maybe.js";import{lerp as e}from"../../../core/mathUtils.js";import{c as n}from"../../../chunks/vec3f64.js";import{s as r}from"../../../chunks/vec3.js";import{a as o}from"../../../chunks/vec4f64.js";import{s}from"../../../chunks/vec4.js";import{empty as i}from"../../../geometry/support/aaBoundingBox.js";import{MAX_PATCH_TESSELATION as c,GEOMETRY_VERTEX_STRIDE as u}from"./TerrainConst.js";import{newLayout as f}from"../support/buffer/InterleavedLayout.js";import{VertexAttrConstants as a}from"../webgl-engine/lib/Util.js";import{computeNormal as m}from"../webgl-engine/materials/internal/MaterialUtil.js";import{ElevationData as l}from"./ElevationData.js";import{BufferPool as p}from"../support/buffer/BufferPool.js";const g=f().vec3f(a.POSITION).vec2f(a.UV0),h=new p((t=>g.createBuffer(t)),(t=>t.count));class d{constructor(){this.indices=null,this.vertexAttributes=null,this.boundingBox=i(),this.numSurfaceIndices=0,this.numSkirtIndices=0,this.numWithoutSkirtIndices=0,this.numVertsPerRow=0,this.skirtLength=0,this.uvOffsetAndScale=o()}}class w{constructor(t,e,n){this.values=t,this.numSurfaceIndices=e,this.numSkirtIndices=n}}function y(){h.clear(),P.clear()}function I(t){h.release(t.vertexAttributes),t.vertexAttributes=null,t.indices=null}function v(t,n,r,o,c,f,a,m){const p=c[0],g=c[1],d=c[2],w=c[3],y=.1*a.radius*(w-g),I=t.numVertsPerRow-1,v=t.numVertsPerRow-1,V=t.numVertsPerRow*t.numVertsPerRow,P=2*I+2*v,b=h.acquire(V+P),j=b.position.typedBuffer,D=b.uv0.typedBuffer,O=o.geometryInfo.boundingBox;i(O);const T=n[2]-n[0],L=n[3]-n[1],q=d-p,W=r[0],C=r[1],E=r[2];for(let t=0;t<=I;t++){const e=t/I,r=p+e*q;k[t]=Math.sin(r),M[t]=Math.cos(r),B[t]=e,U[t]=n[0]+e*T}const N=f&&!!(1&m),z=f&&!!(2&m);let F=0;for(let r=0;r<=v;r++){let o=r/v;const s=e(g,w,o),i=Math.cos(s),c=Math.sin(s);let m;f?(m=a.halfSemiMajorAxis*Math.log((1+c)/(1-c)),o=(m-n[1])/L):m=180*s/Math.PI;for(let e=0;e<=I;e++){const n=B[e],s=k[e],f=M[e];let p=a.radius;t.samplerData&&(p+=l.sample(U[e],m,t.samplerData)||0);const g=f*i*p-W,h=s*i*p-C,d=c*p-E;A(g,h,d,O);const w=u*F;j[w+0]=g,j[w+1]=h,j[w+2]=d,D[w+0]=n,D[w+1]=o;const P=R(e,r,I,v);if(P>-1){const t=u*(V+P),e=N&&0===r?-1:z&&r===v?1:0,s=0===e?g:-W,i=0===e?h:-C,c=0===e?d:a.radius*e-E;j[t+0]=s,j[t+1]=i,j[t+2]=c,D[t+0]=0===e?S(n,o):n,D[t+1]=0===e?y:o,0!==e&&A(s,i,c,O)}++F}}o.geometryInfo.numVertsPerRow=t.numVertsPerRow,o.geometryInfo.vertexAttributes=b,o.geometryInfo.skirtLength=y,s(o.geometryInfo.uvOffsetAndScale,0,0,1,1),x(o.geometryInfo,t.numVertsPerRow,f?m:0,t.wireframe)}function V(t,e,n,r){const o=e[0],c=e[1],f=e[2]-o,a=e[3]-c,m=t.clippingArea,p=m?Math.max(0,(m[0]-e[0])/f):0,g=m?Math.max(0,(m[1]-e[1])/a):0,d=m?Math.min(1,(m[2]-e[0])/f):1,w=m?Math.min(1,(m[3]-e[1])/a):1,y=d>p?1/(d-p):1,I=w>g?1/(w-g):1,v=-p*y,V=-g*I,P=.1*f,b=t.numVertsPerRow-1,j=t.numVertsPerRow-1,k=t.numVertsPerRow*t.numVertsPerRow,M=2*b+2*j,B=h.acquire(k+M),U=B.position.typedBuffer,D=B.uv0.typedBuffer,O=r.geometryInfo.boundingBox;i(O);let T=0;for(let e=0;e<=j;e++){const r=e/j;let s=V+r*I,i=c+r*a;m&&(i<m[1]?(i=m[1],s=0):i>m[3]&&(i=m[3],s=1));for(let r=0;r<=b;r++){const c=r/b;let a=v+c*y,p=o+c*f;m&&(p<m[0]?(p=m[0],a=0):p>m[2]&&(p=m[2],a=1));const g=t.samplerData&&l.sample(p,i,t.samplerData)||0,h=p-n[0],d=i-n[1],w=g-n[2];A(h,d,w,O);const I=u*T;U[I+0]=h,U[I+1]=d,U[I+2]=w,D[I+0]=a,D[I+1]=s;const V=R(r,e,b,b);if(V>-1){const t=u*(k+V);U[t+0]=h,U[t+1]=d,U[t+2]=w,D[t+0]=S(a,s),D[t+1]=P}++T}}r.geometryInfo.numVertsPerRow=t.numVertsPerRow,r.geometryInfo.vertexAttributes=B,r.geometryInfo.skirtLength=P,s(r.geometryInfo.uvOffsetAndScale,p,g,d-p,w-g),x(r.geometryInfo,t.numVertsPerRow,0,t.wireframe)}const P=new Map;function x(t,e,n,r){const o=(2&n)>0,s=e+(r?1024:0)+(o?2048:0);let i=P.get(s);i||(i=function(t,e,n){const r=t-1,o=t-1,s=t*t,i=2*r+2*o;let c=r*o*2*3,u=6*i,f=6*(2*r+o-1);n&&(c*=2,u*=2,f*=2);const a=s+i>65536?new Uint32Array(c+u):new Uint16Array(c+u);let m,l,p,g,h=0,d=0,y=c,I=0;for(let t=0;t<=o;t++){e&&(I=0===t?f:t===o?-f:0),y+=I;for(let e=0;e<=r;e++){const i=R(e,t,r,o);if(i>-1){const c=b(e,t,r,o);0!==c&&(m=h,l=s+i,p=s+(0===e&&1===t?0:i+1),g=h+c,n?(a[y+0]=m,a[y+1]=l,a[y+2]=l,a[y+3]=p,a[y+4]=p,a[y+5]=m,a[y+6]=p,a[y+7]=g,a[y+8]=g,a[y+9]=m,a[y+10]=m,a[y+11]=p,y+=12):(a[y+0]=m,a[y+1]=l,a[y+2]=p,a[y+3]=p,a[y+4]=g,a[y+5]=m,y+=6))}++h,e<r&&t<o&&(m=t*(r+1)+e,l=m+1,p=l+(r+1),g=p-1,n?(a[d+0]=m,a[d+1]=l,a[d+2]=l,a[d+3]=p,a[d+4]=p,a[d+5]=m,a[d+6]=p,a[d+7]=g,a[d+8]=g,a[d+9]=m,a[d+10]=m,a[d+11]=p,d+=12):(a[d+0]=m,a[d+1]=l,a[d+2]=p,a[d+3]=p,a[d+4]=g,a[d+5]=m,d+=6))}y-=I}return new w(a,c,u)}(e,o,r),P.set(s,i)),t.indices=i.values,t.numSurfaceIndices=i.numSurfaceIndices,t.numSkirtIndices=i.numSkirtIndices,t.numWithoutSkirtIndices=t.numSurfaceIndices+(n?6*(e-1)*(r?2:1):0)}function A(t,e,n,r){t<r[0]&&(r[0]=t),t>r[3]&&(r[3]=t),e<r[1]&&(r[1]=e),e>r[4]&&(r[4]=e),n<r[2]&&(r[2]=n),n>r[5]&&(r[5]=n)}function S(t,e){const n=e>t?1:0;return 2+4*n+(1-2*n)*(t+e)}function R(t,e,n,r){return 0===e?t:t===n?n+e:e===r?n+r+(n-t):0===t&&e>0?2*n+r+(r-e):-1}function b(t,e,n,r){return 0===e&&t!==n?1:t===n&&e!==r?n+1:e===r&&0!==t?-1:0===t&&0!==e?-(n+1):0}function j(e,n,o,s,i,c,u,f,a){const l=c.position,p=c.uv0,g=e[0],h=e[1],d=e[2],w=n[0]-g,y=n[1]-h,I=n[2]-d;s*=3;for(let e=o*=3;e<s;e+=3){const n=i[e],o=i[e+1],s=i[e+2];let c=l.get(n,0),v=l.get(n,1),V=l.get(n,2),P=l.get(o,0),x=l.get(o,1),A=l.get(o,2),S=l.get(s,0),R=l.get(s,1),b=l.get(s,2);const j=p.get(n,0),k=p.get(o,0),M=p.get(s,0);j>=2&&(r(D,c,v,V),u(D),c+=D[0],v+=D[1],V+=D[2]),k>=2&&(r(D,P,x,A),u(D),P+=D[0],x+=D[1],A+=D[2]),M>=2&&(r(D,S,R,b),u(D),S+=D[0],R+=D[1],b+=D[2]),t(f)&&([c,v,V]=f.applyToVertex(c,v,V),[P,x,A]=f.applyToVertex(P,x,A),[S,R,b]=f.applyToVertex(S,R,b));const B=P-c,U=x-v,T=A-V,L=S-c,q=R-v,W=b-V,C=y*W-q*I,E=I*L-W*w,N=w*q-L*y,z=B*C+U*E+T*N,F=g-c,G=h-v,H=d-V,J=G*T-U*H,K=H*B-T*F,Q=F*U-B*G;if(z>2220446049250313e-31){const t=F*C+G*E+H*N;if(t<0||t>z)continue;const e=w*J+y*K+I*Q;if(e<0||t+e>z)continue}else{if(!(z<-2220446049250313e-31))continue;{const t=F*C+G*E+H*N;if(t>0||t<z)continue;const e=w*J+y*K+I*Q;if(e>0||t+e<z)continue}}const X=(L*J+q*K+W*Q)/z;if(X>=0){a(X,m(B,U,T,L,q,W,O))}}}const k=new Array(c+1),M=new Array(c+1),B=new Array(c+1),U=new Array(c+1),D=n(),O=n();export{d as PatchGeometry,y as clearCaches,V as createPlanarGlobePatch,v as createSphericalGlobePatch,j as intersectSkirts,I as releaseGeometry};
