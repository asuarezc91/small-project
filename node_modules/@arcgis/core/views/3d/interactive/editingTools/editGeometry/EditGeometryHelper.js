/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{isNone as e,isSome as t,unwrap as i}from"../../../../../core/maybe.js";import s from"../../../../../core/Evented.js";import{Vertex as r,Edge as h}from"./EditGeometry.js";export{Component,Edge,EditGeometry,Vertex}from"./EditGeometry.js";class d extends s{constructor(e,t){super(),this.data=e,this.type=t,this._dirty=!0,this._geometry=null}splitEdge(e,t){const i=new n(this,e,t);return this.data.apply(i),this._dirty=!0,i}moveVertices(e,t,i,s){let r=null;return this.data.lastOperation instanceof o&&this.data.lastOperation.canAccumulate(e)?(r=this.data.lastOperation,r.accumulate(t,i,s)):(r=new o(this,e,t,i,s),this.data.apply(r)),this._dirty=!0,r}removeVertices(e){let t=0;switch(this.type){case"point":t=1;break;case"polyline":t=2;break;case"polygon":t=3}const i=new a(this,e,t);return this.data.apply(i),this._dirty=!0,i}appendVertex(e){if(0===this.data.components.length)return null;const t=new l(this,this.data.components[0],e);return this.data.apply(t),this._dirty=!0,t}canRemoveVertex(){let e=0;switch(this.type){case"point":e=1;break;case"polyline":e=2;break;case"polygon":e=3}return this.data.components[0].vertices.length>e}undo(){this.data.undo(),this._dirty=!0}get canUndo(){return this.data.canUndo}redo(){this.data.redo(),this._dirty=!0}get canRedo(){return this.data.canRedo}get geometry(){if(this._dirty){switch(this.type){case"point":this._geometry=this.data.toPoint();break;case"polyline":this._geometry=this.data.toPolyline();break;case"polygon":this._geometry=this.data.toPolygon()}this._dirty=!1}return this._geometry}}class n{constructor(e,t,i){this.helper=e,this.edge=t,this.t=i,this.createdVertex=null,this.left=null,this.right=null}apply(){let t="redo";const i=this.edge,s=i.component,d=i.component.data,n=i.left,o=i.right;s.edges.splice(s.edges.indexOf(i),1),e(this.createdVertex)&&(t="apply",this.createdVertex=new r(i.component)),s.vertices.push(this.createdVertex),this.createdVertex.pos=d.coordinateHelper.lerp(i.left.pos,i.right.pos,this.t,d.coordinateHelper.createNew()),e(this.left)&&(this.left=new h(s,n,this.createdVertex)),this.left.left.left?s.edges.push(this.left):s.edges.unshift(this.left),n.right=this.left,e(this.right)&&(this.right=new h(s,this.createdVertex,o)),s.edges.push(this.right),o.left=this.right,s.updateVertexIndex(this.createdVertex,n.index+1);const a={type:"vertex-add",vertices:[this.createdVertex],operation:t};this.helper.emit("vertex-add",a)}undo(){if(e(this.createdVertex)||e(this.left)||e(this.right))return null;const t=this.edge,i=t.component,s=this.createdVertex.left,r=this.createdVertex.right,h=s.left,d=r.right;i.vertices.splice(i.vertices.indexOf(this.createdVertex),1),i.edges.splice(i.edges.indexOf(this.left),1),i.edges.splice(i.edges.indexOf(this.right),1),this.edge.left.left?i.edges.push(this.edge):i.edges.unshift(this.edge),h.right=t,d.left=t,i.updateVertexIndex(h,h.index);const n={type:"vertex-remove",vertices:[this.createdVertex],operation:"undo"};this.helper.emit("vertex-remove",n)}}class o{constructor(e,t,i,s,r){this.helper=e,this.applied=!1,this.vertices=t,this.dx=i,this.dy=s,this.dz=r}apply(){this.vertices.forEach((e=>{this.helper.data.coordinateHelper.addDelta(e.pos,this.dx,this.dy,this.dz)})),this.helper.data.components.forEach((e=>{e.unnormalizeVertexPositions()}));const e={type:"vertex-update",vertices:this.vertices,operation:this.applied?"redo":"apply"};this.helper.emit("vertex-update",e),this.applied=!0}undo(){this.vertices.forEach((e=>{this.helper.data.coordinateHelper.addDelta(e.pos,-this.dx,-this.dy,-this.dz)}));const e={type:"vertex-update",vertices:this.vertices,operation:"undo"};this.helper.emit("vertex-update",e)}canAccumulate(e){if(e.length!==this.vertices.length)return!1;for(let t=0;t<e.length;++t)if(e[t]!==this.vertices[t])return!1;return!0}accumulate(e,t,i){this.vertices.forEach((s=>{this.helper.data.coordinateHelper.addDelta(s.pos,e,t,i)})),this.dx+=e,this.dy+=t,this.dz+=i;const s={type:"vertex-update",vertices:this.vertices,operation:"apply"};this.helper.emit("vertex-update",s)}}class a{constructor(e,t,i=0){this.helper=e,this.removedVertices=null,this._minNumberOfVertices=0,this.vertices=t,this._minNumberOfVertices=i}apply(){let e="redo";null==this.removedVertices?(this.removedVertices=[],this.vertices.forEach((e=>{const i=this._removeVertex(e);t(i)&&this.removedVertices.push(i)})),e="apply"):this.removedVertices.forEach((e=>{this._redoRemoveVertex(e)}));const i={type:"vertex-remove",vertices:this.vertices,operation:e};this.helper.emit("vertex-remove",i)}undo(){this.removedVertices.forEach((e=>{this._undoRemoveVertex(e)}));const e={type:"vertex-add",vertices:this.vertices,operation:"undo"};this.helper.emit("vertex-add",e)}_removeVertex(e){const t=e.component;if(t.vertices.length<=this._minNumberOfVertices)return null;const i={removedVertex:e,createdEdge:null},s=e.left,r=e.right;return t.vertices.splice(t.vertices.indexOf(e),1),s&&(t.edges.splice(t.edges.indexOf(s),1),s.left.right=null),r&&(t.edges.splice(t.edges.indexOf(r),1),r.right.left=null),0===e.index&&r&&this.vertices.length>0&&t.swapVertices(t.vertices.indexOf(r.right),0),s&&r&&(i.createdEdge=new h(t,s.left,r.right),t.edges.push(i.createdEdge)),r&&t.updateVertexIndex(r.right,r.right.index-1),i}_redoRemoveVertex(e){console.warn("redo remove vertex not implemented yet")}_undoRemoveVertex(e){const t=e.removedVertex,i=e.removedVertex.component,s=t.left,r=t.right;e.createdEdge&&i.edges.splice(i.edges.indexOf(e.createdEdge),1),i.vertices.push(t),s&&(i.edges.push(s),s.left.right=s),r&&(i.edges.push(r),r.right.left=r),i.updateVertexIndex(t,t.index)}}class l{constructor(e,t,i){this.helper=e,this.component=t,this.pos=i,this.addedVertex=null,this.originalEdge=null,this.left=null,this.right=null}apply(){let s="redo";if(e(this.addedVertex)&&(s="apply",this.addedVertex=new r(this.component)),0===this.component.vertices.length)this.component.vertices.push(this.addedVertex),this.addedVertex.pos=this.pos,this.addedVertex.index=0;else{const s=i(this.component.findEndVertex());let r=null;s.right&&(this.originalEdge=s.right,r=this.originalEdge.right,this.component.edges.splice(this.component.edges.indexOf(this.originalEdge),1)),this.component.vertices.push(this.addedVertex),this.addedVertex.pos=this.pos,e(this.left)&&(this.left=new h(this.component,s,this.addedVertex)),this.component.edges.push(this.left),s.right=this.left,t(this.originalEdge)&&t(r)&&(e(this.right)&&(this.right=new h(this.component,this.addedVertex,r)),this.component.edges.push(this.right),r.left=this.right),this.component.updateVertexIndex(this.addedVertex,s.index+1)}const d={type:"vertex-add",vertices:[this.addedVertex],operation:s};this.helper.emit("vertex-add",d)}undo(){if(e(this.addedVertex))return null;this.component.vertices.splice(this.component.vertices.indexOf(this.addedVertex),1),t(this.left)&&(this.component.edges.splice(this.component.edges.indexOf(this.left),1),this.left.left.right=null),t(this.right)&&(this.component.edges.splice(this.component.edges.indexOf(this.right),1),this.right.right.left=null),t(this.originalEdge)&&(this.component.edges.push(this.originalEdge),this.originalEdge.left.right=this.originalEdge,this.originalEdge.right.left=this.originalEdge),t(this.left)?this.component.updateVertexIndex(this.left.left,this.left.left.index):this.component.updateVertexIndex(this.addedVertex,0);const i={type:"vertex-remove",vertices:[this.addedVertex],operation:"undo"};this.helper.emit("vertex-remove",i)}}export{l as AppendVertexOperation,d as EditGeometryHelper,a as RemoveVerticesOperation,n as SplitEdgeOperation,o as UpdateVerticesOperation};
