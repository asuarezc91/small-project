/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import t from"../../../../../geometry/Polygon.js";import e from"../../../../../geometry/Polyline.js";import"../../../../../geometry.js";import{createCoordinateHelper as s}from"../coordinateHelper.js";class n{constructor(t){this.left=null,this.right=null,this.type="vertex",this.index=null,this.component=t}get pos(){return this._pos}set pos(t){this._pos=t,this.component.unnormalizeVertexPositions()}}class i{constructor(t,e,s){this.type="edge",this.component=t,this.left=e,this.right=s,e.right=this,s.left=this}}class o{constructor(t){this.vertices=[],this.edges=[],this.data=t}unnormalizeVertexPositions(){this.vertices.length<=1||this.data.coordinateHelper.unnormalize(this.vertices)}updateVertexIndex(t,e){if(0===this.vertices.length)return;const s=this.vertices[0];let n=null,i=t,o=e;do{n=i,n.index=o++,i=n.right?n.right.right:null}while(null!=i&&i!==s);n.left&&n!==this.vertices[this.vertices.length-1]&&this.swapVertices(this.vertices.indexOf(n),this.vertices.length-1)}findEndVertex(){return 0===this.vertices.length?null:this.vertices[this.vertices.length-1]}swapVertices(t,e){const s=this.vertices[t];this.vertices[t]=this.vertices[e],this.vertices[e]=s}}class r{constructor(t){this.coordinateHelper=t,this.undoStack=[],this.redoStack=[],this.components=[]}apply(t){t.apply(),this.undoStack.push(t),this.redoStack=[]}undo(){if(this.undoStack.length>0){const t=this.undoStack.pop();t.undo(),this.redoStack.push(t)}}get canUndo(){return this.undoStack.length>0}get lastOperation(){return this.undoStack.length>0?this.undoStack[this.undoStack.length-1]:null}redo(){if(this.redoStack.length>0){const t=this.redoStack.pop();t.apply(),this.undoStack.push(t)}}get canRedo(){return this.redoStack.length>0}toPoint(){return 0===this.components.length||0===this.components[0].vertices.length?null:this.coordinateHelper.createPoint(this.components[0].vertices[0].pos)}toPolyline(){const t=[],s=this.coordinateHelper.toArray;return this.components.forEach(((e,n)=>{const i=[];let o=e.vertices.find((t=>null==t.left));const r=o;do{i.push(s(o.pos)),o=o.right?o.right.right:null}while(o&&o!==r);t.push(i)})),new e({paths:t,spatialReference:this.coordinateHelper.spatialReference})}toPolygon(){const e=[],s=this.coordinateHelper.toArray;return this.components.forEach(((t,n)=>{const i=[],o=t.vertices[0];let r=o;const h=r;do{i.push(s(r.pos)),r=r.right.right}while(r&&r!==h);i.push(s(o.pos)),e.push(i)})),new t({rings:e,spatialReference:this.coordinateHelper.spatialReference})}static fromGeometry(t,e){const h=s(t.hasZ,t.hasM,t.spatialReference,e),c=new r(h);switch(t.type){case"polygon":{const e=t.rings;for(let t=0;t<e.length;++t){const s=e[t],r=new o(c),l=s.length-1;for(let t=0;t<l;++t){const e=h.fromArray(s[t]),i=new n(r);r.vertices.push(i),i.pos=e,i.index=t}const p=r.vertices.length-1;for(let t=0;t<p;++t){const e=r.vertices[t],s=r.vertices[t+1],n=new i(r,e,s);r.edges.push(n)}const a=new i(r,r.vertices[r.vertices.length-1],r.vertices[0]);r.edges.push(a),c.components.push(r)}}break;case"polyline":{const e=t.paths;for(let t=0;t<e.length;++t){const s=e[t],r=new o(c),l=s.length;for(let t=0;t<l;++t){const e=h.fromArray(s[t]),i=new n(r);r.vertices.push(i),i.pos=e,i.index=t}const p=r.vertices.length-1;for(let t=0;t<p;++t){const e=r.vertices[t],s=r.vertices[t+1],n=new i(r,e,s);r.edges.push(n)}c.components.push(r)}}}return c}}export{o as Component,i as Edge,r as EditGeometry,n as Vertex};
