/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../../chunks/tslib.es6.js";import"../../../../../core/has.js";import{isSome as e,isNone as i}from"../../../../../core/maybe.js";import a from"../../../../../core/Logger.js";import"../../../../../core/accessorSupport/ensureType.js";import{property as s}from"../../../../../core/accessorSupport/decorators/property.js";import{subclass as r}from"../../../../../core/accessorSupport/decorators/subclass.js";import"../../../../../core/urlUtils.js";import"../../../../../core/uuid.js";import"../../../../../portal/support/resourceExtension.js";import n from"../../../../../core/clock.js";import{addFrameTask as o}from"../../../../../core/scheduling.js";import l from"../../../../../core/Collection.js";import{createScreenPoint as h,screenPointObjectToArray as p,createScreenPointArray as u}from"../../../../../core/screenUtils.js";import{referenceSetter as d,castForReferenceSetter as c}from"../../../../../core/collectionUtils.js";import{b as _,c as g}from"../../../../../chunks/vec3f64.js";import{d as v,l as y,g as m,a as f,b as P,i as M,n as w,s as b}from"../../../../../chunks/vec3.js";import T from"../../../../../core/Handles.js";import x from"../../../../../layers/Layer.js";import{init as S}from"../../../../../core/watchUtils.js";import{i as k,r as C,p as H,m as j}from"../../../../../chunks/mat4.js";import L from"../../../../../layers/buildingSublayers/BuildingComponentSublayer.js";import{setActive as D}from"../../../../interactive/interactiveToolUtils.js";import{createScreenPointFromEvent as R}from"../../../../support/screenUtils.js";import{sv3d as E,sm4d as O,sv2d as z}from"../../../support/stack.js";import{boundedPlane as U,plane as I,ray as V}from"../../../support/geometryUtils.js";import{Intersector as G}from"../../../webgl-engine/lib/Intersector.js";import K from"../../../webgl-engine/lib/Texture.js";import{createManipulatorDragEventPipeline as A}from"../../../../interactive/dragEventPipeline.js";import{InteractiveToolBase as F}from"../../../../interactive/InteractiveToolBase.js";import{screenToRenderPlane as B}from"../../editingTools/dragEventPipeline3D.js";import{calculateInputRotationTransform as $}from"../../manipulatorUtils.js";import{forceVerticalModifier as N,forceHorizontalModifier as q,PREVIEW_FADE_DURATION_SECONDS as J,POINTER_MOVE_TIMER_MS as Q,PLANE_OUTLINE_COLOR as W,PLANE_BACKGROUND_COLOR as X,PREVIEW_FADE_DOT_THRESHOLD as Y,INITIAL_DEPTH_OFFSET_FRAC as Z,GRID_COLOR as tt}from"./sliceToolConfig.js";import{isAlwaysDrapedLayer as et,createShiftManipulator as it,createRotateManipulator as at,createResizeManipulator as st,createOutlineManipulator as rt,createGridManipulator as nt,forceHorizontalOrVertical as ot,createRotatePlane as lt,resizePlane as ht,calculatePlaneHalfSize as pt,createPlane as ut,DidPointerMoveRecentlyFlag as dt,calculateBoundedPlaneTranslateRotate as ct,updateShiftRestartHandle as _t,updateRotateHeadingHandle as gt,updateRotateTiltHandle as vt,updateResizeHandle as yt,createShiftPlane as mt}from"./sliceToolUtils.js";import ft from"./images/heading-rotate-png.js";import Pt from"./images/tilt-rotate-png.js";const Mt=a.getLogger("esri.views.3d.interactive.analysisTools.slice.SliceTool");let wt=class extends F{constructor(t){super(t),this.clock=n,this.deferCreation=!0,this.cursor=null,this.layersMode="none",this.shiftManipulator=null,this.rotateHeadingManipulator=null,this.rotateTiltManipulator=null,this.resizeManipulators=null,this.disableEngineLayers=!1,this._handles=new T,this._viewHandles=new T,this._frameTask=null,this._prevPointerMoveTimeout=null,this._previewOutlineManipulator=null,this._previewOutlineMaterial=null,this._outlineManipulator=null,this._gridManipulator=null,this._gridMaterial=null,this._startPlane=U.create(),this._previewPlane=null,this._activeKeyModifiers={},this._lastCursorPosition=h(),this._baseOpacity=1,this._resizeHandles=[{direction:[1,0]},{direction:[1,1]},{direction:[0,1]},{direction:[-1,1]},{direction:[-1,0]},{direction:[-1,-1]},{direction:[0,-1]},{direction:[1,-1]}],this._intersector=new G(t.view.state.mode),this._intersector.options.store=0}initialize(){this.rotateHeadingTexture=new K(ft,"slice-rotate-heading",{width:64,height:64,mipmap:!0,preMultiplyAlpha:!0}),this.rotateTiltTexture=new K(Pt,"slice-rotate-tilt",{width:64,height:64,mipmap:!0,preMultiplyAlpha:!0}),this.view._stage&&(this.view._stage.add(4,this.rotateHeadingTexture),this.view._stage.add(4,this.rotateTiltTexture));const t=S(this,"state",(t=>{"ready"!==t&&this.create(),"sliced"===t&&this.complete()}),!0);this._handles.add([t,this.view.state.watch("camera",(()=>this._onCameraChange())),this.excludedLayers.on("before-add",(t=>{const e=t.item;null!=e&&(e instanceof x||e instanceof L)?e instanceof x&&et(e)?(Mt.error("excludedLayers",`Layer '${e.title}, id:${e.id}' of type '${e.type}' can not be individually excluded from slicing. Use 'excludeGroundSurface' instead.`),t.preventDefault()):this.excludedLayers.includes(e)&&t.preventDefault():(Mt.error("excludedLayers","Invalid layer type, layer must derive from Layer or BuildingComponentSublayer"),t.preventDefault())}))]);const i=t=>{this.updateManipulatorsInteractive(t),t.grabbing||(e(this.plane)&&U.copy(this.plane,this._startPlane),this.inputState=null)};this.shiftManipulator=it(this.view),this.manipulators.add(this.shiftManipulator),this.shiftManipulator.events.on("grab-changed",(t=>{this._onShiftGrab(t),i(this.shiftManipulator)})),this._handles.add(this._createShiftDragPipeline(this.shiftManipulator)),this.rotateHeadingManipulator=at(this.view,this.rotateHeadingTexture),this.manipulators.add(this.rotateHeadingManipulator),this.rotateHeadingManipulator.events.on("grab-changed",(t=>{this._onRotateHeadingGrab(t),i(this.rotateHeadingManipulator)})),this._handles.add(this._createRotateHeadingDragPipeline(this.rotateHeadingManipulator)),this.rotateTiltManipulator=at(this.view,this.rotateTiltTexture),this.manipulators.add(this.rotateTiltManipulator),this.rotateTiltManipulator.events.on("grab-changed",(t=>{this._onRotateTiltGrab(t),i(this.rotateTiltManipulator)})),this._handles.add(this._createRotateTiltDragPipeline(this.rotateTiltManipulator)),this.resizeManipulators=this._resizeHandles.map(((t,e)=>{const a=st(this.view,t);return a.events.on("grab-changed",(t=>{this._onResizeGrab(t,e),i(a)})),this._handles.add(this._createResizeDragPipeline(a)),a})),this.manipulators.addMany(this.resizeManipulators);const{manipulator:a,material:s}=rt(this.view);this._previewOutlineManipulator=a,this._previewOutlineMaterial=s,this.manipulators.add(this._previewOutlineManipulator,2),this._outlineManipulator=rt(this.view).manipulator,this.manipulators.add(this._outlineManipulator,1);const{manipulator:r,material:n}=nt(this.view);this._gridManipulator=r,this._gridMaterial=n,this.manipulators.add(this._gridManipulator,2)}destroy(){this.view._stage&&(this.view._stage.remove(4,this.rotateHeadingTexture.id),this.view._stage.remove(4,this.rotateTiltTexture.id)),this.detach(),this._handles.destroy(),this._handles=null,this._viewHandles.destroy(),this._viewHandles=null,this._removeFrameTask(),this._clearPointerMoveTimeout()}get state(){const t=!!this.plane,e=!!this.inputState;return t?t&&e?"slicing":t&&!e?"sliced":"ready":"ready"}get isSupported(){return"3d"===this.get("view.type")}set plane(t){this.view?e(t)&&!this.tiltEnabled?this.internalSetPlane(ot(t,this.view.renderCoordsHelper,U.create())):this.internalSetPlane(t):this._set("plane",t)}internalSetPlane(t){this._set("plane",t),this.planeChanged()}planeChanged(){this.view&&(this._updateLayerViews(),this.visible&&this.attached&&(this.view.slicePlane=this.plane,this._updateManipulators()))}get excludedLayers(){return this._get("excludedLayers")||new l}set excludedLayers(t){this._set("excludedLayers",d(t,this._get("excludedLayers")))}set excludeGroundSurface(t){this._set("excludeGroundSurface",t),this.view&&this._updateLayerViews()}set tiltEnabled(t){t!==this._get("tiltEnabled")&&(this._set("tiltEnabled",t),this.view&&(this._updatePreviewPlane(this._lastCursorPosition,this._activeKeyModifiers),e(this.plane)&&!t&&(this.plane=U.copy(this.plane)),this._updateManipulators()))}get inputState(){return this._get("inputState")}set inputState(t){this._set("inputState",t),this._updateMaterials()}get _isTargeting(){return!this.inputState&&!this.plane&&this.active}get _creatingPointerId(){return this.inputState&&"shift"===this.inputState.type?this.inputState.creatingPointerId:null}enterExcludeLayerMode(){this.created&&(this._set("layersMode","exclude"),D(this,!0))}exitExcludeLayerMode(){this.created&&(this._set("layersMode","none"),D(this,!1))}deactivate(){this._updateMouseCursor(),this._set("layersMode","none"),this._updatePreviewPlane(null)}onDetach(){this.plane=null,this._set("layersMode","none")}onShow(){this._updateMouseCursor(),this._updateLayerViews(),this._updateManipulators();const t=this.view;t.slicePlane=this.plane,0===this._viewHandles.size&&this._viewHandles.add([t.allLayerViews.on("change",(()=>this._updateLayerViews())),this.excludedLayers.on("change",(()=>this._updateLayerViews()))])}onHide(){this._updateMouseCursor(),this._updateLayerViews(),this.view.slicePlane=null,this._viewHandles.removeAll(),this._clearPointerMoveTimeout()}onInputEvent(t){switch(t.type){case"pointer-down":if(!Tt(t))return;this._onPointerDown(t)&&(t.stopPropagation(),this._updateMouseCursor());break;case"pointer-drag":if(!Tt(t))return;this._onPointerDrag(t)&&t.stopPropagation();break;case"pointer-move":this._onPointerMove(t),this._updateMouseCursor();break;case"pointer-up":this._onPointerUp(t)&&t.stopPropagation();break;case"click":if(!Tt(t))return;this._onClick(t)&&t.stopPropagation();break;case"drag":this.inputState&&t.stopPropagation();break;case"key-down":this._onKeyDown(t)&&t.stopPropagation();break;case"key-up":this._onKeyUp(t)&&t.stopPropagation()}}_updateLayerViews(){const t=!(!this.plane||!this.visible),e=[],i=t=>{"layers"in t?t.layers.forEach(i):e.push(t)};this.excludedLayers.forEach(i),this.view.allLayerViews.forEach((i=>{"slicePlaneEnabled"in i&&(i.slicePlaneEnabled=t&&e.indexOf(i.layer)<0),"sublayerViews"in i&&i.sublayerViews.forEach((i=>{i.slicePlaneEnabled=t&&e.indexOf(i.sublayer)<0}))})),this.view.basemapTerrain.slicePlaneEnabled=t&&!this.excludeGroundSurface}_onPointerDown(t){if("exclude"===this.layersMode)return!0;if(this._isTargeting){const e=R(t),i=U.create();if(this._pickPlane(e,!1,this._activeKeyModifiers,i)){U.copy(i,this._startPlane);const a=this._calculatePickRay(e);return this.inputState=bt(a,t.pointerId,i.origin,i),this.internalSetPlane(i),!0}}return!1}_onPointerDrag(t){if(t.pointerId===this._creatingPointerId){const e=R(t);return this.shiftManipulator.events.emit("drag",{action:"start",pointerType:t.pointerType,start:e,screenPoint:e}),!0}return!1}_onPointerMove(t){this._lastCursorPosition.x=t.x,this._lastCursorPosition.y=t.y,this._resetPointerMoveTimeout(),"touch"!==t.pointerType&&this._updatePreviewPlane(R(t),this._activeKeyModifiers)}_onCameraChange(){this._updatePreviewPlane(this._lastCursorPosition,this._activeKeyModifiers),this._updateManipulators()}_onPointerUp(t){return!(t.pointerId!==this._creatingPointerId||!e(this.plane))&&(U.copy(this.plane,this._startPlane),this.inputState=null,!0)}_onClick(t){return!("exclude"!==this.layersMode||!this.created)&&(this.view.hitTest(R(t)).then((t=>{if(t.results.length){const e=t.results[0],i=e&&e.graphic;if(i){const t=i.sourceLayer||i.layer;t&&this.excludedLayers.push(t)}}else t.ground.layer?this.excludedLayers.push(t.ground.layer):this.excludeGroundSurface=!0})),this._set("layersMode","none"),D(this,!1),!0)}_onKeyDown(t){return(t.key===N||t.key===q)&&(this._activeKeyModifiers[t.key]=!0,e(this._previewPlane)&&this._updatePreviewPlane(this._lastCursorPosition,this._activeKeyModifiers),!0)}_onKeyUp(t){return!(t.key!==N&&t.key!==q||!this._activeKeyModifiers[t.key])&&(delete this._activeKeyModifiers[t.key],e(this._previewPlane)&&this._updatePreviewPlane(this._lastCursorPosition,this._activeKeyModifiers),!0)}_onShiftGrab(t){if("start"!==t.action||i(this.plane))return;const e=this._calculatePickRay(t.screenPoint);U.copy(this.plane,this._startPlane),this.inputState=bt(e,null,this.shiftManipulator.renderLocation,this.plane)}_createShiftDragPipeline(t){return A(t,((t,e)=>{const i=this.inputState;i&&"shift"===i.type&&e.next(B(this.view,i.shiftPlane)).next(this._shiftDragAdjustSensitivity(i)).next(this._shiftDragUpdatePlane(i))}))}_shiftDragAdjustSensitivity(t){return e=>{if(i(this.plane))return null;const a=Math.min((1-Math.abs(v(U.normal(this.plane),e.ray.direction)/y(e.ray.direction)))/.001,1),s=-I.signedDistance(this._startPlane.plane,e.renderEnd),r=-I.signedDistance(this._startPlane.plane,t.startPoint);return t.depth=t.depth*(1-a)+s*a-r,e}}_shiftDragUpdatePlane(t){return()=>{if(i(this.plane))return;const e=m(E.get(),this._startPlane.origin),a=m(E.get(),U.normal(this._startPlane));f(a,a,-t.depth),P(a,a,e),U.fromValues(a,this.plane.basis1,this.plane.basis2,this.plane),this.planeChanged(),this.notifyChange("plane")}}_onRotateHeadingGrab(t){if("start"!==t.action||i(this.plane))return;const e=lt(this.plane,this.view.renderCoordsHelper,1,I.create()),a=this._calculatePickRay(t.screenPoint),s=g();I.intersectRay(e,a,s)&&(U.copy(this.plane,this._startPlane),this.inputState={type:"rotate",rotatePlane:e,startPoint:s})}_createRotateHeadingDragPipeline(t){return A(t,((t,e)=>{const i=this.inputState;i&&"rotate"===i.type&&e.next(B(this.view,i.rotatePlane)).next(this._rotateDragRenderPlaneToRotate(i)).next(this._rotateDragUpdatePlaneFromRotate())}))}_onRotateTiltGrab(t){if("start"!==t.action||i(this.plane))return;const e=lt(this.plane,this.view.renderCoordsHelper,2,I.create()),a=this._calculatePickRay(t.screenPoint),s=g();I.intersectRay(e,a,s)&&(U.copy(this.plane,this._startPlane),this.inputState={type:"rotate",rotatePlane:e,startPoint:s})}_createRotateTiltDragPipeline(t){return A(t,((t,e)=>{const i=this.inputState;i&&"rotate"===i.type&&e.next(B(this.view,i.rotatePlane)).next(this._rotateDragRenderPlaneToRotate(i)).next(this._rotateDragUpdatePlaneFromRotate())}))}_rotateDragRenderPlaneToRotate(t){return e=>{if(i(this.plane))return null;const a=I.normal(t.rotatePlane),s=$(this.inputState.startPoint,e.renderEnd,this.plane.origin,a);return{...e,rotateAxis:a,rotateAngle:s}}}_rotateDragUpdatePlaneFromRotate(){return t=>{if(i(this.plane))return;const e=k(O.get());C(e,e,t.rotateAngle,t.rotateAxis);const a=M(E.get(),this._startPlane.basis1,e),s=M(E.get(),this._startPlane.basis2,e);U.fromValues(this.plane.origin,a,s,this.plane),this.planeChanged(),this.notifyChange("plane")}}_onResizeGrab(t,e){if("start"!==t.action||i(this.plane))return;const a=this._calculatePickRay(t.screenPoint),s=E.get();I.intersectRay(this.plane.plane,a,s)&&(U.copy(this.plane,this._startPlane),this.inputState={type:"resize",activeHandleIdx:e,startPoint:_(s)})}_createResizeDragPipeline(t){return A(t,((t,e)=>{const a=this.inputState;a&&"resize"===a.type&&!i(this.plane)&&e.next(B(this.view,this.plane.plane)).next(this._resizeDragUpdatePlane(a))}))}_resizeDragUpdatePlane(t){return e=>{if(i(this.plane))return;const a=this._resizeHandles[t.activeHandleIdx];ht(a,this.inputState.startPoint,e.renderEnd,this.view._stage.getCamera(),this._startPlane,this.plane),this.planeChanged(),this.notifyChange("plane")}}_updatePreviewPlane(t,a={}){let s=this._previewPlane;if(this._previewPlane=null,i(t))return this._removeFrameTask(),void this._updateManipulators();if(!this.plane&&this.active){const i=e(s)?s:U.create();if(s=e(s)?U.copy(s,xt):null,this._pickPlane(t,!0,a,i)){const t=Y;let a=!1;e(s)&&(a=v(s.plane,i.plane)<t||v(w(E.get(),s.basis1),w(E.get(),i.basis1))<t),a&&(this._baseOpacity=0),this._previewPlane=i}}e(this._previewPlane)&&i(this._frameTask)&&0===this._baseOpacity?this._frameTask=o({update:({deltaTime:t})=>{this._baseOpacity=Math.min(this._baseOpacity+t/(1e3*J),1),this._updateManipulators(),1===this._baseOpacity&&this._removeFrameTask()}}):i(this._previewPlane)&&e(this._frameTask)?this._removeFrameTask():e(this._previewPlane)&&this._updateManipulators()}_removeFrameTask(){e(this._frameTask)&&(this._frameTask.remove(),this._frameTask=null)}_calculatePickRay(t){const e=V.create(),i=p(t,St);return V.fromScreen(this.view.state.camera,i,e),w(e.direction,e.direction),e}_pickMinResult(t){const e=p(t,z.get());return this.view.sceneIntersectionHelper.intersectToolIntersectorScreen(e,this._intersector),this._intersector.results.min}_pickPlane(t,e,i,a){const s=this._pickMinResult(t),r=E.get();if(!s.getIntersectionPoint(r))return!1;const n=s.getTransformedNormal(E.get()),o=this.view._stage.getCamera();v(n,o.viewForward)>0&&f(n,n,-1);const l=pt(r,o),h=(e?1:-1)*l*Z,p=f(E.get(),n,h);P(p,p,r);const u=this.tiltEnabled?3:0,d=i[N]?2:i[q]?1:u;return ut(p,n,l,l,o,d,this.view.renderCoordsHelper,a),!0}_updateMouseCursor(){this._set("cursor",null),this._isTargeting||"exclude"===this.layersMode?this._set("cursor","crosshair"):e(this._creatingPointerId)&&this._set("cursor","grabbing")}_clearPointerMoveTimeout(){this._prevPointerMoveTimeout&&(this._prevPointerMoveTimeout.remove(),this._prevPointerMoveTimeout=null)}_resetPointerMoveTimeout(){this._clearPointerMoveTimeout(),this.shiftManipulator.state|=dt,this.rotateHeadingManipulator.state|=dt,this.rotateTiltManipulator.state|=dt,this._prevPointerMoveTimeout=this.clock.setTimeout((()=>{this.shiftManipulator.state&=~dt,this.rotateHeadingManipulator.state&=~dt,this.rotateTiltManipulator.state&=~dt}),Q)}_updateManipulators(){if(this.disableEngineLayers)return;const t=e(this.plane)?this.plane:e(this._previewPlane)?this._previewPlane:null,i=e(t)&&t===this.plane,a=e(t)&&t===this._previewPlane,s=e(t)?ct(t,O.get()):null;if(this.shiftManipulator.available=i,this.rotateHeadingManipulator.available=i,this.rotateTiltManipulator.available=i&&this.tiltEnabled,this.resizeManipulators.forEach((t=>{t.available=i})),i&&(_t(this.shiftManipulator,s,t,this.view._stage.getCamera()),gt(this.rotateHeadingManipulator,s,t,this.view.renderCoordsHelper),vt(this.rotateTiltManipulator,s,t),this.resizeManipulators.forEach(((e,i)=>{yt(e,this._resizeHandles[i],s,t)}))),this._previewOutlineManipulator.available=a,this._outlineManipulator.available=i,this._gridManipulator.available=e(t),e(t)){const e=b(E.get(),y(t.basis1),y(t.basis2),1),i=H(O.get(),e),a=j(i,s,i);a[12]=0,a[13]=0,a[14]=0;const r=b(E.get(),s[12],s[13],s[14]);this._previewOutlineManipulator.modelTransform=a,this._previewOutlineManipulator.renderLocation=r,this._outlineManipulator.modelTransform=a,this._outlineManipulator.renderLocation=r,this._gridManipulator.modelTransform=a,this._gridManipulator.renderLocation=r,this._updateMaterials()}}_updateMaterials(){const t=[W[0],W[1],W[2],W[3]*this._baseOpacity];this._previewOutlineMaterial.setParameterValues({color:t});const e=[X[0],X[1],X[2],X[3]*this._baseOpacity],i=this.inputState&&"resize"===this.inputState.type?tt:[0,0,0,0];this._gridMaterial.setParameterValues({backgroundColor:e,gridColor:i})}updateManipulatorsInteractive(t){if(!t.grabbing)return this.shiftManipulator.interactive=!0,this.rotateHeadingManipulator.interactive=!0,this.rotateTiltManipulator.interactive=!0,void this.resizeManipulators.forEach((t=>{t.interactive=!0}));this.shiftManipulator.interactive=this.shiftManipulator===t,this.rotateHeadingManipulator.interactive=this.rotateHeadingManipulator===t,this.rotateTiltManipulator.interactive=this.rotateTiltManipulator===t,this.resizeManipulators.forEach((e=>{e.interactive=e===t}))}};function bt(t,e,i,a){const s=mt(i,U.normal(a),t.direction,I.create()),r=g();return I.intersectRay(s,t,r)?{type:"shift",creatingPointerId:e,shiftPlane:s,depth:0,startPoint:r}:null}function Tt(t){return"mouse"!==t.pointerType||0===t.button}t([s()],wt.prototype,"clock",void 0),t([s({constructOnly:!0})],wt.prototype,"view",void 0),t([s({dependsOn:["plane","inputState"],readOnly:!0})],wt.prototype,"state",null),t([s({dependsOn:["view.type"],readOnly:!0})],wt.prototype,"isSupported",null),t([s({readOnly:!0})],wt.prototype,"cursor",void 0),t([s({value:null})],wt.prototype,"plane",null),t([s({readOnly:!0})],wt.prototype,"layersMode",void 0),t([s({cast:c})],wt.prototype,"excludedLayers",null),t([s({type:Boolean,value:!1})],wt.prototype,"excludeGroundSurface",null),t([s({type:Boolean,value:!1})],wt.prototype,"tiltEnabled",null),t([s({value:null})],wt.prototype,"inputState",null),wt=t([r("esri.views.3d.interactive.analysisTools.slice.SliceTool")],wt);const xt=U.create(),St=u();var kt=wt;export default kt;
