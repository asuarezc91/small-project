/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import t from"../../../../../geometry/SpatialReference.js";import{segmentIntersects as e}from"../../../../../geometry/support/intersects.js";import{deg2rad as s}from"../../../../../core/mathUtils.js";import{c as i}from"../../../../../chunks/vec3f64.js";import{n as o,k as r,g as n,c as h,p as a,f as l,d,a as p,b as g}from"../../../../../chunks/vec3.js";import{makeOrthonormal as c,tangentFrame as m}from"../../../support/mathUtils.js";import{getSphericalPCPF as _,getReferenceEllipsoid as u}from"../../../../../geometry/projectionEllipsoid.js";import{canProjectWithoutEngine as f,canProjectToWGS84ComparableLonLat as C,projectPointToVector as S,projectPointToWGS84ComparableLonLat as w,projectDirection as R,projectVectorToVector as j}from"../../../../../geometry/projection.js";import A from"../../../../../core/Quantity.js";import{a as L}from"../../../../../chunks/vec2f64.js";import{a as P}from"../../../../../chunks/vec4f64.js";import{earcut as U}from"../../../../../core/libs/earcut/earcut.js";import{s as W,i as G}from"../../../../../chunks/vec2.js";import{midpoint as v}from"../support/viewUtils.js";import I from"../support/measurementUtils.js";function z(t,e){const s=new Float64Array(t.length*e);for(let i=0;i<t.length;++i){const o=t[i];for(let t=0;t<e;++t)s[i*e+t]=o[t]}return s}export default class{constructor(){this.positionsWorldCoords=[],this.positionsRenderCoords=[],this.positionsProjectedWorldCoords=[],this.positionsFittedRenderCoords=[],this.positionsGeographic=[],this.positionsSpherical=[],this.positionsStereographic=[],this.pathSegmentLengths=[],this.geodesicPathSegmentLengths=[],this.perimeterSegmentLengths=[],this.intersectingSegments=new Set,this.geodesicIntersectingSegments=new Set,this.areaCentroidWorldCoords=i(),this.areaCentroidRenderCoords=i(),this.geodesicAreaCentroidRenderCoords=i(),this._length=0,this._centroidRenderCoords=i(),this._planeWorldCoords=P(),this._worldUp=i(),this._worldTangent=i(),this._frame=[i(),i(),i()],this._tempU=i(),this._tempV=i(),this._tempVec3=i(),this._tempSphere={center:i(),radius:0}}update(t,e,s,i,r,n,h){this._resize(t.length);const a=_(e.spatialReference),l=f(e.spatialReference,a)&&C(e.spatialReference),d=this.positionsGeographic,p=this.positionsWorldCoords,g=this.positionsRenderCoords,c=this.positionsSpherical;for(let e=0;e<t.length;++e){const s=t.vertex(e);S(s,p[e],n),S(s,g[e],r),l&&(w(s,d[e]),S(s,c[e],a),o(c[e],c[e]))}const m=this._updatePathLengths(i);if(this.pathLength=this._length>0?new A(s.normalizeDistance(m),"meters"):null,l){const t=this._updateGeodesicPathLengths(i,n);this.geodesicPathLength=this._length>0?new A(t,"meters"):null}else this.geodesicPathLength=null;if(!i)return this.area=null,this.geodesicArea=null,this.perimeterLength=null,this.triangleIndices=null,this.geodesicTriangleIndices=null,this.intersectingSegments.clear(),void this.geodesicIntersectingSegments.clear();this._updateArea(e,s,r,n,h),l&&this._updateGeodesicArea(e)}_resize(t){for(t<this._length&&(this.positionsWorldCoords.length=t,this.positionsRenderCoords.length=t,this.positionsProjectedWorldCoords.length=t,this.positionsFittedRenderCoords.length=t,this.positionsGeographic.length=t,this.positionsSpherical.length=t,this.positionsStereographic.length=t,this.pathSegmentLengths.length=t,this.geodesicPathSegmentLengths.length=t,this.perimeterSegmentLengths.length=t,this._length=t);this._length<t;)this.positionsWorldCoords.push(i()),this.positionsRenderCoords.push(i()),this.positionsProjectedWorldCoords.push(L()),this.positionsFittedRenderCoords.push(i()),this.positionsGeographic.push(i()),this.positionsSpherical.push(i()),this.positionsStereographic.push(L()),this.pathSegmentLengths.push(0),this.geodesicPathSegmentLengths.push(0),this.perimeterSegmentLengths.push(0),++this._length}_updatePathLengths(t){const e=this.positionsWorldCoords,s=this.pathSegmentLengths;let i=0;for(let o=0;o<this._length;++o){const n=s[o]=r(e[o],e[(o+1)%this._length]);(o<this._length-1||t)&&(i+=n)}return i}_updateGeodesicPathLengths(t,e){const s=this.positionsGeographic,i=this.geodesicPathSegmentLengths;let o=0;for(let r=0;r<this._length;++r){const n=i[r]=I.segmentLengthGeodesicVector(s[r],s[(r+1)%this._length],e);(r<this._length-1||t)&&(o+=n)}return o}_updateArea(t,e,s,i,o){const r=t.renderCoordsHelper,m=this.positionsWorldCoords,_=this.positionsRenderCoords,u=this.positionsProjectedWorldCoords,f=this.positionsFittedRenderCoords,C=this._planeWorldCoords,S=this._centroidRenderCoords;v(_,S),r.worldUpAtPosition(S,this._worldUp),r.worldBasisAtPosition(S,0,this._worldTangent),R(S,this._worldUp,s,this._worldUp,i),R(S,this._worldTangent,s,this._worldTangent,i),m.length>2&&I.bestFitPlane(m,C),this.fittingMode=this._selectFittingMode(C,m,this._worldUp,o);let w=0;if("horizontal"===this.fittingMode){let t=-1/0;_.forEach(((e,s)=>{const i=r.getAltitude(_[s]);i>t&&(t=i,w=s)}))}const L=m[w];let P=C,U=this._worldTangent;"horizontal"===this.fittingMode?P=this._worldUp:"vertical"===this.fittingMode&&(P=this._tempVec3,U=this._worldUp,c(C,this._worldUp,P)),n(this._frame[2],P),c(U,P,this._frame[0]),h(this._frame[1],this._frame[0],this._frame[2]),a(this._frame[1],this._frame[1]);const G=this._tempVec3,z=this._tempU,M=this._tempV;for(let t=0;t<this._length;++t){const e=u[t],o=f[t];l(G,m[t],L),W(e,d(this._frame[0],G),d(this._frame[1],G)),p(z,this._frame[0],e[0]),p(M,this._frame[1],e[1]),g(G,z,M),g(G,G,L),j(G,i,o,s)}this.perimeterLength=this._length>0?new A(e.normalizeDistance(this._updatePerimeterLengths()),"meters"):null,v(f,this.areaCentroidRenderCoords),j(this.areaCentroidRenderCoords,s,this.areaCentroidWorldCoords,i),this._updateIntersectingSegments(),this.area=0===this.intersectingSegments.size?new A(e.normalizeArea(this._computeArea()),"square-meters"):null}_updateGeodesicArea(t){const e=t.renderCoordsHelper,s=this.positionsSpherical,i=this.positionsStereographic,o=this._tempVec3,r=I.fitHemisphere(s,o);if(!r)return void(this.geodesicArea=null);const n=this._tempU,h=this._tempV;m(o,n,h);for(let t=0;t<this._length;++t){const e=d(s[t],n),r=d(s[t],h),a=d(s[t],o);W(i[t],e/a,r/a)}p(o,o,u(t.spatialReference).radius),e.toRenderCoords(o,_(t.spatialReference),this.geodesicAreaCentroidRenderCoords),this._updateGeodesicIntersectingSegments(),this.geodesicArea=r&&0===this.geodesicIntersectingSegments.size?new A(this._computeGeodesicArea(),"square-meters"):null}_updatePerimeterLengths(){const t=this.positionsProjectedWorldCoords,e=this.perimeterSegmentLengths;let s=0;for(let i=0;i<this._length;++i){s+=e[i]=G(t[i],t[(i+1)%this._length])}return s}_updateIntersectingSegments(){const t=this.positionsProjectedWorldCoords,s=this.intersectingSegments;s.clear();for(let i=0;i<this._length;++i)for(let o=i+2;o<this._length;++o){if((o+1)%this._length===i)continue;const r=t[i],n=t[(i+1)%this._length],h=t[o],a=t[(o+1)%this._length];e(r,n,h,a)&&(s.add(i),s.add(o))}}_computeArea(){const t=this.positionsProjectedWorldCoords,e=z(t,2),s=this.triangleIndices=new Uint32Array(U(e,[],2));let i=0;for(let e=0;e<s.length;e+=3)i+=I.triangleAreaEuclidean(t[s[e]],t[s[e+1]],t[s[e+2]]);return i}_updateGeodesicIntersectingSegments(){const t=this.positionsStereographic,s=this.geodesicIntersectingSegments;s.clear();for(let i=0;i<this._length;++i)for(let o=i+2;o<this._length;++o){if((o+1)%this._length===i)continue;const r=t[i],n=t[(i+1)%this._length],h=t[o],a=t[(o+1)%this._length];e(r,n,h,a)&&(s.add(i),s.add(o))}}_computeGeodesicArea(){const e=this.positionsGeographic,s=z(this.positionsStereographic,2),i=this.geodesicTriangleIndices=new Uint32Array(U(s,[],2));let o=0;for(let s=0;s<i.length;s+=3)o+=I.triangleAreaGeodesic(e[i[s]],e[i[s+1]],e[i[s+2]],t.WGS84);return o}_selectFittingMode(t,e,i,o){const r=e.map((e=>Math.abs(I.planePointDistance(t,e)))).reduce(((t,e)=>Math.max(t,e)),0);I.boundingSphere(e,this._tempSphere);const n=r/(2*this._tempSphere.radius),h=n<o.maxRelativeErrorCoplanar,a=n<o.maxRelativeErrorAlmostCoplanar;let l="horizontal";if(h)l="oblique";else if(a){l=Math.abs(d(i,t))>Math.cos(s(o.verticalAngleThreshold))?"horizontal":"vertical"}return l}}
