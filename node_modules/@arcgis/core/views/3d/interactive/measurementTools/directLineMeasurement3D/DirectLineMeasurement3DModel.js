/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../../chunks/tslib.es6.js";import"../../../../../core/has.js";import{isSome as t,isNone as s}from"../../../../../core/maybe.js";import"../../../../../core/Logger.js";import"../../../../../core/accessorSupport/ensureType.js";import{property as o}from"../../../../../core/accessorSupport/decorators/property.js";import{aliasOf as i}from"../../../../../core/accessorSupport/decorators/aliasOf.js";import{subclass as r}from"../../../../../core/accessorSupport/decorators/subclass.js";import"../../../../../core/urlUtils.js";import"../../../../../core/uuid.js";import"../../../../../portal/support/resourceExtension.js";import n from"../../../../../core/Accessor.js";import a from"../../../../../geometry/Point.js";import c from"../../../../../geometry/Polyline.js";import{onLocaleChange as d}from"../../../../../intl/locale.js";import{rad2deg as l,acosClamped as m,deg2rad as u}from"../../../../../core/mathUtils.js";import{fetchMessageBundle as h}from"../../../../../intl/messages.js";import"../../../../../intl.js";import{c as p}from"../../../../../chunks/vec3f64.js";import{k as f}from"../../../../../chunks/vec3.js";import g from"../../../../../core/Handles.js";import{init as P}from"../../../../../core/watchUtils.js";import{getSphericalPCPF as _,getReferenceEllipsoid as v,SphericalECEFSpatialReference as y,WGS84ECEFSpatialReference as j}from"../../../../../geometry/projectionEllipsoid.js";import{canProjectWithoutEngine as M,projectPointToWGS84ComparableLonLat as D,projectPointToVector as w}from"../../../../../geometry/projection.js";import b from"../../../../../core/Quantity.js";import{inverseGeodeticSolver as S,isSupported as L,geodesicLengths as z}from"../../../../../geometry/support/geodesicUtils.js";import{geodesicLength as O}from"../../../../../geometry/geometryEngine.js";import{PropertiesPool as k}from"../../../support/PropertiesPool.js";import x from"../support/UnitNormalizer.js";import{DirectLineMeasurement3D as A}from"../../graphics/DirectLineMeasurement3D.js";let E=class extends n{constructor(){super(...arguments),this._tempStartPosition=p(),this._tempEndPosition=p(),this._tempCornerPosition=p(),this._unitNormalizer=new x,this._handles=new g,this._propertiesPool=new k({startPoint:a,endPoint:a},this),this.model=new A,this.cursorPoint=null,this.state="initial",this.mode="auto",this.active=!1,this.geodesicMeasurementDistanceThreshold=1e5}initialize(){this._handles.add([this.model.watch("startPoint",(()=>this._updateMeasurement()),!0),this.model.watch("endPoint",(()=>this._updateMeasurement()),!0),this.model.watch("settings",(()=>this._updateMeasurement()),!0)],"model"),h("esri/core/t9n/Units").then((e=>{this.messages=e})),this._handles.add(d((async()=>{this.messages=await h("esri/core/t9n/Units")}))),this._handles.add(P(this.sceneView,"spatialReference",(e=>{const t=_(e),s=t===y?j:t;this._sphericalPCPF=s;const o=M(e,s);this._unitNormalizer.spatialReference=o?s:e})),"scene-view"),this.reset()}destroy(){this._handles.destroy(),this._handles=null,this._propertiesPool.destroy(),this._propertiesPool=null,this.model.destroy()}set startPointSurfaceLocation(e){this._set("startPointSurfaceLocation",e),this._updateMeasurement()}set endPointSurfaceLocation(e){this._set("endPointSurfaceLocation",e),this._updateMeasurement()}get measurementSurfaceLocation(){const e=this.startPointSurfaceLocation,t=this.endPointSurfaceLocation;return null==e||null==t||"above-the-surface"===e&&"below-the-surface"===t||"below-the-surface"===e&&"above-the-surface"===t||"on-the-surface"===e&&"on-the-surface"===t?"camera-dependent":"above-the-surface"===e||"above-the-surface"===t?"above-the-surface":"below-the-surface"}get validMeasurement(){return t(this.model.startPoint)&&t(this.model.endPoint)}get isMeasuring(){return!!this.startPoint}get geodesicDistanceExceeded(){return t(this.model.measurement)&&this.model.measurement.horizontalDistance&&this.model.measurement.horizontalDistance.value>this.geodesicMeasurementDistanceThreshold}get measurementMode(){let e=this.mode;return"auto"===e&&(e="euclidean","degrees"!==this.unit&&"degrees-minutes-seconds"!==this.unit||(e="geodesic"),this.geodesicDistanceExceeded&&(e="geodesic")),e}reset(){this.clearMeasurement()}clearMeasurement(){this.state="initial",this.startPoint=null,this.endPoint=null,this.cursorPoint=null,this._clearOverride("measurementSurfaceLocation"),this._updateMeasurement()}finishMeasurement(){if(!this._isOverridden("measurementSurfaceLocation")){const e=this.measurementSurfaceLocation,t="camera-dependent"===e?this.sceneView.state.camera.aboveGround?"above-the-surface":"below-the-surface":e;this._override("measurementSurfaceLocation",t)}this.state="measured"}_fallbackGeodesicAngle(e,t){return e/v(t).metersPerDegree}_fallbackGeodesicDistance(e,t,s){if(D(e,G)){D(t,U);const e=u(G[0]),s=u(G[1]),o=u(U[0]),i=u(U[1]),r=Math.abs(o-e),n=m(Math.sin(s)*Math.sin(i)+Math.cos(s)*Math.cos(i)*Math.cos(r)),a=l(n),c={distance:0};return S(c,[G[0],G[1]],[U[0],U[1]]),{distance:c.distance,angle:a}}{const t=e.spatialReference,o=s;return{distance:o,angle:this._fallbackGeodesicAngle(o,t)}}}_exactGeodesicDistanceAndAngle(e,t,s){const o=e.spatialReference,i=new c({paths:[e,t],spatialReference:o}),r=o.isGeographic&&L(o)?z([i],"meters")[0]:o.isWebMercator?O(i,"meters"):void 0,{distance:n,angle:a}=r?{distance:r,angle:this._fallbackGeodesicAngle(r,o)}:this._fallbackGeodesicDistance(e,t,s);return{distance:new b(n,"meters"),angle:new b(a,"degrees")}}_euclideanDistances(e,t){e.z>t.z&&(e=[e,e=t][0]);const s=e.clone();s.z=t.z;const o=this._tempStartPosition,i=this._tempEndPosition,r=this._tempCornerPosition,n=this.sceneView.spatialReference,a=this._sphericalPCPF,c=M(n,a)?a:n;w(e,o,c),w(t,i,c),w(s,r,c);const d=f(o,i),l=f(r,i),m=Math.abs(t.z-e.z),u=e=>this._unitNormalizer.normalizeDistance(e),h=u(d),p=u(l),g=u(m);return{direct:new b(h,"meters"),horizontal:new b(p,"meters"),vertical:new b(g,"meters")}}_updateMeasurement(){if(s(this.startPoint)||s(this.endPoint))return void(this.model.measurement=null);const e=this._euclideanDistances(this.startPoint,this.endPoint),t=this._exactGeodesicDistanceAndAngle(this.startPoint,this.endPoint,e.horizontal.value);this.model.measurement={directDistance:e.direct,horizontalDistance:e.horizontal,verticalDistance:e.vertical,geodesicDistance:t.distance,geodesicAngle:t.angle}}};e([o()],E.prototype,"messages",void 0),e([o({constructOnly:!0})],E.prototype,"sceneView",void 0),e([o()],E.prototype,"model",void 0),e([i("model.startPoint")],E.prototype,"startPoint",void 0),e([o({value:null})],E.prototype,"startPointSurfaceLocation",null),e([i("model.endPoint")],E.prototype,"endPoint",void 0),e([o({value:null})],E.prototype,"endPointSurfaceLocation",null),e([o({dependsOn:["startPointSurfaceLocation","endPointSurfaceLocation"]})],E.prototype,"measurementSurfaceLocation",null),e([o()],E.prototype,"cursorPoint",void 0),e([o()],E.prototype,"state",void 0),e([o()],E.prototype,"mode",void 0),e([i("model.settings.unit")],E.prototype,"unit",void 0),e([o()],E.prototype,"active",void 0),e([o({readOnly:!0,dependsOn:["model.startPoint","model.endPoint"]})],E.prototype,"validMeasurement",null),e([o({readOnly:!0,dependsOn:["startPoint"]})],E.prototype,"isMeasuring",null),e([o()],E.prototype,"geodesicMeasurementDistanceThreshold",void 0),e([o({readOnly:!0,dependsOn:["model.measurement","geodesicMeasurementDistanceThreshold"]})],E.prototype,"geodesicDistanceExceeded",null),e([o({readOnly:!0,dependsOn:["unit","geodesicDistanceExceeded"]})],E.prototype,"measurementMode",null),E=e([r("esri.views.3d.interactive.measurementTools.directLineMeasurement3D.DirectLineMeasurement3DModel")],E);const G=p(),U=p();var R=E;export default R;
