/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import e from"../../../../core/ObjectPool.js";import t from"../../../../core/PooledArray.js";import{f as r,c as n}from"../../../../chunks/vec3f64.js";import{a as i,b as s,g as o,e as h}from"../../../../chunks/vec3.js";import{ray as a,sphere as d,frustum as c}from"../../support/geometryUtils.js";import{rayBoxTest as l}from"./Util.js";class u{constructor(e,t,r=0){this.center=n(),this.initFrom(e,t,r,0)}init(e){return this.initFrom(e.node,e.center,e.halfSize,e.depth)}initFrom(e=null,t,r=this.halfSize,n=this.depth){return this.node=e||u.createEmptyNode(),t&&o(this.center,t),this.halfSize=r,this.depth=n,this}advance(e){let t=this.node.children[e];t||(t=u.createEmptyNode(),this.node.children[e]=t),this.node=t,this.halfSize/=2,this.depth++;const r=S[e];return this.center[0]+=r[0]*this.halfSize,this.center[1]+=r[1]*this.halfSize,this.center[2]+=r[2]*this.halfSize,this}advanceTo(e,t,r=!1){for(;;){if(this.isTerminalFor(e))return t&&t(this,-1),!0;if(this.isLeaf()&&!r)return t&&t(this,-1),!1;this.isLeaf()&&(this.node.residents=null);const n=this._childIndex(e);t&&t(this,n),this.advance(n)}}isLeaf(){return null!=this.node.residents}isTerminalFor(e){return e.radius>this.halfSize/2}_childIndex(e){const t=e.center,r=this.center;let n=0;for(let e=0;e<3;e++)r[e]<t[e]&&(n|=1<<e);return n}static createEmptyNode(){return{children:[null,null,null,null,null,null,null,null],terminals:new t({shrink:!0}),residents:new t({shrink:!0})}}static acquire(){return u._pool.acquire()}static release(e){u._pool.release(e)}static clearPool(){u._pool.prune()}}function f(e,t,r){e[0]=Math.min(e[0],t[0]-r),e[1]=Math.min(e[1],t[1]-r),e[2]=Math.min(e[2],t[2]-r)}function _(e,t,r){e[0]=Math.max(e[0],t[0]+r),e[1]=Math.max(e[1],t[1]+r),e[2]=Math.max(e[2],t[2]+r)}function m(e,t,r){return(r=r||e)[0]=e[0]+t,r[1]=e[1]+t,r[2]=e[2]+t,r}function p(e,t,r){return!c.intersectsSphere(r.planes,d.wrap(t,e))}function g(e,t){let r=1/0,n=null;for(let i=0;i<8;++i){const s=b(e,t,j[i]);s<r&&(r=s,n=j[i])}return n}function b(e,t,r){return t*(e[0]*r[0]+e[1]*r[1]+e[2]*r[2])}u._pool=new e(u);const S=[r(-1,-1,-1),r(1,-1,-1),r(-1,1,-1),r(1,1,-1),r(-1,-1,1),r(1,-1,1),r(-1,1,1),r(1,1,1)],j=[r(-1,-1,-1),r(-1,-1,1),r(-1,1,-1),r(-1,1,1),r(1,-1,-1),r(1,-1,1),r(1,1,-1),r(1,1,1)],x=Math.sqrt(3),O=[null];function N(e){return Array.isArray(e)?e:(O[0]=e,O)}const M=n(),E=n(),z=n(),R=n(),T=new t,D={center:n(),radius:0},A={center:n(),radius:0},v={center:n(),radius:0},w={center:n(),radius:0},y=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],F=new t,B=new t;export default class{constructor(e,t){this._objectToBoundingSphere=e,this._maximumObjectsPerNode=10,this._maximumDepth=20,this._degenerateObjects=new Set,this._objectCount=0,t&&(void 0!==t.maximumObjectsPerNode&&(this._maximumObjectsPerNode=t.maximumObjectsPerNode),void 0!==t.maximumDepth&&(this._maximumDepth=t.maximumDepth)),this._root=new u(null,r(0,0,0),0)}get center(){return this._root.center}get size(){return 2*this._root.halfSize}get root(){return this._root.node}get maximumObjectsPerNode(){return this._maximumObjectsPerNode}get maximumDepth(){return this._maximumDepth}get objectCount(){return this._objectCount}destroy(){this._degenerateObjects.clear(),this._root=null,u.clearPool(),O[0]=null,T.prune(),F.prune(),B.prune()}add(e,t){const r=N(e);t=null==t?r.length:t,this._objectCount+=t,this._grow(r,t);const n=u.acquire();for(let e=0;e<t;e++){const t=r[e];this._isDegenerate(t)?this._degenerateObjects.add(t):(n.init(this._root),this._add(t,n))}u.release(n)}remove(e,t){const r=N(e);this._objectCount-=r.length;const n=u.acquire();for(const e of r){const r=t||this._boundingSphereFromObject(e,D);this._isValidRadius(r.radius)?(n.init(this._root),this._remove(e,r,n)):this._degenerateObjects.delete(e)}u.release(n),this._shrink()}update(e,t){!this._isValidRadius(t.radius)&&this._isDegenerate(e)||(this.remove(e,t),this.add(e))}forEachAlongRay(e,t,r){const n=a.wrap(e,t);this._forEachNode(this._root,(e=>{if(!this._intersectsNode(n,e))return!1;const t=e.node;return t.terminals.forAll((e=>{this._intersectsObject(n,e)&&r(e)})),null!==t.residents&&t.residents.forAll((e=>{this._intersectsObject(n,e)&&r(e)})),!0}))}forEachAlongRayWithVerticalOffset(e,t,r,n){const i=a.wrap(e,t);this._forEachNode(this._root,(e=>{if(!this._intersectsNodeWithOffset(i,e,n))return!1;const t=e.node;return t.terminals.forAll((e=>{this._intersectsObjectWithOffset(i,e,n)&&r(e)})),null!==t.residents&&t.residents.forAll((e=>{this._intersectsObjectWithOffset(i,e,n)&&r(e)})),!0}))}forEach(e){this._forEachNode(this._root,(t=>{const r=t.node;return r.terminals.forAll(e),null!==r.residents&&r.residents.forAll(e),!0})),this._degenerateObjects.forEach(e)}forEachDegenerateObject(e){this._degenerateObjects.forEach(e)}findClosest(e,t,r,n,i){return this._findClosest(e,"front-to-back"===t?1:-1,r,n,i)}forEachInDepthRange(e,t,r,n,i,s,o,h){this._forEachInDepthRange(e,t,"front-to-back"===r?1:-1,n,i,s,o,h)}forEachNode(e){this._forEachNode(this._root,(t=>e(t.node,t.center,2*t.halfSize)))}_intersectsNode(e,t){return m(t.center,2*-t.halfSize,z),m(t.center,2*t.halfSize,R),l(e.origin,e.direction,z,R)}_intersectsNodeWithOffset(e,t,r){return m(t.center,2*-t.halfSize,z),m(t.center,2*t.halfSize,R),r.applyToMinMax(z,R),l(e.origin,e.direction,z,R)}_intersectsObject(e,t){const r=this._objectToBoundingSphere.getRadius(t);return!(r>0)||d.intersectsRay(d.wrap(r,this._objectToBoundingSphere.getCenter(t)),e)}_intersectsObjectWithOffset(e,t,r){const n=this._objectToBoundingSphere.getRadius(t);return!(n>0)||d.intersectsRay(r.applyToBoundingSphere(n,this._objectToBoundingSphere.getCenter(t)),e)}_forEachNode(e,t){let r=u.acquire().init(e);const n=[r];for(;0!==n.length;){if(r=n.pop(),t(r)&&!r.isLeaf())for(let e=0;e<r.node.children.length;e++){r.node.children[e]&&n.push(u.acquire().init(r).advance(e))}u.release(r)}}_forEachNodeDepthOrdered(e,t,r,n=1){let i=u.acquire().init(e);const s=[i];for(!function(e,t,r){if(!F.length)for(let e=0;e<8;++e)F.push({index:0,distance:0});for(let r=0;r<8;++r){const n=S[r];F.data[r].index=r,F.data[r].distance=b(e,t,n)}F.sort(((e,t)=>e.distance-t.distance)),r.clear();for(let e=0;e<8;++e)r.push(F.data[e].index)}(r,n,B);0!==s.length;){if(i=s.pop(),t(i)&&!i.isLeaf())for(let e=7;e>=0;--e){const t=B.data[e];if(t>=i.node.children.length)continue;i.node.children[t]&&s.push(u.acquire().init(i).advance(t))}u.release(i)}}_findClosest(e,t,r,n,o){let h=1/0,a=1/0,d=null;const c=g(e,t);let l=0;const u=i=>{if(++l,n&&!n(i))return;const s=this._objectToBoundingSphere.getCenter(i),o=this._objectToBoundingSphere.getRadius(i);if(r&&p(s,o,r))return;const c=b(e,t,s),u=c-o;u<h&&(h=u,a=c+o,d=i)};return this._forEachNodeDepthOrdered(this._root,(n=>{if(null!=o&&l>=o)return!1;if(r&&p(n.center,n.halfSize*x,r))return!1;i(E,c,n.halfSize),s(E,E,n.center);if(b(e,t,E)>a)return!1;const h=n.node;return h.terminals.forAll((e=>{u(e)})),null!==h.residents&&h.residents.forAll((e=>{u(e)})),!0}),e,t),d}_forEachInDepthRange(e,t,r,n,o,h,a,d){let c=-1/0,l=1/0;const u={setRange:e=>{1===r?(c=Math.max(c,e.near),l=Math.min(l,e.far)):(c=Math.max(c,-e.far),l=Math.min(l,-e.near))}};u.setRange(n);const f=b(t,r,e),_=g(t,r),m=g(t,-1*r);let S=0;const j=e=>{if(++S,a&&!a(e))return;const n=this._objectToBoundingSphere.getCenter(e),i=this._objectToBoundingSphere.getRadius(e),s=b(t,r,n)-f;s-i>l||s+i<c||h&&p(n,i,h)||o(e,u)};this._forEachNodeDepthOrdered(this._root,(e=>{if(null!=d&&S>=d)return!1;if(h&&p(e.center,e.halfSize*x,h))return!1;i(E,_,e.halfSize),s(E,E,e.center);if(b(t,r,E)-f>l)return!1;i(E,m,e.halfSize),s(E,E,e.center);if(b(t,r,E)-f<c)return!1;const n=e.node;return n.terminals.forAll((e=>{j(e)})),null!==n.residents&&n.residents.forAll((e=>{j(e)})),!0}),t,r)}_remove(e,t,r){T.clear();const n=r.advanceTo(t,((e,t)=>{T.push(e.node),T.push(t)}))?r.node.terminals:r.node.residents;if(n.removeUnordered(e),0===n.length)for(let e=T.length-2;e>=0;e-=2){const t=T.data[e],r=T.data[e+1];if(!this._purge(t,r))break}}_nodeIsEmpty(e){if(0!==e.terminals.length)return!1;if(null!==e.residents)return 0===e.residents.length;for(let t=0;t<e.children.length;t++)if(e.children[t])return!1;return!0}_purge(e,r){return r>=0&&(e.children[r]=null),!!this._nodeIsEmpty(e)&&(null===e.residents&&(e.residents=new t({shrink:!0})),!0)}_add(e,t){t.advanceTo(this._boundingSphereFromObject(e,D))?t.node.terminals.push(e):(t.node.residents.push(e),t.node.residents.length>this._maximumObjectsPerNode&&t.depth<this._maximumDepth&&this._split(t))}_split(e){const t=e.node.residents;e.node.residents=null;for(let r=0;r<t.length;r++){const n=u.acquire().init(e);this._add(t.data[r],n),u.release(n)}}_grow(e,t){if(0===t)return;const r=this._boundingSphereFromObjects(e,t,((e,t)=>this._boundingSphereFromObject(e,t)),A);if(this._isValidRadius(r.radius)&&!this._fitsInsideTree(r))if(this._nodeIsEmpty(this._root.node))o(this._root.center,r.center),this._root.halfSize=1.25*r.radius;else{const e=u.acquire();this._rootBoundsForRootAsSubNode(r,e),this._placingRootViolatesMaxDepth(e)?this._rebuildTree(r,e):this._growRootAsSubNode(e),u.release(e)}}_rebuildTree(e,t){o(v.center,t.center),v.radius=t.halfSize;const r=this._boundingSphereFromObjects([e,v],2,(e=>e),w),n=u.acquire().init(this._root);this._root.initFrom(null,r.center,1.25*r.radius),this._forEachNode(n,(e=>(this.add(e.node.terminals.data,e.node.terminals.length),null!==e.node.residents&&this.add(e.node.residents.data,e.node.residents.length),!0))),u.release(n)}_placingRootViolatesMaxDepth(e){let t=0;this._forEachNode(this._root,(e=>(t=Math.max(t,e.depth),!0)));return t+Math.log(e.halfSize/this._root.halfSize)*Math.LOG2E>this._maximumDepth}_rootBoundsForRootAsSubNode(e,t){const r=e.radius,n=e.center;let i=-1/0;const s=this._root.center,o=this._root.halfSize;for(let e=0;e<3;e++){const t=s[e]-o-(n[e]-r),h=n[e]+r-(s[e]+o),a=Math.max(0,Math.ceil(t/(2*o))),d=Math.max(0,Math.ceil(h/(2*o)))+1,c=Math.pow(2,Math.ceil(Math.log(a+d)*Math.LOG2E));i=Math.max(i,c),y[e].min=a,y[e].max=d}for(let e=0;e<3;e++){let t=y[e].min,r=y[e].max;const n=(i-(t+r))/2;t+=Math.ceil(n),r+=Math.floor(n);const h=s[e]-o-t*o*2;M[e]=h+(r+t)*o}return t.initFrom(null,M,i*o,0)}_growRootAsSubNode(e){const t=this._root.node;o(A.center,this._root.center),A.radius=this._root.halfSize,this._root.init(e),e.advanceTo(A,null,!0),e.node.children=t.children,e.node.residents=t.residents,e.node.terminals=t.terminals}_shrink(){for(;;){const e=this._findShrinkIndex();if(-1===e)break;this._root.advance(e),this._root.depth=0}}_findShrinkIndex(){if(0!==this._root.node.terminals.length||this._root.isLeaf())return-1;let e=null;const t=this._root.node.children;let r=0,n=0;for(;n<t.length&&null==e;)r=n++,e=t[r];for(;n<t.length;)if(t[n++])return-1;return r}_isDegenerate(e){const t=this._objectToBoundingSphere.getRadius(e);return!this._isValidRadius(t)}_isValidRadius(e){return!isNaN(e)&&e!==-1/0&&e!==1/0&&e>0}_fitsInsideTree(e){const t=this._root.center,r=this._root.halfSize,n=e.center;return e.radius<=r&&n[0]>=t[0]-r&&n[0]<=t[0]+r&&n[1]>=t[1]-r&&n[1]<=t[1]+r&&n[2]>=t[2]-r&&n[2]<=t[2]+r}_boundingSphereFromObject(e,t){return o(t.center,this._objectToBoundingSphere.getCenter(e)),t.radius=this._objectToBoundingSphere.getRadius(e),t}_boundingSphereFromObjects(e,t,r,n){if(1===t){const t=r(e[0],A);o(n.center,t.center),n.radius=t.radius}else{z[0]=1/0,z[1]=1/0,z[2]=1/0,R[0]=-1/0,R[1]=-1/0,R[2]=-1/0;for(let n=0;n<t;n++){const t=r(e[n],A);this._isValidRadius(t.radius)&&(f(z,t.center,t.radius),_(R,t.center,t.radius))}h(n.center,z,R,.5),n.radius=Math.max(R[0]-z[0],R[1]-z[1],R[2]-z[2])/2}return n}}
