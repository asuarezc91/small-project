/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{c as t}from"../../../../chunks/vec3f64.js";import{f as e,c as n,n as r,a,b as o,d as s,s as l,g as i,i as c}from"../../../../chunks/vec3.js";import{f as y,c as A,a as f}from"../../../../chunks/vec3f32.js";import{plane as h,ray as O}from"../../support/geometryUtils.js";import{Vec3Compact as w}from"./BufferVectorMath.js";import{VertexAttrConstants as u,assert as d}from"./Util.js";import{GeometryData as I}from"./GeometryData.js";const g=w;var m,M,N,P;!function(t){const e=.5,n=[[-e,-e,e],[e,-e,e],[e,e,e],[-e,e,e],[-e,-e,-e],[e,-e,-e],[e,e,-e],[-e,e,-e]],r=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],a=[0,0,1,0,1,1,0,1],o=[0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5],s=new Array(36);for(let t=0;t<6;t++)for(let e=0;e<6;e++)s[6*t+e]=t;const l=new Array(36);for(let t=0;t<6;t++)l[6*t+0]=0,l[6*t+1]=1,l[6*t+2]=2,l[6*t+3]=2,l[6*t+4]=3,l[6*t+5]=0;t.createGeometry=function(t){Array.isArray(t)||(t=[t,t,t]);const e=new Float32Array(24);for(let r=0;r<8;r++)e[3*r]=n[r][0]*t[0],e[3*r+1]=n[r][1]*t[1],e[3*r+2]=n[r][2]*t[2];const i={};i[u.POSITION]=new Uint32Array(o),i[u.NORMAL]=new Uint32Array(s),i[u.UV0]=new Uint32Array(l);const c={};return c[u.POSITION]={size:3,data:e},c[u.NORMAL]={size:3,data:new Float32Array(r)},c[u.UV0]={size:2,data:new Float32Array(a)},new I(c,i)}}(m||(m={})),function(t){const e=.5,n=[[-e,0,-e],[e,0,-e],[e,0,e],[-e,0,e],[0,-e,0],[0,e,0]],r=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],a=[5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0],o=[0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7];t.createGeometry=function(t){Array.isArray(t)||(t=[t,t,t]);const e=new Float32Array(18);for(let r=0;r<6;r++)e[3*r]=n[r][0]*t[0],e[3*r+1]=n[r][1]*t[1],e[3*r+2]=n[r][2]*t[2];const s={};s[u.POSITION]=new Uint32Array(a),s[u.NORMAL]=new Uint32Array(o);const l={};return l[u.POSITION]={size:3,data:e},l[u.NORMAL]={size:3,data:new Float32Array(r)},new I(l,s)}}(M||(M={})),function(t){const a=.5,o=y(-a,0,-a),s=y(a,0,-a),l=y(0,0,a),i=y(0,.5,0),c=A(),f=A(),h=A(),O=A(),w=A();e(c,o,i),e(f,o,s),n(h,c,f),r(h,h),e(c,s,i),e(f,s,l),n(O,c,f),r(O,O),e(c,l,i),e(f,l,o),n(w,c,f),r(w,w);const d=[o,s,l,i],g=[0,-1,0,h[0],h[1],h[2],O[0],O[1],O[2],w[0],w[1],w[2]],m=[0,1,2,3,1,0,3,2,1,3,0,2],M=[0,0,0,1,1,1,2,2,2,3,3,3];t.createGeometry=function(t){Array.isArray(t)||(t=[t,t,t]);const e=new Float32Array(12);for(let n=0;n<4;n++)e[3*n]=d[n][0]*t[0],e[3*n+1]=d[n][1]*t[1],e[3*n+2]=d[n][2]*t[2];const n={};n[u.POSITION]=new Uint32Array(m),n[u.NORMAL]=new Uint32Array(M);const r={};return r[u.POSITION]={size:3,data:e},r[u.NORMAL]={size:3,data:new Float32Array(g)},new I(r,n)}}(N||(N={})),function(w){w.createBoxGeometry=m.createGeometry,w.createDiamondGeometry=M.createGeometry,w.createTetrahedronGeometry=N.createGeometry,w.createSphereGeometry=function(t,e,n,r){const{phiStart:a=-Math.PI,phiLength:o=2*Math.PI,thetaStart:s=-Math.PI/2,thetaLength:l=Math.PI}=r||{},{position:i=u.POSITION,normal:c=u.NORMAL,uv:y=u.UV0}=(null==r?void 0:r.attributes)||{},A=Math.max(3,Math.floor(e)),f=Math.max(2,Math.floor(n)),h=(A+1)*(f+1),O=new Float32Array(3*h),w=new Float32Array(3*h),d=new Float32Array(2*h),g=[];let m=0;for(let e=0;e<=f;e++){const n=[],r=e/f,i=s+r*l,c=Math.cos(i);for(let e=0;e<=A;e++){const s=e/A,l=a+s*o,y=Math.cos(l)*c,f=Math.sin(i),h=-Math.sin(l)*c;O[3*m]=y*t,O[3*m+1]=f*t,O[3*m+2]=h*t,w[3*m]=y,w[3*m+1]=f,w[3*m+2]=h,d[2*m]=s,d[2*m+1]=r,n.push(m),++m}g.push(n)}const M=new Uint32Array(2*A*(f-1)*3);m=0;for(let t=0;t<f;t++)for(let e=0;e<A;e++){const n=g[t][e],r=g[t][e+1],a=g[t+1][e+1],o=g[t+1][e];0===t?(M[m++]=n,M[m++]=a,M[m++]=o):t===f-1?(M[m++]=n,M[m++]=r,M[m++]=a):(M[m++]=n,M[m++]=r,M[m++]=a,M[m++]=a,M[m++]=o,M[m++]=n)}const N={};N[i]=M,N[c]=M;const P={};return P[i]={size:3,data:O},P[c]={size:3,data:w},y&&(P[y]={size:2,data:d},N[y]=M),new I(P,N)},w.createPolySphereGeometry=function(t,e,n){const r=t;let a,o;if(n)a=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],o=new Uint32Array([0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1]);else{const t=r*(1+Math.sqrt(5))/2;a=[-r,t,0,r,t,0,-r,-t,0,r,-t,0,0,-r,t,0,r,t,0,-r,-t,0,r,-t,t,0,-r,t,0,r,-t,0,-r,-t,0,r],o=new Uint32Array([0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1])}for(let e=0;e<a.length;e+=3)g.scale(a,e,t/g.length(a,e));let s={};function l(e,n){e>n&&([e,n]=[n,e]);const r=e.toString()+"."+n.toString();if(s[r])return s[r];let o=a.length;return a.length+=3,g.add(a,3*e,a,3*n,a,o),g.scale(a,o,t/g.length(a,o)),o/=3,s[r]=o,o}for(let t=0;t<e;t++){const t=o.length,e=new Uint32Array(4*t);for(let n=0;n<t;n+=3){const t=o[n],r=o[n+1],a=o[n+2],s=l(t,r),i=l(r,a),c=l(a,t),y=4*n;e[y]=t,e[y+1]=s,e[y+2]=c,e[y+3]=r,e[y+4]=i,e[y+5]=s,e[y+6]=a,e[y+7]=c,e[y+8]=i,e[y+9]=s,e[y+10]=i,e[y+11]=c}o=e,s={}}const i=new Float32Array(a);for(let t=0;t<i.length;t+=3)g.normalize(i,t);const c={};c[u.POSITION]=o,c[u.NORMAL]=o;const y={};return y[u.POSITION]={size:3,data:new Float32Array(a)},y[u.NORMAL]={size:3,data:i},new I(y,c)},w.createPointGeometry=function(t,e,n,r,a,o,s,l){const i=e?new Float64Array([e[0],e[1],e[2]]):new Float32Array([0,0,0]),c=t?new Float32Array([t[0],t[1],t[2]]):new Float32Array([0,0,1]),y=o?new Float32Array(o):new Float32Array([0,0]),A=n?new Uint8Array([255*n[0],255*n[1],255*n[2],n.length>3?255*n[3]:255]):new Uint8Array([255,255,255,255]),f=null!=r&&2===r.length?new Float32Array(r):new Float32Array([1,1]),h={};if(h[u.POSITION]={size:3,data:i},h[u.NORMAL]={size:3,data:c},h[u.UV0]={size:y.length,data:y},h[u.COLOR]={size:4,data:A},h[u.SIZE]={size:2,data:f},null!=a){const t=new Float32Array([a[0],a[1],a[2],a[3]]);h[u.AUXPOS1]={size:4,data:t}}if(null!=s){const t=new Float32Array([s[0],s[1],s[2],s[3]]);h[u.AUXPOS2]={size:4,data:t}}return null!=l?(l.initialize(h,I.DefaultIndices,"point"),l):new I(h,I.DefaultIndices,"point")},w.updatePointGeometry=function(t,e,n,r,a,o,s,l){const i=l.vertexAttributes;if(null!=t){const{data:e}=i[u.NORMAL];e[0]=t[0],e[1]=t[1],e[2]=t[2]}if(null!=e){const{data:t}=i[u.POSITION];t[0]=e[0],t[1]=e[1],t[2]=e[2]}if(null!=n){const{data:t}=i[u.COLOR];t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3]}if(null!=r){const{data:t}=i[u.SIZE];t[0]=r[0],t[1]=r[1]}if(null!=a){const{data:t}=i[u.AUXPOS1];t[0]=a[0],t[1]=a[1],t[2]=a[2],t[3]=a[3]}if(null!=o){const{data:t}=i[u.UV0];t[0]=o[0],t[1]=o[1]}if(null!=s){const{data:t}=i[u.AUXPOS2];t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3]}return l},w.createPointArrayGeometry=function(t,e){const n=new Float32Array(3*t.length),r=new Float32Array(e?3*t.length:3),a=new Uint32Array(t.length),o=new Uint32Array(t.length);for(let s=0;s<t.length;s++)n[3*s]=t[s][0],n[3*s+1]=t[s][1],n[3*s+2]=t[s][2],e&&(r[3*s]=e[s][0],r[3*s+1]=e[s][1],r[3*s+2]=e[s][2]),a[s]=s,o[s]=0;e||(r[0]=0,r[1]=1,r[2]=0);const s=new Float32Array(2);s[0]=0,s[1]=0;const l={};l[u.POSITION]=a,l[u.NORMAL]=e?a:o,l[u.UV0]=o;const i={};return i[u.POSITION]={size:3,data:n},i[u.NORMAL]={size:3,data:r},i[u.UV0]={size:2,data:s},new I(i,l,"point")},w.createTriangleGeometry=function(){const t=new Float32Array([0,0,0,0,0,100,100,0,0]),e=new Uint32Array([0,1,2]),n=new Float32Array([0,1,0]),r=new Uint32Array([0,0,0]),a=new Float32Array([0,0]),o=new Uint32Array([0,0,0]),s={};s[u.POSITION]=e,s[u.NORMAL]=r,s[u.UV0]=o;const l={};return l[u.POSITION]={size:3,data:t},l[u.NORMAL]={size:3,data:n},l[u.UV0]={size:2,data:a},new I(l,s)};const P=[[-1,-1,0],[1,-1,0],[1,1,0],[-1,1,0]];function F(t,e,a,o,l){return!(Math.abs(s(e,t))>l)&&(n(a,t,e),r(a,a),n(o,a,t),r(o,o),!0)}function S(t,e,n,r,a,o,s){return F(t,e,a,o,s)||F(t,n,a,o,s)||F(t,r,a,o,s)}w.createSquareGeometry=function(t=P){const e=new Float64Array(12);for(let n=0;n<4;n++)for(let r=0;r<3;r++)e[3*n+r]=t[n][r];const n=new Uint32Array([0,1,2,2,3,0]),r=new Float32Array([0,0,1]),a=new Uint32Array([0,0,0,0,0,0]),o=new Float32Array([0,0,1,0,1,1,0,1]),s=new Uint8Array([255,255,255,255]),l={[u.POSITION]:n,[u.NORMAL]:a,[u.UV0]:n,[u.COLOR]:a},i={[u.POSITION]:{size:3,data:e},[u.NORMAL]:{size:3,data:r},[u.UV0]:{size:2,data:o},[u.COLOR]:{size:4,data:s}};return new I(i,l)},w.createConeGeometry=function(t,e,n,r,a=!0,o=!0){let s=0;const l=e,i=t;let c=y(0,s,0),A=y(0,s+i,0),f=y(0,-1,0),h=y(0,1,0);r&&(s=i,A=y(0,0,0),c=y(0,s,0),f=y(0,1,0),h=y(0,-1,0));const O=[A,c],w=[f,h],d=n+2,g=Math.sqrt(i*i+l*l);if(r)for(let t=n-1;t>=0;t--){const e=t*(2*Math.PI/n),r=y(Math.cos(e)*l,s,Math.sin(e)*l);O.push(r);const a=y(i*Math.cos(e)/g,-l/g,i*Math.sin(e)/g);w.push(a)}else for(let t=0;t<n;t++){const e=t*(2*Math.PI/n),r=y(Math.cos(e)*l,s,Math.sin(e)*l);O.push(r);const a=y(i*Math.cos(e)/g,l/g,i*Math.sin(e)/g);w.push(a)}const m=new Uint32Array(2*(n+2)*3),M=new Uint32Array(2*(n+2)*3);let N=0,P=0;if(a){for(let t=3;t<O.length;t++)m[N++]=1,m[N++]=t-1,m[N++]=t,M[P++]=0,M[P++]=0,M[P++]=0;m[N++]=O.length-1,m[N++]=2,m[N++]=1,M[P++]=0,M[P++]=0,M[P++]=0}if(o){for(let t=3;t<O.length;t++)m[N++]=t,m[N++]=t-1,m[N++]=0,M[P++]=t,M[P++]=t-1,M[P++]=1;m[N++]=0,m[N++]=2,m[N++]=O.length-1,M[P++]=1,M[P++]=2,M[P++]=w.length-1}const U=new Float32Array(3*d);for(let t=0;t<d;t++)U[3*t]=O[t][0],U[3*t+1]=O[t][1],U[3*t+2]=O[t][2];const z=new Float32Array(3*d);for(let t=0;t<d;t++)z[3*t]=w[t][0],z[3*t+1]=w[t][1],z[3*t+2]=w[t][2];const F={};F[u.POSITION]=m,F[u.NORMAL]=M;const S={};return S[u.POSITION]={size:3,data:U},S[u.NORMAL]={size:3,data:z},new I(S,F)},w.createCylinderGeometry=function(t,e,i,c,h,O){const w=c?f(c):y(1,0,0),d=h?f(h):y(0,0,0),g=void 0===O||O,m=A();r(m,w);const M=A();a(M,m,Math.abs(t));const N=A();a(N,M,-.5),o(N,N,d);const P=y(0,1,0);Math.abs(1-s(m,P))<.2&&l(P,0,0,1);const U=A();n(U,m,P),r(U,U),n(P,U,m);const z=2*i+(g?2:0),F=i+(g?2:0),S=new Float32Array(3*z),p=new Float32Array(3*F),T=new Float32Array(2*z),L=new Uint32Array(3*i*(g?4:2)),R=new Uint32Array(3*i*(g?4:2));g&&(S[3*(z-2)+0]=N[0],S[3*(z-2)+1]=N[1],S[3*(z-2)+2]=N[2],T[2*(z-2)]=0,T[2*(z-2)+1]=0,S[3*(z-1)+0]=S[3*(z-2)+0]+M[0],S[3*(z-1)+1]=S[3*(z-2)+1]+M[1],S[3*(z-1)+2]=S[3*(z-2)+2]+M[2],T[2*(z-1)]=1,T[2*(z-1)+1]=1,p[3*(F-2)+0]=-m[0],p[3*(F-2)+1]=-m[1],p[3*(F-2)+2]=-m[2],p[3*(F-1)+0]=m[0],p[3*(F-1)+1]=m[1],p[3*(F-1)+2]=m[2]);const G=function(t,e,n){L[t]=e,R[t]=n};let V=0;const v=A(),x=A();for(let t=0;t<i;t++){const n=t*(2*Math.PI/i);a(v,P,Math.sin(n)),a(x,U,Math.cos(n)),o(v,v,x),p[3*t+0]=v[0],p[3*t+1]=v[1],p[3*t+2]=v[2],a(v,v,e),o(v,v,N),S[3*t+0]=v[0],S[3*t+1]=v[1],S[3*t+2]=v[2],T[2*t+0]=t/i,T[2*t+1]=0,S[3*(t+i)+0]=S[3*t+0]+M[0],S[3*(t+i)+1]=S[3*t+1]+M[1],S[3*(t+i)+2]=S[3*t+2]+M[2],T[2*(t+i)+0]=t/i,T[2*t+1]=1;const r=(t+1)%i;G(V++,t,t),G(V++,t+i,t),G(V++,r,r),G(V++,r,r),G(V++,t+i,t),G(V++,r+i,r)}if(g){for(let t=0;t<i;t++){const e=(t+1)%i;G(V++,z-2,F-2),G(V++,t,F-2),G(V++,e,F-2)}for(let t=0;t<i;t++){const e=(t+1)%i;G(V++,t+i,F-1),G(V++,z-1,F-1),G(V++,e+i,F-1)}}const b={};b[u.POSITION]=L,b[u.NORMAL]=R,b[u.UV0]=L;const j={};return j[u.POSITION]={size:3,data:S},j[u.NORMAL]={size:3,data:p},j[u.UV0]={size:2,data:T},new I(j,b)},w.createTubeGeometry=function(t,e,n,r,a){n=n||10,r=null==r||r,d(t.length>1);const o=[],s=[];for(let t=0;t<n;t++){o.push([0,-t-1,-(t+1)%n-1]);const r=t/n*2*Math.PI;s.push([Math.cos(r)*e,Math.sin(r)*e])}return w.createPathExtrusionGeometry(s,t,[[0,0,0]],o,r,a)},w.createPathExtrusionGeometry=function(c,f,w,d,g,m=y(0,0,0)){const M=c.length,N=new Float32Array(f.length*M*3+(6*w.length||0)),P=new Float32Array(f.length*M+(2*w.length||0)),z=new Float32Array(f.length*M*3+(w?6:0)),F=(f.length-1)*M*6+3*d.length*2,p=new Uint32Array(F),T=new Uint32Array(F);let L=0,R=0,G=0,V=0,v=0;const x=A(),b=A(),j=A(),k=A(),C=A(),D=A(),E=A(),B=t(),X=A(),q=A(),Z=A(),H=A(),J=A(),K=h.create();l(X,0,1,0),e(b,f[1],f[0]),r(b,b),g?(o(B,f[0],m),r(j,B)):l(j,0,0,1),S(b,j,X,X,C,j,U),i(k,j),i(H,C);for(let t=0;t<w.length;t++)a(D,C,w[t][0]),a(B,j,w[t][2]),o(D,D,B),o(D,D,f[0]),N[L++]=D[0],N[L++]=D[1],N[L++]=D[2],P[G++]=0;z[R++]=-b[0],z[R++]=-b[1],z[R++]=-b[2];for(let t=0;t<d.length;t++)p[V++]=d[t][0]>0?d[t][0]:-d[t][0]-1+w.length,p[V++]=d[t][1]>0?d[t][1]:-d[t][1]-1+w.length,p[V++]=d[t][2]>0?d[t][2]:-d[t][2]-1+w.length,T[v++]=0,T[v++]=0,T[v++]=0;let Q=w.length;const W=w.length-1;for(let t=0;t<f.length;t++){let l=!1;if(t>0){i(x,b),t<f.length-1?(e(b,f[t+1],f[t]),r(b,b)):l=!0,o(q,x,b),r(q,q),o(Z,f[t-1],k),h.fromPositionAndNormal(f[t],q,K);h.intersectRay(K,O.wrap(Z,x),B)?(e(B,B,f[t]),r(j,B),n(C,q,j),r(C,C)):S(q,k,H,X,C,j,U),i(k,j),i(H,C)}g&&(o(B,f[t],m),r(J,B));for(let e=0;e<M;e++)if(a(D,C,c[e][0]),a(B,j,c[e][1]),o(D,D,B),r(E,D),z[R++]=E[0],z[R++]=E[1],z[R++]=E[2],P[G++]=g?s(D,J):D[2],o(D,D,f[t]),N[L++]=D[0],N[L++]=D[1],N[L++]=D[2],!l){const t=(e+1)%M;p[V++]=Q+e,p[V++]=Q+M+e,p[V++]=Q+t,p[V++]=Q+t,p[V++]=Q+M+e,p[V++]=Q+M+t;for(let t=0;t<6;t++)T[v++]=p[V-6+t]-W}Q+=M}const Y=f[f.length-1];for(let t=0;t<w.length;t++)a(D,C,w[t][0]),a(B,j,w[t][1]),o(D,D,B),o(D,D,Y),N[L++]=D[0],N[L++]=D[1],N[L++]=D[2],P[G++]=0;const $=R/3;z[R++]=b[0],z[R++]=b[1],z[R++]=b[2];const _=Q-M;for(let t=0;t<d.length;t++)p[V++]=d[t][0]>=0?Q+d[t][0]:-d[t][0]-1+_,p[V++]=d[t][2]>=0?Q+d[t][2]:-d[t][2]-1+_,p[V++]=d[t][1]>=0?Q+d[t][1]:-d[t][1]-1+_,T[v++]=$,T[v++]=$,T[v++]=$;const tt={};tt[u.POSITION]=p,tt[u.NORMAL]=T;const et={};return et[u.POSITION]={size:3,data:N},et.zOffset={size:1,data:P},et[u.NORMAL]={size:3,data:z},new I(et,tt)},w.createPolylineGeometry=function(t,e){d(t.length>1,"createPolylineGeometry(): polyline needs at least 2 points"),d(3===t[0].length,"createPolylineGeometry(): malformed vertex"),d(void 0===e||e.length===t.length,"createPolylineGeometry: need same number of points and normals"),d(void 0===e||3===e[0].length,"createPolylineGeometry(): malformed normal");const n=new Float64Array(3*t.length),r=new Uint32Array(2*(t.length-1));let a=0,o=0;for(let e=0;e<t.length;e++){for(let r=0;r<3;r++)n[a++]=t[e][r];e>0&&(r[o++]=e-1,r[o++]=e)}const s={},l={};if(s[u.POSITION]=r,l[u.POSITION]={size:3,data:n},e){const n=new Float32Array(3*e.length);let a=0;for(let r=0;r<t.length;r++)for(let t=0;t<3;t++)n[a++]=e[r][t];s[u.NORMAL]=r,l[u.NORMAL]={size:3,data:n}}return new I(l,s,"line")},w.createExtrudedTriangle=function(t,e,n,r){const a=new Float32Array(18),o=[[-e,0,r/2],[n,0,r/2],[0,t,r/2],[-e,0,-r/2],[n,0,-r/2],[0,t,-r/2]];for(let t=0;t<6;t++)a[3*t]=o[t][0],a[3*t+1]=o[t][1],a[3*t+2]=o[t][2];const s={[u.POSITION]:new Uint32Array([0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5])},l={[u.POSITION]:{size:3,data:a}};return new I(l,s)},w.transformInPlace=function(t,e){const n=t.vertexAttributes[u.POSITION].data;for(let t=0;t<n.length;t+=3){const r=n[t],a=n[t+1],o=n[t+2];l(z,r,a,o),c(z,z,e),n[t]=z[0],n[t+1]=z[1],n[t+2]=z[2]}},w.cgToGIS=function(t,e=t){const n=t.getVertexAttr(),r=n.position.data,a=n.normal.data,o=e.getVertexAttr(),s=o.position.data,l=o.normal.data;if(a)for(let t=0;t<a.length;t+=3){const e=a[t+1];l[t+1]=-a[t+2],l[t+2]=e}if(r)for(let t=0;t<r.length;t+=3){const e=r[t+1];s[t+1]=-r[t+2],s[t+2]=e}return e},w.makeOrthoBasisDirUp=F,w.makeOrthoBasisDirUpFallback=S}(P||(P={}));const U=.99619469809,z=A();var F=P;export default F;
