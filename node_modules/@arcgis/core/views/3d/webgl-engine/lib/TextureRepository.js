/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{isSome as e,isNone as t}from"../../../../core/maybe.js";import r from"../../../../core/Logger.js";import{isThenable as s,isAbortError as a}from"../../../../core/promiseUtils.js";import i from"../../../../core/Evented.js";import{Task as n,ImmediateTask as u}from"../../../support/Scheduler.js";import{assert as o}from"./Util.js";import h from"../../../webgl/Texture.js";import{TextureTechniqueConfiguration as l,TextureTechnique as c}from"./TextureTechnique.js";const T=r.getLogger("esri.views.3d.webgl-engine.lib.TextureRepository");class f{constructor(t,r,s,a){this._textures=r,this.rctx=a,this._idToRefCountedTexture=new Map,this._textureTechniqueConfig=new l,this._loadingCount=0,this._frameUpdates=new Map,this._fallbackTextureData=new Uint8Array(256),this._fallbackTextureTransparentData=new Uint8Array(256),this.events=new i,this._textureTechnique=s.acquireAndReleaseExisting(c,this._textureTechniqueConfig,this._textureTechnique);for(let e=0;e<this._fallbackTextureData.length;++e)this._fallbackTextureData[e]=255,this._fallbackTextureTransparentData[e]=(e+1)%4!=0?255:0;this._fallbackTextureDesc={target:3553,pixelFormat:6408,dataType:5121,samplingMode:9728,width:8,height:8,maxAnisotropy:this.rctx.parameters.maxMaxAnisotropy},this._frameTask=e(t)?t.registerTask(n.TEXTURE_UNLOAD,(()=>{}),(()=>!1)):u}dispose(){this._frameTask.remove(),e(this._fallbackTexture)&&(this._fallbackTexture.dispose(),this._fallbackTexture=null),e(this._fallbackTextureTransparent)&&(this._fallbackTextureTransparent.dispose(),this._fallbackTextureTransparent=null),this._textures.forEach((e=>e.unload()))}acquire(e,t=!1,r){const s=this._getOrCreateRef(e,t,r);return s.ref(),s}update(){let e=!1;this._frameUpdates.forEach((t=>{const r=t.texture.frameUpdate(this.rctx,this._textureTechnique,t.previousToken);r>=0&&r!==t.previousToken&&(t.previousToken=r,e=!0)})),e&&this.events.emit("changed",0)}_getOrCreateRef(e,t,r){const s=this._idToRefCountedTexture.get(e);return s||this._createNewRef(e,t,r)}_createNewRef(e,t,r){const i=this._textures.get(e);o(void 0!==i);const n=i.events.on("unloaded",(()=>{n.remove(),this._onTextureUnloaded(e)})),u=new x;this._idToRefCountedTexture.set(e,u);const h=i.load(this.rctx,this._textureTechnique);this._loadingCount++;const l=t=>(this._loadingCount--,this._updateGLTexture(u,t),r&&r(u),i.requiresFrameUpdates&&this._frameUpdates.set(e,{texture:i,previousToken:-1}),u),c=e=>{this._loadingCount--,a(e)||T.error(e)};return s(h)?(this._updateGLTexture(u,t?this.fallbackTextureTransparent:this.fallbackTexture),h.then(l,c)):l(h),u}_updateGLTexture(e,t){e.glTexture=t,this.events.emit("changed",1)}release(e){const t=this._idToRefCountedTexture.get(e);if(t&&(t.unref(),t.isUnreferenced)){const r=this._textures.get(e);this._frameTask.schedule((()=>{t.isUnreferenced&&r.unload()}))}}getTexture(e){return this._textures.get(e)}get loadingCount(){return this._loadingCount}_onTextureUnloaded(e){this._idToRefCountedTexture.delete(e),this._frameUpdates.delete(e)}get fallbackTexture(){return t(this._fallbackTexture)&&(this._fallbackTexture=new h(this.rctx,this._fallbackTextureDesc,this._fallbackTextureData)),this._fallbackTexture}get fallbackTextureTransparent(){return t(this._fallbackTextureTransparent)&&(this._fallbackTextureTransparent=new h(this.rctx,this._fallbackTextureDesc,this._fallbackTextureTransparentData)),this._fallbackTextureTransparent}}class x{constructor(){this._refCount=0,this.glTexture=null}get isUnreferenced(){return 0===this._refCount}ref(){++this._refCount}unref(){0!==this._refCount?--this._refCount:T.error("Cannot dereference texture that has no references!")}}export{x as RefCountedTexture,f as TextureRepository};
