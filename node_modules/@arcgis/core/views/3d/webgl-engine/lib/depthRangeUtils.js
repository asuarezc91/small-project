/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import t from"../../../../core/PooledArray.js";import{c as e}from"../../../../chunks/vec3f64.js";import{i as r}from"../../../../chunks/vec3.js";import{maxScale as i}from"../../support/mathUtils.js";import{m as n,c as s}from"../../../../chunks/mat4.js";import{a}from"../../../../chunks/mat4f64.js";import{a as o}from"../../../../chunks/vec4f64.js";import{l as h}from"../../../../chunks/vec4.js";import{frustum as f,sphere as c}from"../../support/geometryUtils.js";import{unpackFloatRGBA as l,assert as u}from"./Util.js";import{empty as g,union as d,set as m}from"./depthRange.js";function p(t,e,r){return l(e,t)*(r[1]-r[0])+r[0]}function w(t,e,r){if(e.size<1e4)return I.compute(t,e);const i=g();return r.forEach((e=>{e.isVisible&&d(i,b(t,e))})),i}function b(t,e){if(!e.isVisible)return;const r=g(),i=e.getObjects();return e.getSpatialQueryAccelerator()?function(t,e,r){const i=e.eye,n=e.viewForward,s=e.frustum,a=t=>t.isVisible,o=r.objectCount;if(o<500)m(A,e.near,Math.min(t.near,e.far)),r.forEachInDepthRange(i,n,"front-to-back",A,((r,i)=>{v(t,e,r),A.far=t.near,i.setRange(A)}),s,a),m(A,Math.max(t.far,e.near),e.far),r.forEachInDepthRange(i,n,"back-to-front",A,((r,i)=>{v(t,e,r),A.near=t.far,i.setRange(A)}),s,a);else{const i=Math.max(Math.min(o,500),Math.ceil(.1*o)),h=r.findClosest(n,"front-to-back",s,a,i),f=r.findClosest(n,"back-to-front",s,a,i);h&&f&&(B(t,e,h.getCenter(),h.getBSRadius()),B(t,e,f.getCenter(),f.getBSRadius()))}}(r,t,e.getSpatialQueryAccelerator()):function(t,e,r){if(k.clear(),r.forEach((t=>{t.isVisible&&k.add(t)})),k.empty)return;k.sort(e),m(A,e.near,Math.min(t.near,e.far)),k.forEachInDepthRange(A,"front-to-back",((r,i)=>{i<t.near&&v(t,e,r)})),m(A,Math.max(t.far,e.near),e.far),k.forEachInDepthRange(A,"back-to-front",((e,r,i)=>{t.far=Math.max(t.far,i)}))}(r,t,i),r}function v(t,e,r){if(!r.isVisible)return;if(!f.intersectsSphere(e.frustum.planes,c.wrap(r.getBSRadius(),r.getCenter())))return;const s=r.objectTransformation,a=S;r.geometryRecords.forEach((r=>{n(a,s,r.getShaderTransformation());const o=i(a);R(t,e,r.geometry.boundingInfo,a,o)}))}function R(t,e,i,n,s){const a=e.eye,o=e.viewForward;r(M,i.center,n);const h=o[0]*(M[0]-a[0])+o[1]*(M[1]-a[1])+o[2]*(M[2]-a[2]),l=i.bsRadius*s;if(!(h-l>t.near&&h+l<t.far)&&f.intersectsSphere(e.frustum.planes,c.wrap(l,M)))if(i.bsRadius>100&&i.getChildren()){const r=i.getChildren();for(let i=0;i<8;++i)r[i]&&R(t,e,r[i],n,s)}else P.unionDepthRangeWithAABB(t,e.viewProjectionMatrix,n,i.bbMin,i.bbMax)}function B(t,e,r,i){const n=e.eye,s=e.viewForward,a=(r[0]-n[0])*s[0]+(r[1]-n[1])*s[1]+(r[2]-n[2])*s[2];t.near=Math.min(t.near,a-i),t.far=Math.max(t.far,a+i)}class j{constructor(){this.view=a(),this.viewProj=a(),this.frustum=f.create(),this.geometries=[],this.near=[],this.far=[],this.nearCandidates=[],this.farCandidates=[],this.range={near:0,far:0},this.looseRange={near:0,far:0}}compute(t,e){this.reset(),s(this.view,t.viewMatrix),n(this.viewProj,t.projectionMatrix,this.view),f.copy(t.frustum,this.frustum);const r=this.view,i=r[2],a=r[6],o=r[10],h=r[14],c=this.range;let l=0;if(e.forEach((t=>{if(!t.instanceParameters.visible)return;if(!t.castShadow)return;let e,r;t.hasShaderTransformation?(e=t.getBoundingSphere(t.getShaderTransformation(),1,M),r=M):(e=t.bsRadius,r=t.center);const n=i*r[0]+a*r[1]+o*r[2]+h,s=n-e,f=n+e;this.geometries[l]=t,this.near[l]=-f,this.far[l]=-s,++l})),0===this.geometries.length)return c;for(let t=0;t<this.geometries.length;++t)this.near[t]>c.far&&(c.far=this.near[t]),this.near[t]>2&&this.far[t]<c.near&&(c.near=this.far[t]);const u=this.looseRange;u.near=Math.max(.5*c.near,2),u.far=2*c.far;let g=0,d=0;for(let t=0;t<this.geometries.length;++t)this.near[t]<c.near&&(this.near[t]>=u.near?c.near=this.near[t]:this.nearCandidates[g++]=t),this.far[t]>c.far&&(this.far[t]<=u.far?c.far=this.far[t]:this.farCandidates[d++]=t);if(0===this.nearCandidates.length&&0===this.farCandidates.length)return c;this.nearCandidates.sort(((t,e)=>this.near[t]<this.near[e]?-1:this.near[t]>this.near[e]?1:0)),this.farCandidates.sort(((t,e)=>this.far[t]<this.far[e]?1:this.far[t]>this.far[e]?-1:0));for(let t=0;t<this.nearCandidates.length;++t){const e=this.nearCandidates[t];if(this.near[e]<c.near){const t=this.geometries[e],r=t.boundingInfo;this.includeNearBoundingInfoRec(r,t.getShaderTransformation())}}for(let t=0;t<this.farCandidates.length;++t){const e=this.farCandidates[t];if(this.far[e]>c.far){const t=this.geometries[e],r=t.boundingInfo;this.includeFarBoundingInfoRec(r,t.getShaderTransformation())}}return c}reset(){this.geometries.length=0,this.near.length=0,this.far.length=0,this.nearCandidates.length=0,this.farCandidates.length=0,this.range.near=Number.MAX_VALUE,this.range.far=-Number.MAX_VALUE}includeNearBoundingInfoRec(t,e){let n=t.getBSRadius();const s=t.getCenter();r(M,s,e);const a=i(e),o=M[0],h=M[1],f=M[2];n*=a;const{planes:c}=this.frustum;if(c[0][0]*o+c[0][1]*h+c[0][2]*f+c[0][3]>n)return;if(c[1][0]*o+c[1][1]*h+c[1][2]*f+c[1][3]>n)return;if(c[2][0]*o+c[2][1]*h+c[2][2]*f+c[2][3]>n)return;if(c[3][0]*o+c[3][1]*h+c[3][2]*f+c[3][3]>n)return;const l=this.view[2]*o+this.view[6]*h+this.view[10]*f+this.view[14],u=l+n;if(!(-(l-n)<2||-u>=this.range.near))if(-u>this.looseRange.near)this.range.near=-u;else{if(n>100){const r=t.getChildren();if(void 0!==r){for(let t=0;t<8;++t)void 0!==r[t]&&this.includeNearBoundingInfoRec(r[t],e);return}}P.unionDepthRangeWithAABB(this.range,this.viewProj,e,t.getBBMin(),t.getBBMax())}}includeFarBoundingInfoRec(t,e){let n=t.getBSRadius();const s=t.getCenter();r(M,s,e);const a=i(e),o=M[0],h=M[1],f=M[2];n*=a;const{planes:c}=this.frustum;if(c[0][0]*o+c[0][1]*h+c[0][2]*f+c[0][3]>n)return;if(c[1][0]*o+c[1][1]*h+c[1][2]*f+c[1][3]>n)return;if(c[2][0]*o+c[2][1]*h+c[2][2]*f+c[2][3]>n)return;if(c[3][0]*o+c[3][1]*h+c[3][2]*f+c[3][3]>n)return;const l=this.view[2]*o+this.view[6]*h+this.view[10]*f+this.view[14]-n;if(!(-l<=this.range.far))if(-l<this.looseRange.far)this.range.far=-l;else{if(n>100){const r=t.getChildren();if(void 0!==r){for(let t=0;t<8;++t)void 0!==r[t]&&this.includeFarBoundingInfoRec(r[t],e);return}}P.unionDepthRangeWithAABB(this.range,this.viewProj,e,t.getBBMin(),t.getBBMax())}}}const C=[[0,1,3],[2,3,1],[1,5,2],[6,2,5],[5,4,6],[7,6,4],[4,0,7],[3,7,0],[3,2,7],[6,7,2],[4,5,0],[1,0,5]],M=e(),S=a(),A=g(),k=new class{constructor(){this._items=new t({allocator:t=>t||{obj:null,distance:0,near:0,far:0},deallocator:t=>(t.obj=null,t.distance=0,t.near=0,t.far=0,t)})}get length(){return this._items.length}get empty(){return 0===this._items.length}clear(){this._items.clear()}add(t){this._items.pushNew().obj=t}sort(t){const e=t.eye,r=t.viewForward;this._items.forAll((t=>{const i=t.obj,n=i.getCenter(),s=i.getBSRadius(),a=(n[0]-e[0])*r[0]+(n[1]-e[1])*r[1]+(n[2]-e[2])*r[2];t.distance=a,t.near=a-s,t.far=a+s})),this._items.sort(((t,e)=>t.distance-e.distance))}forEachInDepthRange(t,e,r){if("front-to-back"===e)for(let e=0;e<this._items.length;++e){const i=this._items.data[e];i.far<t.near||i.near>t.far||r(i.obj,i.near,i.far)}else for(let e=this._items.length-1;e>=0;--e){const i=this._items.data[e];i.far<t.near||i.near>t.far||r(i.obj,i.near,i.far)}}},I=new j,P=new class{constructor(){this.modelViewProj=a(),this.clipPosition=[o(),o(),o(),o(),o(),o(),o(),o()]}unionDepthRangeWithAABB(t,e,r,i,s){const a=this.modelViewProj;n(a,e,r);let o=!1;for(let t=0;t<8;++t){const e=this.clipPosition[t],r=0===t||3===t||4===t||7===t?i[0]:s[0],n=0===t||1===t||4===t||5===t?i[1]:s[1],o=t<4?i[2]:s[2];e[0]=a[0]*r+a[4]*n+a[8]*o+a[12],e[1]=a[1]*r+a[5]*n+a[9]*o+a[13],e[2]=a[2]*r+a[6]*n+a[10]*o+a[14],e[3]=a[3]*r+a[7]*n+a[11]*o+a[15]}for(let e=0;e<12;++e){const r=this.clipPosition[C[e][0]],i=this.clipPosition[C[e][1]],n=this.clipPosition[C[e][2]],s=this.clipTriangle(r,i,n);let a=!0;for(let t=0;t<s.length;++t){if(s[t][3]>=2){a=!1;break}}if(!a){o=!0;for(let e=0;e<s.length;++e){const r=s[e][3];r<t.near&&(t.near=r),r>t.far&&(t.far=r)}}}return o}inside(t,e){return 0===e?t[0]>=-t[3]:1===e?t[1]>=-t[3]:2===e?t[0]<=t[3]:3===e?t[1]<=t[3]:void u(!1)}intersect(t,e,r){let i=0;return 0===r?i=(-t[3]-t[0])/(e[0]-t[0]+e[3]-t[3]):1===r?i=(-t[3]-t[1])/(e[1]-t[1]+e[3]-t[3]):2===r?i=(t[3]-t[0])/(e[0]-t[0]-e[3]+t[3]):3===r&&(i=(t[3]-t[1])/(e[1]-t[1]-e[3]+t[3])),h(o(),t,e,i)}clipTriangle(t,e,r){let i=[t,e,r];for(let t=0;t<4;++t){const e=i;i=[];for(let r=0;r<e.length;++r){const n=e[r],s=e[(r+1)%e.length];this.inside(s,t)?(this.inside(n,t)||i.push(this.intersect(n,s,t)),i.push(s)):this.inside(n,t)&&i.push(this.intersect(n,s,t))}}return i}};export{j as DepthRangeFromRenderGeometries,b as depthRangeFromLayer,w as depthRangeFromScene,p as texure2depth};
