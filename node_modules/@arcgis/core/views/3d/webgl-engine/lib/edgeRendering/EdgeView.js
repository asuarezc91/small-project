/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import"../../../../../core/has.js";import{isUint16Array as e}from"../../../../../core/typedArrayUtil.js";import{disposeMaybe as t,destroyMaybe as r,isNone as s,isSome as o}from"../../../../../core/maybe.js";import{equals as a}from"../../../../../core/arrayUtils.js";import{createAbortController as i,create as n,all as c}from"../../../../../core/promiseUtils.js";import{clamp as d}from"../../../../../core/mathUtils.js";import{c as l}from"../../../../../chunks/vec3f64.js";import{s as m,g as h,k as g}from"../../../../../chunks/vec3.js";import{c as f}from"../../../../../chunks/mat4.js";import{a as u}from"../../../../../chunks/mat3f64.js";import{a as p}from"../../../../../chunks/mat4f64.js";import{f as b,t as y,d as j}from"../../../../../chunks/mat3.js";import w from"../../../../webgl/BufferObject.js";import x from"../../../../webgl/VertexArrayObject.js";import v from"../Object3D.js";import E from"../GridLocalOriginFactory.js";import{VertexPosition as O}from"../../core/shaderLibrary/attributes/VertexPosition.glsl.js";import{c as R}from"../../../../../chunks/vec33.js";import{TwoVectorPosition as M}from"../../core/util/TwoVectorPosition.js";import{BufferManager as C}from"../TextureBackedBuffer/BufferManager.js";import{applyToModelMatrix as T}from"../localOriginHelper.js";import{LocalOriginManager as k}from"../LocalOriginManager.js";import{VertexLayout as D,EdgeShaderAttributeLocations as B,glVertexLayout as I,EdgeInputBufferLayout as L}from"./bufferLayouts.js";import{RegularEdgeBufferWriter as V,SilhouetteEdgeBufferWriter as A}from"./edgeBufferWriters.js";import{EdgeRenderer as P,LINE_WIDTH_FRACTION_FACTOR as U,EXTENSION_LENGTH_OFFSET as F}from"./EdgeRenderer.js";import S from"./EdgeWorkerHandle.js";import{generateStrokesTexture as G}from"./strokes.js";import{determineRendererType as K,estimateLengthAtDistance as q,determineEdgeTransparency as N,determineObjectTransparency as z,fillComponenBufferIndices as W,computeEdgeCount as _}from"./util.js";class H{constructor(e,t,r,s){this.rctx=e,this.techniqueRepository=t,this.callbacks=r,this.profilingCallback=null,this.perObjectData=new Map,this.renderers=new Map,this.localOrigins=new k(new E),this.numberOfRenderedEdges=0,this.gpuMemoryUsage=0,this.workerAbort=i(),this.destroyed=!1,this.tmpModelPosition=l(),this.tmpCameraPosition=l(),this.componentColorManager=new C(this.rctx,2),this.worker=new S(s);const o=D.createBuffer(4);for(let e=0;e<4;e++)o.sideness.set(e,0,0===e||3===e?0:1),o.sideness.set(e,1,0===e||1===e?0:1);this.verticesBufferObject=w.createVertex(this.rctx,35044,o.buffer)}destroy(){this.destroyed||(this.perObjectData.forEach(((e,t)=>{this.perObjectData.delete(t),e.renderables.forEach((e=>{this.removeRenderable(e)}))})),this.strokesTexture=t(this.strokesTexture),this.componentColorManager=r(this.componentColorManager),this.workerAbort.abort(),this.worker.destroy(),this.verticesBufferObject=t(this.verticesBufferObject),this.perObjectData.clear(),this.renderers.clear(),this.destroyed=!0)}getUsedMemory(){return this.gpuMemoryUsage}get numberOfRenderedPrimitives(){return this.numberOfRenderedEdges}shouldRender(){return this.renderers.size>0}async addComponentObject(e,t,r,s,o,a,i,c){if(this.hasObject(e))return;let d;const l=new Y(n((e=>d=e)),r);this.perObjectData.set(e,l),await this.addComponentGeometry(t,l,s,o,a,i,c),this.callbacks.setNeedsRender(),d()}async addOrUpdateObject3D(e,t,r,s){const o=new Array;let i;const d=new Y(n((e=>i=e))),l=this.perObjectData.get(e);if(this.perObjectData.set(e,d),r.mergeGeometries&&e.geometries.length>1&&function(e){let t=null,r=null;for(let s=0;s<e.geometries.length;s++){const o=e.geometryRecords[s];if(o.material.supportsEdges){if(t){if(!a(t,o.transformation))return!1}else t=o.transformation;if(!r&&o.origin)r=o;else if(r&&o.origin&&r.origin.id!==o.origin.id)return!1}}return!0}(e))o.push(this.addObjectMergedGeometries(e,d,t,r,s));else for(let a=0;a<e.geometries.length;a++){const i=e.geometries[a],n=e.geometryRecords[a];n.material.supportsEdges&&o.push(this.addGeometryData(e,d,i.data,n,t[0],r,s))}await c(o),l&&l.waitLoaded((()=>{l.renderables.forEach((e=>this.removeRenderable(e))),this.callbacks.setNeedsRender()})),this.callbacks.setNeedsRender(),i()}hasObject(e){return this.perObjectData.has(e)}async updateAllComponentOpacities(e,t){const r=t instanceof Array?e=>t[e]:()=>t;(await this.getObjectEntry(e)).renderables.forEach((e=>{const t=e.components.meta.length;for(let s=0;s<t;s++){const t=r(s),o=e.components.meta[s],a=o.index;o.material.opacity=t,e.components.buffer.textureBuffer.setDataElement(a,1,3,255*t)}this.updateTransparency(e)})),this.callbacks.setNeedsRender()}async updateAllComponentMaterials(e,t,r,s){const o=e instanceof v,a=!!r.slicePlaneEnabled,i=K(t),n=P.getKey(i,a,o);(await this.getObjectEntry(e)).renderables.forEach((e=>{if(n!==e.rendererKey){const t=this.renderers.get(e.rendererKey),r=this.acquireRenderer(i,a,o);t.removeRenderable(e),t.refCount.decrement(),e.rendererKey=n,r.addRenderable(e)}for(let r=0;r<t.length;r++)e.components.meta[r].material=t[r];s&&this.updateComponentBuffer(e.components),this.updateTransparency(e)})),this.callbacks.setNeedsRender()}async updateObjectVisibility(e,t){(await this.getObjectEntry(e)).renderables.forEach((e=>e.visible=t)),this.callbacks.setNeedsRender()}removeObject(e){const t=this.perObjectData.get(e);t&&(this.perObjectData.delete(e),t.waitLoaded((()=>{t.renderables.forEach((e=>this.removeRenderable(e))),this.callbacks.setNeedsRender()})))}async getObjectEntry(e){const t=this.perObjectData.get(e);if(!t)throw"no object";return await t.loaded,t}removeAll(){this.perObjectData.forEach(((e,t)=>this.removeObject(t)))}render(e,t){if(s(this.componentColorManager))return;this.localOrigins.updateViewMatrices(e.camera.viewMatrix);const r=e.camera.viewInverseTransposeMatrix,o=l(),a=new M,i=new O.ViewProjectionTransform,n=u();m(o,r[3],r[7],r[11]),a.set(o),h(i.worldFromView_TH,a.high),h(i.worldFromView_TL,a.low),b(i.viewFromCameraRelative_RS,e.camera.viewMatrix),f(i.projFromView,e.camera.projectionMatrix);const c=u();y(c,i.viewFromCameraRelative_RS),j(n,c),this.renderers.forEach((e=>{0===e.refCount.value&&(this.renderers.delete(e.key),e.dispose())})),this.componentColorManager.garbageCollect(),this.componentColorManager.updateTextures();let d=0,g=0;if(this.renderers.forEach((e=>e.forEachRenderable((e=>{d+=e.statistics.averageEdgeLength,g++}),t))),0===g)return;const p={distanceFalloffFactor:40*d/g,minimumEdgeLength:q(e.camera.fullViewport[3],e.camera.fovY,1,3.5*e.camera.pixelRatio),transparency:t,viewProjectionTransform:i,transformNormal_ViewFromGlobal:n};this.updateObjectCameraDistances(e),this.numberOfRenderedEdges=0,this.renderers.forEach((t=>{this.renderRegularEdges(t,e,p),this.renderSilhouetteEdges(t,e,p)}))}updateTransparency(e){const t=N(e.components.meta),r=z(e.components.meta);t===e.edgeTransparency&&r===e.objectTransparency||(e.edgeTransparency=t,e.objectTransparency=r,this.renderers.get(e.rendererKey).setRenderablesDirty())}computeModelTransformWithLocalOrigin(e,t,r){if(e.getCombinedStaticTransformation(t,r),t.origin)this.localOrigins.register(t.origin);else{const e=m(this.tmpModelPosition,r[12],r[13],r[14]);t.origin=this.localOrigins.acquire(e)}return T(t.origin.vec3,r),r}updateComponentBuffer(e){const{meta:t,buffer:r}=e;for(let e=0;e<t.length;e++){const s=t[e].material,o=t[e].index,a=d(Math.round(s.size*U),0,255),i=d(s.extensionLength,-F,255-F)+F,n="solid"===s.type?0:1,c=255*s.opacity,l=s.color,m=255*l[0],h=255*l[1],g=255*l[2],f=255*l[3];r.textureBuffer.setData(o,0,m,h,g,f),r.textureBuffer.setData(o,1,a,i,n,c)}}createComponentBuffers(e){if(s(this.componentColorManager))return null;const t=new Array,r=this.componentColorManager.getBuffer(e.length);for(let s=0;s<e.length;s++){const o=e[s],a=r.acquireIndex();t.push({index:a,material:o})}const o={meta:t,buffer:r};return this.updateComponentBuffer(o),o}extractEdges(e,t,r,s,o){return this.worker.process({data:t,originalIndices:o,writerSettings:e,skipDeduplicate:r},this.workerAbort.signal,s)}createEdgeResources(e){const t={};if(s(this.verticesBufferObject))return t;if(e.regular.lodInfo.lengths.length>0){const r=new x(this.rctx,B,{vertices:I,instances:V.glLayout},{vertices:this.verticesBufferObject,instances:w.createVertex(this.rctx,35044,e.regular.instancesData.buffer)});t.regular={vao:r,lod:e.regular.lodInfo}}if(e.silhouette.lodInfo.lengths.length>0){const r=new x(this.rctx,B,{vertices:I,instances:A.glLayout},{vertices:this.verticesBufferObject,instances:w.createVertex(this.rctx,35044,e.silhouette.instancesData.buffer)});t.silhouette={vao:r,lod:e.silhouette.lodInfo}}return t}async addGeometryData(e,t,r,s,o,a,i){const n=r.getAttribute("position"),c=this.computeModelTransformWithLocalOrigin(e,s,p()),d=s.origin,l={position:n,indices:r.getIndices("position"),modelTransform:c,origin:d};return this.addPositionData(t,l,o,a,i)}async addPositionData(e,t,r,o,a=!1){const i=this.createComponentBuffers([r]);if(s(i))return;const n=this.acquireRenderer(r.type,!!o.slicePlaneEnabled),{modelTransform:c,origin:d,indices:l}=t,m=t.position,h=m.data.length/m.strideIdx,g=L.createBuffer(h);for(let e=0;e<h;e++)g.position.set(e,0,m.data[m.offsetIdx+e*m.strideIdx+0]),g.position.set(e,1,m.data[m.offsetIdx+e*m.strideIdx+1]),g.position.set(e,2,m.data[m.offsetIdx+e*m.strideIdx+2]);W(i.meta,[0,g.componentIndex.count],g.componentIndex);const f=await this.extractEdges(n.writerSettings,g,!1,a,l),{regular:u,silhouette:p}=this.createEdgeResources(f),b=(u?u.vao.size:0)+(p?p.vao.size:0),y={regular:u,silhouette:p,transform:{modelMatrix:c,origin:d},statistics:{gpuMemoryUsage:b,averageEdgeLength:f.averageEdgeLength},components:i,visible:!0,edgeTransparency:N(i.meta),objectTransparency:z(i.meta),distanceToCamera:0,rendererKey:n.key};e.renderables.push(y),n.addRenderable(y),this.gpuMemoryUsage+=b}async addComponentGeometry(e,t,r,o,a,i,n){const c=this.createComponentBuffers(i);if(s(c))return;const d=K(i),l=this.acquireRenderer(d,n.slicePlaneEnabled||!1,!1),m=L.createBuffer(r.count);R(m.position,r),W(c.meta,a,m.componentIndex,o);const h=l.writerSettings,g=await this.extractEdges(h,m,!0,!1,o),{regular:f,silhouette:u}=this.createEdgeResources(g),p=(f?f.vao.size:0)+(u?u.vao.size:0),b={regular:f,silhouette:u,transform:e,statistics:{gpuMemoryUsage:p,averageEdgeLength:g.averageEdgeLength},components:c,visible:!0,edgeTransparency:N(c.meta),objectTransparency:z(c.meta),distanceToCamera:0,rendererKey:l.key};t.renderables.push(b),l.addRenderable(b),this.gpuMemoryUsage+=p}async addObjectMergedGeometries(t,r,s,o,a){const i=new Map;let n=0,c=null,d=null;for(let r=0;r<t.geometries.length;r++){const s=t.geometries[r],o=t.geometryRecords[r];if(!o.material.supportsEdges)continue;!d&&o.origin&&(d=o);const a=s.data.getIndices("position");n+=a?a.length:0,(a&&null==c||c===Uint16Array)&&(c=e(a)?Uint16Array:Uint32Array)}const l=n?new c(n):null,m=[];let h=0;for(let e=0;e<t.geometries.length;e++){const r=t.geometries[e];if(!t.geometryRecords[e].material.supportsEdges)continue;const s=r.data.getAttribute("position"),o=r.data.getIndices("position");let a=i.get(s.data);if(null==a){a=m.length/3;for(let e=s.offsetIdx;e<s.data.length;e+=s.strideIdx)m.push(s.data[e+0]),m.push(s.data[e+1]),m.push(s.data[e+2]);i.set(s.data,a)}if(o)for(let e=0;e<o.length;e++)l[h++]=a+o[e]}const g=d||t.geometryRecords[0],f=this.computeModelTransformWithLocalOrigin(t,g,p()),u=g.origin;for(let e=0;e<t.geometryRecords.length;e++)t.geometryRecords[e].origin=u;const b={position:{data:m,offsetIdx:0,strideIdx:3},indices:l,modelTransform:f,origin:u};await this.addPositionData(r,b,s[0],o,a)}acquireRenderer(e,t,r=!0){const o=P.getKey(e,t,r);let a=this.renderers.get(o);return s(this.strokesTexture)&&(this.strokesTexture=G(this.rctx)),a||(a=new P(this.rctx,this.techniqueRepository,{type:e,slicePlaneEnabled:t,strokesTexture:this.strokesTexture,legacy:r}),this.renderers.set(o,a)),a.refCount.increment(),a}removeRenderable(e){const t=this.renderers.get(e.rendererKey);if(t){t.removeRenderable(e),t.refCount.decrement(),function(e){e.regular&&(e.regular.vao.vertexBuffers.instances.dispose(),e.regular.vao.dispose(!1),e.regular.vao=null);e.silhouette&&(e.silhouette.vao.vertexBuffers.instances.dispose(),e.silhouette.vao.dispose(!1),e.silhouette.vao=null)}(e),"origin"in e.transform&&this.localOrigins.release(e.transform.origin),this.gpuMemoryUsage-=e.statistics.gpuMemoryUsage;for(const t of e.components.meta)e.components.buffer.releaseIndex(t.index)}}updateObjectCameraDistances(e){const t=e.camera.viewInverseTransposeMatrix;m(this.tmpCameraPosition,t[3],t[7],t[11]),this.perObjectData.forEach(((e,t)=>{const r=o(e.center)?e.center:t.getCenter(),s=g(r,this.tmpCameraPosition);e.renderables.forEach((e=>e.distanceToCamera=s))}))}renderRegularEdges(e,t,r){e.bindRegularEdges(t,r);const s=r.transparency;e.forEachRenderable((s=>{if(!s.visible||!s.regular)return;const o=_(s.regular.lod.lengths,s.distanceToCamera,r);"origin"in s.transform&&(t.localViewMatrixForEdges=this.localOrigins.getViewMatrix(s.transform.origin)),e.renderRegularEdges(s,t,o),this.numberOfRenderedEdges+=o}),s)}renderSilhouetteEdges(e,t,r){e.bindSilhouetteEdges(t,r);const s=r.transparency;e.forEachRenderable((s=>{if(!s.visible||!s.silhouette)return;const o=_(s.silhouette.lod.lengths,s.distanceToCamera,r);"origin"in s.transform&&(t.localViewMatrixForEdges=this.localOrigins.getViewMatrix(s.transform.origin)),e.renderSilhouetteEdges(s,t,o),this.numberOfRenderedEdges+=o}),s)}}class Y{constructor(e,t=null){this.center=t,this.renderables=new Array,this.loaded=e,this.loaded.then((()=>this.loaded=!0))}waitLoaded(e){!0===this.loaded?e():this.loaded.then((()=>e()))}}export{H as EdgeView};
