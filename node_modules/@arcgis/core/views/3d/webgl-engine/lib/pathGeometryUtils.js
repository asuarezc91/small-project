/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{sign as t,acosClamped as e,reciprocalClamped as i}from"../../../../core/mathUtils.js";import{c as s}from"../../../../chunks/vec3f64.js";import{d as r,g as o,b as h,n as a,a as n,f as l,c as u,p,s as f,l as c,i as d}from"../../../../chunks/vec3.js";import{t as x,i as m,r as v}from"../../../../chunks/mat4.js";import{a as g}from"../../../../chunks/mat4f64.js";import{a as V,b as A,f as b}from"../../../../chunks/vec2f64.js";import{s as C,g as D,o as I,d as R,a as P,h as N,e as S,l as U}from"../../../../chunks/vec2.js";import{plane as T,ray as y}from"../../support/geometryUtils.js";import{VertexAttrConstants as _}from"./Util.js";import{GeometryData as L}from"./GeometryData.js";import F from"./GeometryUtil.js";import{intersectTriangles as O}from"../materials/internal/MaterialUtil.js";import{s as k}from"../../../../chunks/mat2.js";import{c as E}from"../../../../chunks/mat2f64.js";import{PathVertexAttrConstants as M}from"../materials/PathTechnique.js";var B;!function(B){function Y(){return{up:s(),right:s()}}B.makeFrame=Y,B.profileSpaceToVertexSpace=function(t,e,i){t[0]=i[0]*e.right[0]+i[1]*e.up[0],t[1]=i[0]*e.right[1]+i[1]*e.up[1],t[2]=i[0]*e.right[2]+i[1]*e.up[2]},B.vertexSpaceToProfileSpace=function(t,e,i){C(t,r(i,e.right),r(i,e.up))};B.PathVertex=class{constructor(){this.pos=s(),this.posES=s(),this.posGS=s(),this.vRight=s(),this.vLeft=s(),this.frame=Y(),this.rotationFrame=Y(),this.rotationRight=V(),this.rotationAngle=0,this.miterStretch=E()}setFrameFromUpVector(t){o(this.frame.up,t),h(q,this.vLeft,this.vRight),a(q,q),n(J,this.frame.up,r(q,this.frame.up)),l(K,q,J),a(K,K),u(this.frame.right,K,this.frame.up)}computeRotationAxisAndAngleFromUpVector(){o(this.rotationFrame.up,this.frame.up),o(this.rotationFrame.right,this.frame.right),C(this.rotationRight,1,0),n(J,this.frame.up,r(this.frame.up,this.vLeft)),l(J,this.vLeft,J),p(J,J),a(J,J),n(q,this.frame.up,r(this.frame.up,this.vRight)),l(q,this.vRight,q),a(q,q),u(H,this.rotationFrame.up,this.vLeft);const s=t(r(H,this.vRight));if(this.rotationAngle=s*(Math.PI-e(r(J,q))),Math.abs(this.rotationAngle)>0){const t=i(Math.cos(.5*this.rotationAngle));k(this.miterStretch,t-1+1,0,0,1)}const h=Math.PI-this.rotationAngle;this.maxStretchDistance=Math.abs(Math.min(this.vLeftLength,this.vRightLength)/Math.cos(.5*h))}};class Z{constructor(){this.vertices=[],this.vertexIndices=[],this.vertexNormals=[],this.poles=[],this.poleIndices=[],this.uvs=null,this.uvIndices=null}addVertex(t,e){return this.vertices.push(A(t)),this.vertexNormals.push(A(e)),this.vertices.length-1}addUV(t){return this.uvs||(this.uvs=[],this.uvIndices=[]),this.uvs.push(t),this.uvs.length-1}addPole(t,e=null){return this.poles.push({position:A(t),normal:e?A(e):null}),this.poles.length-1}addSegment(t,e=null,i=null){this.vertexIndices.push(t.v0),this.vertexIndices.push(t.v1),e&&(this.uvIndices.push(e.v0),this.uvIndices.push(e.v1)),i&&(this.poleIndices.push(i.v0),this.poleIndices.push(i.v1))}get numSegments(){return this.vertexIndices.length/2}hasUV(){return null!=this.uvs}translate(t,e){for(const i of this.vertices)i[0]+=t,i[1]+=e;for(const i of this.poles)i.position[0]+=t,i.position[1]+=e}static circle(t=20){const e=new Z,i={v0:0,v1:0};e.addPole(b(0,0));for(let i=0;i<t;++i){const s=2*i*Math.PI/t,r=Math.cos(s),o=Math.sin(s),h=b(.5*r,.5*o),a=b(r,o);e.addVertex(h,a),e.addUV(i/t)}e.addUV(1);for(let s=0;s<t-1;++s){const t={v0:s,v1:s+1},r=t;e.addSegment(t,r,i)}const s={v0:t-1,v1:0},r={v0:t-1,v1:t};return e.addSegment(s,r,i),e}static rect(){const t=new Z,e=b(-.5,-.5),i=b(.5,-.5),s=b(.5,.5),r=b(-.5,.5),o=b(0,-1),h=b(1,0),a=b(0,1),n=b(-1,0);t.addUV(0),t.addUV(1),t.addPole(b(0,.5),a),t.addPole(b(0,.5)),t.addPole(b(0,-.5)),t.addPole(b(0,-.5),o);const l={v0:0,v1:1};return t.addVertex(e,o),t.addVertex(i,o),t.addSegment({v0:0,v1:1},l,{v0:3,v1:3}),t.addVertex(i,h),t.addVertex(s,h),t.addSegment({v0:2,v1:3},l,{v0:2,v1:1}),t.addVertex(s,a),t.addVertex(r,a),t.addSegment({v0:4,v1:5},l,{v0:0,v1:0}),t.addVertex(r,n),t.addVertex(e,n),t.addSegment({v0:6,v1:7},l,{v0:1,v1:2}),t}}B.Profile=Z;B.Path=class{constructor(t){this.vertices=[],this.offset=s(),this.xform=g(),this.vertices=t;const e=Math.floor((t.length-1)/2);o(this.offset,this.vertices[e].pos);for(const t of this.vertices)l(t.pos,t.pos,this.offset);x(this.xform,this.xform,this.offset),this.updatePathVertexInformation()}updatePathVertexInformation(){const t=this.vertices.length;let e=this.vertices[0];e.index=0,f(e.vLeft,0,0,0),e.vLeftLength=0,l(e.vRight,this.vertices[1].pos,e.pos),e.vRightLength=c(e.vRight),a(e.vRight,e.vRight);let i=e;for(let s=1;s<t;++s)e=this.vertices[s],e.index=s,o(e.vLeft,i.vRight),e.vLeftLength=i.vRightLength,s<t-1?(l(e.vRight,this.vertices[s+1].pos,e.pos),e.vRightLength=c(e.vRight),a(e.vRight,e.vRight)):(o(e.vRight,e.vLeft),e.vRightLength=e.vLeftLength),i=e}},B.computeMinimumRotationTangentFrame=function(t,e){let i=null;const r=t.vertices.length,n=.99619469809,p=s(),d=s(),x=s(),m=s(),v=s(),g=s(),V=T.create();let A=t.vertices[0];o(d,e),f(p,0,1,0),F.makeOrthoBasisDirUpFallback(A.vRight,d,p,p,x,d,n),o(A.frame.up,d),o(A.frame.right,x),i=A;for(let e=1;e<r;++e){A=t.vertices[e],h(v,A.vLeft,A.vRight);let s=c(v);s>0?(s=1/Math.sqrt(s),v[0]=v[0]*s,v[1]=v[1]*s,v[2]=v[2]*s):(v[0]=A.vRight[0],v[1]=A.vRight[1],v[2]=A.vRight[2]),h(g,i.pos,i.frame.up),T.fromPositionAndNormal(A.pos,v,V);T.intersectRay(V,y.wrap(g,A.vLeft),m)?(l(m,m,A.pos),a(d,m),u(x,v,d),a(x,x)):F.makeOrthoBasisDirUpFallback(v,i.frame.up,i.frame.right,p,x,d,n),o(A.frame.up,d),o(A.frame.right,x),i=A}};B.Extruder=class{};B.SimpleExtruder=class{numProfilesPerJoin(){return 1}extrude(t,e,i){for(let s=0;s<e.vertices.length;++s)i(t.index,t.frame,e.vertices[s],e.vertexNormals[s],!1)}};B.MiterExtruder=class{constructor(t=.8*Math.PI,e=1){this.cutoffAngle=t,this.numBendSubdivisions=e}numProfilesPerJoin(){return this.numBendSubdivisions+1}extrude(t,e,i){const s=Q;if(Math.abs(t.rotationAngle)>=this.cutoffAngle)for(let a=0;a<this.numBendSubdivisions+1;++a){m(W),v(W,W,.5*-t.rotationAngle+a*t.rotationAngle/this.numBendSubdivisions,t.rotationFrame.up),r=s,o=t.frame,h=W,d(r.up,o.up,h),d(r.right,o.right,h);for(let r=0;r<e.vertices.length;++r){D(e.vertices[r],t.rotationRight)*t.rotationAngle>=0?i(t.index,s,e.vertices[r],e.vertexNormals[r],!1):(I(w,e.vertices[r],t.miterStretch),i(t.index,t.frame,w,e.vertexNormals[r],!0))}}else for(let s=0;s<this.numBendSubdivisions+1;++s)for(let s=0;s<e.vertices.length;++s){const r=D(e.vertices[s],t.rotationRight)*t.rotationAngle>=0;I(w,e.vertices[s],t.miterStretch),i(t.index,t.frame,w,e.vertexNormals[s],!r)}var r,o,h}};const $={generateUV:!1};class tt{rebuildConnectingProfileGeometry(t,e,i){for(let s=0;s<e.vertices.length;++s)i(t.index,t.frame,e.vertices[s],e.vertexNormals[s],0,0)}}B.CapBuilder=tt;B.NoCapBuilder=class extends tt{constructor(){super()}getNumVertices(){return 0}getNumIndices(){return 0}rebuildCapGeometry(){}buildTopology(){}};B.TriangulationCapBuilder=class extends tt{constructor(t,e=0,i=!1){super(),this.profile=t,this.profilePlaneOffset=e,this.flip=i}getNumVertices(){return this.profile.vertices.length}getNumIndices(){return 3*this.profile.numSegments}rebuildConnectingProfileGeometry(t,e,i){for(let s=0;s<e.vertices.length;++s)i(t.index,t.frame,e.vertices[s],e.vertexNormals[s],this.profilePlaneOffset,0)}rebuildCapGeometry(t,e){const i=j;C(i,0,0);const s=this.flip?1:-1;for(let r=0;r<this.profile.vertices.length;++r)e(t.index,t.frame,this.profile.vertices[r],i,this.profilePlaneOffset,s)}buildTopology(t,e){const i=this.vertexBufferStart+this.profile.vertexIndices[0];for(let t=1;t<this.profile.numSegments;++t){const s=this.profile.vertexIndices[2*t+0],r=this.profile.vertexIndices[2*t+1],o=this.vertexBufferStart+s,h=this.vertexBufferStart+r;this.flip?e(h,o,i):e(i,o,h)}}};B.RoundCapBuilder=class extends tt{constructor(t){super(),this.flip=!1,this.sign=0,this.breakNormals=!1,this.numSegments=3,this.profile=t.profile,this.flip=t.flip,this.sign=this.flip?1:-1,this.breakNormals=t.breakNormals,this.numSegments=t.subdivisions}getNumVertices(){let t=0;return t=this.profile.vertices.length*(this.numSegments-1),this.breakNormals&&(t+=this.profile.vertices.length),t+=this.profile.poles.length,t}getNumIndices(){let t=0;t+=2*this.profile.numSegments*(this.numSegments-1);for(let e=0;e<this.profile.numSegments;++e){const i=this.profile.vertexIndices[2*e+0],s=this.profile.vertexIndices[2*e+1];this.profile.poleIndices[i]===this.profile.poleIndices[s]?t+=1:t+=2}return 3*t}rebuildCapGeometry(t,e){const i=t.frame,s=.5*this.sign,r=w,o=j;C(o,0,0);for(let r=0;r<this.profile.poles.length;++r){const h=this.profile.poles[r];h.normal?e(t.index,i,h.position,h.normal,s,0):e(t.index,i,h.position,o,s,this.sign)}if(this.breakNormals)for(let s=0;s<this.profile.vertices.length;++s)e(t.index,i,this.profile.vertices[s],this.profile.vertexNormals[s],0,0);for(let h=0;h<this.numSegments-1;++h){const a=(1-(h+1)/this.numSegments)*Math.PI*.5,n=Math.sin(a),l=Math.cos(a);for(let h=0;h<this.profile.vertices.length;++h){const a=this.profile.poles[this.profile.poleIndices[h]];R(r,this.profile.vertices[h],a.position),P(r,r,n),a.normal?(N(r,r,a.position),e(t.index,i,r,a.normal,s*l,0)):(S(o,r),P(o,o,n),N(r,r,a.position),e(t.index,i,r,o,s*l,this.sign*l))}}}buildTopology(t,e){const i=this.breakNormals?this.vertexBufferStart+this.profile.poles.length:this.firstProfileVertexIndex,s=this.breakNormals?this.vertexBufferStart+this.profile.poles.length+this.profile.vertices.length:this.vertexBufferStart+this.profile.poles.length;for(let t=0;t<this.profile.numSegments;++t){const r=this.profile.vertexIndices[2*t+0],o=this.profile.vertexIndices[2*t+1],h=this.vertexBufferStart+this.profile.poleIndices[r],a=this.vertexBufferStart+this.profile.poleIndices[o];let n=i+r,l=i+o;for(let t=0;t<this.numSegments-1;++t){const i=s+t*this.profile.vertices.length+r,h=s+t*this.profile.vertices.length+o;this.flip?(e(i,l,n),e(l,i,h)):(e(n,l,i),e(h,i,l)),n=i,l=h}this.flip?(e(h,l,n),h!==a&&e(h,a,l)):(e(n,l,h),h!==a&&e(l,a,h))}}};B.Builder=class{constructor(t,e,i,s,r,o=$){this.options=o,this._extrusionVertexCount=0,this._triangleCount=0,this.numExtrusionProfiles=0,this.numVerticesTotal=0,this.numNormalsTotal=0,this.numUVTotal=0,this.profile=e,this.path=t,this.extruder=i,this.startCap=s,this.endCap=r;const h=this.path.vertices.length-2;this.numExtrusionProfiles=i.numProfilesPerJoin()*h+2,this.numVerticesTotal=e.vertices.length*this.numExtrusionProfiles,this.numNormalsTotal=this.numVerticesTotal,this.startCap.vertexBufferStart=this.numVerticesTotal;const a=this.startCap.getNumVertices();this.numVerticesTotal+=a,this.numNormalsTotal+=a,this.endCap.vertexBufferStart=this.numVerticesTotal;const n=this.endCap.getNumVertices();this.numVerticesTotal+=n,this.numNormalsTotal+=n,this.pathVertexData=new Float32Array(1*this.numVerticesTotal),this.profileRightAxisData=new Float32Array(4*this.numVerticesTotal),this.profileUpAxisData=new Float32Array(4*this.numVerticesTotal),this.profileVertexAndNormalData=new Float32Array(4*this.numVerticesTotal),this.profile.hasUV()&&this.options.generateUV&&(this.numUVTotal=this.profile.uvs.length,this.uvData=new Float32Array(2*this.numUVTotal)),this.originData=new Float32Array(3*this.path.vertices.length),this.rebuildGeometry(),this.buildTopology()}emitVertex(t,e,i,s,r){if(this.profileRightAxisData[4*this._extrusionVertexCount+0]=e.right[0],this.profileRightAxisData[4*this._extrusionVertexCount+1]=e.right[1],this.profileRightAxisData[4*this._extrusionVertexCount+2]=e.right[2],this.profileUpAxisData[4*this._extrusionVertexCount+0]=e.up[0],this.profileUpAxisData[4*this._extrusionVertexCount+1]=e.up[1],this.profileUpAxisData[4*this._extrusionVertexCount+2]=e.up[2],this.profileVertexAndNormalData[4*this._extrusionVertexCount+0]=i[0],this.profileVertexAndNormalData[4*this._extrusionVertexCount+1]=i[1],this.profileVertexAndNormalData[4*this._extrusionVertexCount+2]=s[0],this.profileVertexAndNormalData[4*this._extrusionVertexCount+3]=s[1],this.pathVertexData[this._extrusionVertexCount]=t,r){const e=this.path.vertices[t];this.profileRightAxisData[4*this._extrusionVertexCount+3]=e.rotationRight[0]*e.maxStretchDistance,this.profileUpAxisData[4*this._extrusionVertexCount+3]=e.rotationRight[1]*e.maxStretchDistance}else this.profileRightAxisData[4*this._extrusionVertexCount+3]=0,this.profileUpAxisData[4*this._extrusionVertexCount+3]=0;++this._extrusionVertexCount}emitCapVertex(t,e,i,s,r,o){this.profileRightAxisData[4*this._extrusionVertexCount+0]=e.right[0],this.profileRightAxisData[4*this._extrusionVertexCount+1]=e.right[1],this.profileRightAxisData[4*this._extrusionVertexCount+2]=e.right[2],this.profileUpAxisData[4*this._extrusionVertexCount+0]=e.up[0],this.profileUpAxisData[4*this._extrusionVertexCount+1]=e.up[1],this.profileUpAxisData[4*this._extrusionVertexCount+2]=e.up[2],this.profileVertexAndNormalData[4*this._extrusionVertexCount+0]=i[0],this.profileVertexAndNormalData[4*this._extrusionVertexCount+1]=i[1],this.profileVertexAndNormalData[4*this._extrusionVertexCount+2]=s[0],this.profileVertexAndNormalData[4*this._extrusionVertexCount+3]=s[1],this.pathVertexData[this._extrusionVertexCount]=t,this.profileRightAxisData[4*this._extrusionVertexCount+3]=r,this.profileUpAxisData[4*this._extrusionVertexCount+3]=o,++this._extrusionVertexCount}emitTriangle(t,e,i){this.vertexIndices[3*this._triangleCount+0]=t,this.vertexIndices[3*this._triangleCount+1]=e,this.vertexIndices[3*this._triangleCount+2]=i,this.pathVertexIndices[3*this._triangleCount+0]=this.pathVertexData[t],this.pathVertexIndices[3*this._triangleCount+1]=this.pathVertexData[e],this.pathVertexIndices[3*this._triangleCount+2]=this.pathVertexData[i],this.normalIndices[3*this._triangleCount+0]=t,this.normalIndices[3*this._triangleCount+1]=e,this.normalIndices[3*this._triangleCount+2]=i,++this._triangleCount}rebuildGeometry(){const t=(t,e,i,s,r)=>this.emitVertex(t,e,i,s,r),e=(t,e,i,s,r,o)=>this.emitCapVertex(t,e,i,s,r,o);this._extrusionVertexCount=0;for(const t of this.path.vertices)this.originData[3*t.index+0]=t.pos[0],this.originData[3*t.index+1]=t.pos[1],this.originData[3*t.index+2]=t.pos[2];this.startCap.rebuildConnectingProfileGeometry(this.path.vertices[0],this.profile,e);for(let e=1;e<this.path.vertices.length-1;++e)this.extruder.extrude(this.path.vertices[e],this.profile,t);if(this.endCap.rebuildConnectingProfileGeometry(this.path.vertices[this.path.vertices.length-1],this.profile,e),this.startCap.rebuildCapGeometry(this.path.vertices[0],e),this.endCap.rebuildCapGeometry(this.path.vertices[this.path.vertices.length-1],e),this.profile.hasUV()&&this.options.generateUV)for(let t=0;t<this.profile.uvs.length;++t)this.uvData[2*t+0]=this.profile.uvs[t],this.uvData[2*t+1]=0}buildTopology(){const t=(t,e,i)=>this.emitTriangle(t,e,i);this._triangleCount=0;const e=this.profile.vertices.length,i=this.profile.numSegments,s=this.numExtrusionProfiles-1;let r=3*(2*(i*s));this.startCap.indexBufferStart=r,this.startCap.firstProfileVertexIndex=0,r+=this.startCap.getNumIndices(),this.endCap.indexBufferStart=r,this.endCap.firstProfileVertexIndex=e*(this.numExtrusionProfiles-1),r+=this.endCap.getNumIndices(),this.vertexIndices=new Uint32Array(r),this.normalIndices=new Uint32Array(r),this.pathVertexIndices=new Uint32Array(r),this.profile.hasUV()&&this.options.generateUV&&(this.uvIndices=new Uint32Array(r));for(let r=0;r<i;++r){const i=this.profile.vertexIndices[2*r],o=this.profile.vertexIndices[2*r+1];for(let r=0;r<s;++r){const s=r*e+i,h=(r+1)*e+o,a=r*e+o;t(s,(r+1)*e+i,h),t(s,h,a)}}this.startCap.buildTopology(this.path.vertices[0],t),this.endCap.buildTopology(this.path.vertices[this.path.vertices.length-1],t)}onPathChanged(){this.rebuildGeometry()}};class et{constructor(t){this.builder=t}get xform(){return this.builder.path.xform}onPathChanged(){this.builder.onPathChanged()}}B.PathGeometry=et;class it extends et{constructor(t){super(t),this.vertexAttributePosition=null,this.vertexAttributeNormal=null,this.vertexAttributeColor=null,this.vertexAttributePosition=new Float32Array(3*this.builder.numVerticesTotal),this.vertexAttributeNormal=new Float32Array(3*this.builder.numNormalsTotal),this.vertexAttributeColor=new Uint8Array(4),this.vertexAttributeColor[0]=255,this.vertexAttributeColor[1]=255,this.vertexAttributeColor[2]=255,this.vertexAttributeColor[3]=255}bakeVertexColors(t){this.vertexAttributeColor[0]=255*t[0],this.vertexAttributeColor[1]=255*t[1],this.vertexAttributeColor[2]=255*t[2],this.vertexAttributeColor[3]=255*(t.length>3?t[3]:1)}bake(e){this.size=e;for(let i=0;i<this.builder.numVerticesTotal;++i){const s=this.builder.pathVertexData[i],r=0===s||s===this.builder.path.vertices.length-1,o=G;f(o,this.builder.originData[3*s+0],this.builder.originData[3*s+1],this.builder.originData[3*s+2]);const h=J,a=w,n=q,l=H,p=X;let c=0,d=0;if(f(l,this.builder.profileRightAxisData[4*i+0],this.builder.profileRightAxisData[4*i+1],this.builder.profileRightAxisData[4*i+2]),f(p,this.builder.profileUpAxisData[4*i+0],this.builder.profileUpAxisData[4*i+1],this.builder.profileUpAxisData[4*i+2]),C(a,this.builder.profileVertexAndNormalData[4*i+0]*e[0],this.builder.profileVertexAndNormalData[4*i+1]*e[1]),r)u(n,p,l),c=this.builder.profileRightAxisData[4*i+3]*e[0],d=this.builder.profileUpAxisData[4*i+3];else{const e=j,s=z;C(e,this.builder.profileRightAxisData[4*i+3],this.builder.profileUpAxisData[4*i+3]);const r=U(e);S(e,e);const o=D(a,e);if(Math.abs(o)>r){C(s,-e[1],e[0]);const i=D(a,s);P(e,e,r*t(o)),P(s,s,i),N(a,e,s)}f(n,0,0,0)}f(h,l[0]*a[0]+p[0]*a[1],l[1]*a[0]+p[1]*a[1],l[2]*a[0]+p[2]*a[1]),this.vertexAttributePosition[3*i+0]=o[0]+h[0]+n[0]*c,this.vertexAttributePosition[3*i+1]=o[1]+h[1]+n[1]*c,this.vertexAttributePosition[3*i+2]=o[2]+h[2]+n[2]*c;const x=w;C(x,this.builder.profileVertexAndNormalData[4*i+2],this.builder.profileVertexAndNormalData[4*i+3]),this.vertexAttributeNormal[3*i+0]=l[0]*x[0]+p[0]*x[1]+n[0]*d,this.vertexAttributeNormal[3*i+1]=l[1]*x[0]+p[1]*x[1]+n[1]*d,this.vertexAttributeNormal[3*i+2]=l[2]*x[0]+p[2]*x[1]+n[2]*d}}createGeometryData(){const t={};if(t[_.POSITION]=this.builder.vertexIndices,t[_.NORMAL]=this.builder.normalIndices,this.vertexAttributeColor){const e=t[_.POSITION].length;t[_.COLOR]=new Uint32Array(e)}const e={};return e[_.POSITION]={size:3,data:this.vertexAttributePosition},e[_.NORMAL]={size:3,data:this.vertexAttributeNormal},this.vertexAttributeColor&&(e[_.COLOR]={size:4,data:this.vertexAttributeColor}),new L(e,t,"triangle")}onPathChanged(){super.onPathChanged(),this.bake(this.size)}intersect(t,e,i){const s=this.builder.vertexIndices,r={size:3,offsetIdx:0,strideIdx:3,data:this.vertexAttributePosition},o=s.length/3;O(t,e,0,o,s,r,void 0,void 0,i)}}B.StaticPathGeometry=it;B.FastUpdatePathGeometry=class extends et{constructor(t,e,i,s){super(t),this.sizeAttributeValue=e,this.colorAttributeValue=i,this.opacityAttributeValue=s,this.vvData=null,this.baked=new it(t),this.vvData=new Float32Array(4*this.builder.path.vertices.length);for(let t=0;t<this.builder.path.vertices.length;++t){this.vvData[4*t+0]=e,this.vvData[4*t+1]=i,this.vvData[4*t+2]=s;const r=0===t||t===this.builder.path.vertices.length-1;this.vvData[4*t+3]=r?1:0}}createGeometryData(){const t={};t[M.POSITION]=this.builder.pathVertexIndices,t[M.PROFILERIGHT]=this.builder.vertexIndices,t[M.PROFILEUP]=this.builder.vertexIndices,t[M.PROFILEVERTEXANDNORMAL]=this.builder.vertexIndices,t[M.FEATUREVALUE]=this.builder.pathVertexIndices;const e={};return e[M.POSITION]={size:3,data:this.builder.originData},e[M.PROFILERIGHT]={size:4,data:this.builder.profileRightAxisData},e[M.PROFILEUP]={size:4,data:this.builder.profileUpAxisData},e[M.PROFILEVERTEXANDNORMAL]={size:4,data:this.builder.profileVertexAndNormalData},e[M.FEATUREVALUE]={size:4,data:this.vvData},new L(e,t,"triangle")}}}(B||(B={}));const G=s(),w=V(),j=V(),z=V(),J=s(),q=s(),H=s(),X=s(),K=s(),Q=B.makeFrame(),W=g();var Y=B;export default Y;
