/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{clamp as e}from"../../../../core/mathUtils.js";import{BufferViewVec4f as t}from"../../support/buffer/BufferView.js";import{fromValues as i}from"../../../../geometry/support/aaBoundingBox.js";import{newLayout as a}from"../../support/buffer/InterleavedLayout.js";import{computeAttachmentOriginLines as s}from"../lib/geometryDataUtils.js";import{assert as r}from"../lib/Util.js";import n from"../lib/GLMaterial.js";import{intersectAabbInvDir as o}from"./internal/MaterialUtil.js";import{Material as u,materialParametersDefaults as h}from"../lib/Material.js";import{writeDefaultAttributes as c,writeBufferVec4 as d}from"./internal/bufferWriterUtils.js";import p from"./VisualVariableMaterialParameters.js";import{pathVertexAttributeLocations as l,PathTechniqueConfiguration as f,PathVertexAttrConstants as m,PathTechnique as b}from"./PathTechnique.js";const v=r;class g extends u{constructor(e,t){super(t,e,E),this.supportsEdges=!0,this._vertexAttributeLocations=l,this.techniqueConfig=new f,this.vertexBufferLayout=g.getVertexBufferLayout(this.params)}getTechniqueConfig(e,t){return this.techniqueConfig.output=e,this.techniqueConfig.vvSize=this.params.vvSizeEnabled,this.techniqueConfig.vvColor=this.params.vvColorEnabled,this.techniqueConfig.vvOpacity=this.params.vvOpacityEnabled,this.techniqueConfig.slicePlaneEnabled=this.params.slicePlaneEnabled,this.techniqueConfig.transparent=this.params.transparent,this.techniqueConfig.sceneHasOcludees=this.params.sceneHasOcludees,0!==e&&7!==e||(this.techniqueConfig.doubleSidedMode=this.params.doubleSided&&"normal"===this.params.doubleSidedType?1:this.params.doubleSided&&"winding-order"===this.params.doubleSidedType?2:0,this.techniqueConfig.receiveShadows=this.params.receiveShadows,this.techniqueConfig.receiveSSAO=this.params.receiveSSAO),this.techniqueConfig.transparencyPassType=t?t.transparencyPassType:3,this.techniqueConfig}getPassParameters(){return this.params}isVisibleInPass(e){return 4!==e||this.params.castShadows}isVisible(){const e=this.params;return!!super.isVisible()&&e.opacity>0}intersect(t,a,s,r,n,u,h){const c=t;if(!c.metadata)return;const d=c.metadata.pathGeometry,p=[this.params.size[0],this.params.size[1]];if(this.params.vvSizeEnabled){const t=this.params.vvSizeOffset,i=this.params.vvSizeFactor,a=this.params.vvSizeMinSize,s=this.params.vvSizeMaxSize,r=d.sizeAttributeValue;p[0]*=e(t[0]+r*i[0],a[0],s[0]),p[1]*=e(t[2]+r*i[2],a[2],s[2])}const l=Math.max(p[0],p[1]),f=i(t.boundingInfo.bbMin[0]-l,t.boundingInfo.bbMin[1]-l,t.boundingInfo.bbMin[2]-l,t.boundingInfo.bbMax[0]+l,t.boundingInfo.bbMax[1]+l,t.boundingInfo.bbMax[2]+l),m=[u[0]-n[0],u[1]-n[1],u[2]-n[2]],b=Math.sqrt(m[0]*m[0]+m[1]*m[1]+m[2]*m[2]);o(f,n,[b/m[0],b/m[1],b/m[2]],r.tolerance)&&(d.baked.size&&d.baked.size[0]===p[0]&&d.baked.size[1]===p[1]||d.baked.bake(p),d.baked.intersect(n,u,h))}computeAttachmentOrigin(e,t){const i=e.data,a="getVertexAttr"in i?i.getVertexAttr():"vertexAttr"in i?i.vertexAttr:null;if(!a)return null;const r=a[m.POSITION];return s(r,null,!1,t)}createBufferWriter(){return new O(this.vertexBufferLayout)}getGLMaterial(e){if(0===e.output||7===e.output||1===e.output||2===e.output||4===e.output||3===e.output&&this.params.castShadows)return new S(e)}static getVertexBufferLayout(e){let t=a().vec3f(m.POSITION).vec4f(m.PROFILERIGHT).vec4f(m.PROFILEUP).vec4f(m.PROFILEVERTEXANDNORMAL);return(e.vvColorEnabled||e.vvSizeEnabled||e.vvOpacityEnabled)&&(t=t.vec4f(m.FEATUREVALUE)),t}}class S extends n{constructor(e){super(e),this.updateParameters()}updateParameters(e){this.technique=this.techniqueRep.acquireAndReleaseExisting(b,this.material.getTechniqueConfig(this.output,e),this.technique)}beginSlot(e){return e===(this.technique.configuration.transparent?5:3)}_updateOccludeeState(e){e.hasOccludees!==this.material.params.sceneHasOcludees&&this.material.setParameterValues({sceneHasOcludees:e.hasOccludees})}_updateShadowState(e){e.shadowMappingEnabled!==this.technique.configuration.receiveShadows&&this.material.setParameterValues({receiveShadows:e.shadowMappingEnabled})}ensureParameters(e){0!==this.output&&7!==this.output||(this._updateShadowState(e),this._updateOccludeeState(e)),this.updateParameters(e)}bind(e,t){e.bindProgram(this.technique.program),this.technique.bindPass(e,this.material.getPassParameters(),t)}}const E={size:[1,1,1],ambient:[.2,.2,.2],diffuse:[.8,.8,.8],specular:[0,0,0],opacity:1,doubleSided:!1,doubleSidedType:"normal",receiveSSAO:!0,receiveShadows:!1,castShadows:!0,slicePlaneEnabled:!1,transparent:!1,sceneHasOcludees:!1,...p.Default,...h};class O{constructor(e){this.vertexBufferLayout=e}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return e.indices[m.POSITION].length}write(e,i,a,s){const r=e=>{if(e in i.vertexAttr){const r=i.vertexAttr[e],n=i.indices[e];v(4===r.size);const o=a.getField(e,t);if(!o)throw new Error("unable to acquire view for "+e);d(n,r.data,o,s)}};r(m.PROFILERIGHT),r(m.PROFILEUP),r(m.PROFILEVERTEXANDNORMAL),this.vertexBufferLayout.hasField(m.FEATUREVALUE)&&r(m.FEATUREVALUE),c(i,this.vertexBufferLayout,e.transformation,e.invTranspTransformation,a,s)}}export{g as PathMaterial};
