/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{isSome as e}from"../../../../core/maybe.js";import{clamp as t,sign as i}from"../../../../core/mathUtils.js";import{createRenderScreenPointArray3 as s}from"../../../../core/screenUtils.js";import{c as r,f as n}from"../../../../chunks/vec3f64.js";import{s as a,i as o,n as c,f as l,a as f,g as u,l as h,k as p,t as d,d as m,b as g}from"../../../../chunks/vec3.js";import{a as S}from"../../../../chunks/mat4.js";import{create as O}from"../../../../geometry/support/aaBoundingRect.js";import{a as v}from"../../../../chunks/mat3f64.js";import{a as x}from"../../../../chunks/mat4f64.js";import{a as P,f as A}from"../../../../chunks/vec2f64.js";import{f as b}from"../../../../chunks/mat3.js";import{c as q}from"../../../../chunks/vec2.js";import{newLayout as C}from"../../support/buffer/InterleavedLayout.js";import{computeAttachmentOriginPoints as y}from"../lib/geometryDataUtils.js";import{VertexAttrConstants as z,assert as T}from"../lib/Util.js";import{isInstanceHidden as I}from"./renderers/utils.js";import{applyScaleFactor as w,applyPrecomputedScaleFactor as U,precomputeScaleFactor as V}from"../lib/screenSizePerspectiveUtils.js";import{isMat4 as j}from"../../../../core/libs/gl-matrix-2/types/mat4.js";import M from"../lib/GLMaterialTexture.js";import{verticalOffsetAtDistance as R}from"./internal/MaterialUtil.js";import{Material as E,materialParametersDefaults as D}from"../lib/Material.js";import{writePosition as N,writeNormal as B,writeColor as L,writeBufferVec4 as G}from"./internal/bufferWriterUtils.js";import{c as X}from"../../../../chunks/HUDMaterial.glsl.js";import{HUDMaterialTechniqueConfiguration as k,HUDMaterialTechnique as H}from"../shaders/HUDMaterialTechnique.js";class F extends E{constructor(e,t){super(t,e,pe),this.techniqueConfig=new k}getTechniqueConfig(e,t){return this.techniqueConfig.output=e,this.techniqueConfig.slicePlaneEnabled=this.params.slicePlaneEnabled,this.techniqueConfig.verticalOffset=!!this.params.verticalOffset,this.techniqueConfig.screenSizePerspective=!!this.params.screenSizePerspective,this.techniqueConfig.screenCenterOffsetUnitsEnabled="screen"===this.params.centerOffsetUnits?1:0,this.techniqueConfig.polygonOffsetEnabled=this.params.polygonOffset,this.techniqueConfig.isDraped=this.params.isDraped,this.techniqueConfig.occlusionTestEnabled=this.params.occlusionTest,this.techniqueConfig.pixelSnappingEnabled=this.params.pixelSnappingEnabled,this.techniqueConfig.sdf=this.params.textureIsSignedDistanceField,this.techniqueConfig.vvSize=!!this.params.vvSizeEnabled,this.techniqueConfig.vvColor=!!this.params.vvColorEnabled,0===e&&(this.techniqueConfig.debugDrawBorder=!!this.params.debugDrawBorder),4===e&&(this.techniqueConfig.binaryHighlightOcclusion=this.params.binaryHighlightOcclusion),this.techniqueConfig.depthEnabled=this.params.depthEnabled,this.techniqueConfig.transparencyPassType=t?t.transparencyPassType:3,this.techniqueConfig}intersect(e,t,i,s,r,n,a,o,c){c?this.intersectDrapedHudGeometry(e,n,a,o):this.intersectHudGeometry(e,t,i,s,a,o)}intersectDrapedHudGeometry(e,t,i,s){const r=e.getAttribute(z.POSITION),n=e.getAttribute(z.SIZE),a=this.params,o=X(a);let c=1,l=1;if(s){const e=s(ce);c=e[0],l=e[5]}c*=e.screenToWorldRatio,l*=e.screenToWorldRatio;const f=fe*e.screenToWorldRatio;for(let s=0;s<r.data.length/r.size;s++){const u=s*r.size,h=r.data[u],p=r.data[u+1],d=s*n.size;let m;ue[0]=n.data[d]*c,ue[1]=n.data[d+1]*l,a.textureIsSignedDistanceField&&(m=a.outlineSize*e.screenToWorldRatio/2),K(t,h,p,ue,f,m,a,o)&&i()}}intersectHudGeometry(e,t,i,s,n,d){if(!s.options.selectionMode||!s.options.hud)return;if(I(t))return;const m=e.data,g=this.params;let O=1,v=1;if(b(se,i),d){const e=d(ce);O=e[0],v=e[5],function(e){const t=e[0],i=e[1],s=e[2],r=e[3],n=e[4],a=e[5],o=e[6],c=e[7],l=e[8],f=1/Math.sqrt(t*t+i*i+s*s),u=1/Math.sqrt(r*r+n*n+a*a),h=1/Math.sqrt(o*o+c*c+l*l);e[0]=t*f,e[1]=i*f,e[2]=s*f,e[3]=r*u,e[4]=n*u,e[5]=a*u,e[6]=o*h,e[7]=c*h,e[8]=l*h}(se)}const x=m.getVertexAttr()[z.POSITION],P=m.getVertexAttr()[z.SIZE],A=m.getVertexAttr()[z.NORMAL],q=m.getVertexAttr()[z.AUXPOS1];T(x.size>=3);const C=s.point,y=s.camera,V=X(g);O*=y.pixelRatio,v*=y.pixelRatio;const j="screen"===this.params.centerOffsetUnits;for(let e=0;e<x.data.length/x.size;e++){const t=e*x.size;a($,x.data[t],x.data[t+1],x.data[t+2]),o($,$,i);const d=e*P.size;ue[0]=P.data[d]*O,ue[1]=P.data[d+1]*v,o($,$,y.viewMatrix);const m=e*q.size;if(a(ae,q.data[m+0],q.data[m+1],q.data[m+2]),!j&&($[0]+=ae[0],$[1]+=ae[1],0!==ae[2])){const e=ae[2];c(ae,$),l($,$,f(ae,ae,e))}const b=e*A.size;if(a(_,A.data[b],A.data[b+1],A.data[b+2]),this.normalAndViewAngle(_,se,y,oe),this.applyVerticalOffsetTransformationView($,oe,y,Q),y.applyProjection($,ee),ee[0]>-1){let e=Math.floor(ee[0])+this.params.screenOffset[0],t=Math.floor(ee[1])+this.params.screenOffset[1];j&&(e+=ae[0],0!==ae[1]&&(t+=w(ae[1],Q.factorAlignment))),U(ue,Q.factor,ue);const i=le*y.pixelRatio;let a;if(g.textureIsSignedDistanceField&&(a=g.outlineSize*y.pixelRatio/2),K(C,e,t,ue,i,a,g,V)){const e=s.ray;if(o(ie,$,S(ne,y.viewMatrix)),ee[0]=C[0],ee[1]=C[1],y.unprojectFromRenderScreen(ee,$)){const t=r();u(t,e.direction);const i=1/h(t);f(t,t,i);n(p(e.origin,$)*i,t,-1,1,!0,ie)}}}}}computeAttachmentOrigin(e,t){const i=e.data,s="getVertexAttr"in i?i.getVertexAttr():"vertexAttr"in i?i.vertexAttr:null;if(!s)return null;const r=z.POSITION,n=s[r],a="getIndices"in i?i.getIndices(r):"indices"in i?i.indices[r]:null;return y(n,a,t)}createBufferWriter(){return new me(this)}normalAndViewAngle(e,t,i,s){return j(t)&&(t=b(re,t)),d(s.normal,e,t),o(s.normal,s.normal,i.viewInverseTransposeMatrix),s.cosAngle=m(te,he),s}updateScaleInfo(e,t,i){const s=this.params;s.screenSizePerspective?V(i,t,s.screenSizePerspective,e.factor):(e.factor.scale=1,e.factor.factor=0,e.factor.minPixelSize=0,e.factor.paddingPixels=0),s.screenSizePerspectiveAlignment?V(i,t,s.screenSizePerspectiveAlignment,e.factorAlignment):(e.factorAlignment.factor=e.factor.factor,e.factorAlignment.scale=e.factor.scale,e.factorAlignment.minPixelSize=e.factor.minPixelSize,e.factorAlignment.paddingPixels=e.factor.paddingPixels)}applyShaderOffsetsView(e,t,i,s,r,n,a){const o=this.normalAndViewAngle(t,i,r,oe);return this.applyVerticalGroundOffsetView(e,o,r,a),this.applyVerticalOffsetTransformationView(a,o,r,n),this.applyPolygonOffsetView(a,o,s[3],r,a),this.applyCenterOffsetView(a,s,a),a}applyShaderOffsetsNDC(t,i,s,r,n){return this.applyCenterOffsetNDC(t,i,s,r),e(n)&&u(n,r),this.applyPolygonOffsetNDC(r,i,s,r),r}applyPolygonOffsetView(e,s,r,n,a){const o=n.aboveGround?1:-1;let c=i(r);0===c&&(c=o);const l=o*c;if(this.params.shaderPolygonOffset<=0)return u(a,e);const h=t(Math.abs(s.cosAngle),.01,1),p=1-Math.sqrt(1-h*h)/h/n.viewport[2];return f(a,e,l>0?p:1/p),a}applyVerticalGroundOffsetView(e,t,i,s){const r=h(e),n=i.aboveGround?1:-1,a=.5*i.computeRenderPixelSizeAtDist(r),o=f($,t.normal,n*a);return g(s,e,o),s}applyVerticalOffsetTransformationView(e,t,i,s){const r=this.params;if(!r.verticalOffset||!r.verticalOffset.screenLength){if(r.screenSizePerspective||r.screenSizePerspectiveAlignment){const i=h(e);this.updateScaleInfo(s,i,t.cosAngle)}else s.factor.scale=1,s.factorAlignment.scale=1;return e}const n=h(e),a=r.screenSizePerspectiveAlignment||r.screenSizePerspective,o=R(i,n,r.verticalOffset,t.cosAngle,a);return this.updateScaleInfo(s,n,t.cosAngle),f(t.normal,t.normal,o),g(e,e,t.normal)}applyCenterOffsetView(e,t,i){const s="screen"!==this.params.centerOffsetUnits;return i!==e&&u(i,e),s&&(i[0]+=t[0],i[1]+=t[1],t[2]&&(c(_,i),g(i,i,f(_,_,t[2])))),i}applyCenterOffsetNDC(e,t,i,s){const r="screen"!==this.params.centerOffsetUnits;return s!==e&&u(s,e),r||(s[0]+=t[0]/i.fullWidth*2,s[1]+=t[1]/i.fullHeight*2),s}applyPolygonOffsetNDC(e,t,s,r){const n=this.params.shaderPolygonOffset;if(e!==r&&u(r,e),n){const e=s.aboveGround?1:-1,a=e*i(t[3]);r[2]-=(a||e)*n}return r}getGLMaterial(e){return 0===e.output||7===e.output?new Z(e):4===e.output?new J(e):void 0}calculateRelativeScreenBounds(e,t,i=O()){return function(e,t,i,s=Y){q(s,e.anchorPos),s[0]*=-t[0],s[1]*=-t[1],s[0]+=e.screenOffset[0]*i,s[1]+=e.screenOffset[1]*i}(this.params,e,t,i),i[2]=i[0]+e[0],i[3]=i[1]+e[1],i}}class W extends M{constructor(e){super({...e,...e.material.params}),this.updateParameters()}beginSlot(e){return e===(this.material.params.drawInSecondSlot?19:18)}updateParameters(e){this.updateTexture(this.material.params.textureId),this.selectProgram(e)}selectProgram(e){this.technique=this.techniqueRep.acquireAndReleaseExisting(H,this.material.getTechniqueConfig(this.output,e),this.technique)}ensureParameters(e){this.updateParameters(e)}bind(e,t){e.bindProgram(this.technique.program),this.bindTexture(e,this.technique.program),this.bindTextureScale(e,this.technique.program),this.technique.bindPass(e,this.material.params,t)}}class Z extends W{constructor(e){super(e),this.isOcclusionSlot=!1}beginSlot(e){const t=this.material.params.drawInSecondSlot?19:18;return this.material.params.occlusionTest?(this.isOcclusionSlot=12===e,12===e||e===t):(this.isOcclusionSlot=!1,e===t)}getTechnique(){return this.isOcclusionSlot?this.occlusionTechnique:this.technique}selectProgram(e){this.technique=this.techniqueRep.acquireAndReleaseExisting(H,this.material.getTechniqueConfig(this.output,e),this.technique),this.occlusionTechnique=this.techniqueRep.acquireAndReleaseExisting(H,this.material.getTechniqueConfig(6,e),this.occlusionTechnique)}bind(e,t){const i=this.getTechnique();e.bindProgram(i.program),this.isOcclusionSlot||(this.bindTexture(e,i.program),this.bindTextureScale(e,i.program)),i.bindPass(e,this.material.params,t)}}class J extends W{constructor(e){super({...e,output:4})}}function K(e,t,i,s,r,n,a,o){let c=t-r-(o[0]>0?s[0]*o[0]:0),l=c+s[0]+2*r,f=i-r-(o[1]>0?s[1]*o[1]:0),u=f+s[1]+2*r;if(a.textureIsSignedDistanceField){const e=a.distanceFieldBoundingBox;c+=s[0]*e[0],f+=s[1]*e[1],l-=s[0]*(1-e[2]),u-=s[1]*(1-e[3]),c-=n,l+=n,f-=n,u+=n}return e[0]>c&&e[0]<l&&e[1]>f&&e[1]<u}const Q={factor:{scale:0,factor:0,minPixelSize:0,paddingPixels:0},factorAlignment:{scale:0,factor:0,minPixelSize:0,paddingPixels:0}},Y=P(),$=r(),_=r(),ee=s(),te=r(),ie=r(),se=v(),re=v(),ne=x(),ae=r(),oe={normal:te,cosAngle:0},ce=x(),le=1,fe=2,ue=[0,0],he=n(0,0,1),pe={texCoordScale:[1,1],occlusionTest:!0,binaryHighlightOcclusion:!0,drawInSecondSlot:!1,color:[1,1,1,1],outlineColor:[1,1,1,1],outlineSize:0,textureIsSignedDistanceField:!1,distanceFieldBoundingBox:null,vvSizeEnabled:!1,vvSizeMinSize:[1,1,1],vvSizeMaxSize:[100,100,100],vvSizeOffset:[0,0,0],vvSizeFactor:[1,1,1],vvColorEnabled:!1,vvColorValues:[0,0,0,0,0,0,0,0],vvColorColors:[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],screenOffset:[0,0],verticalOffset:null,screenSizePerspective:null,screenSizePerspectiveAlignment:null,slicePlaneEnabled:!1,anchorPos:A(.5,.5),shaderPolygonOffset:1e-5,polygonOffset:!1,textureId:null,centerOffsetUnits:"world",depthEnabled:!0,pixelSnappingEnabled:!0,debugDrawBorder:!1,isDraped:!1,...D},de=C().vec3f(z.POSITION).vec3f(z.NORMAL).vec2f(z.UV0).vec4u8(z.COLOR).vec2f(z.SIZE).vec4f(z.AUXPOS1).vec4f(z.AUXPOS2);class me{constructor(e){this.material=e,this.vertexBufferLayout=de}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return 6*e.indices[z.POSITION].length}write(e,t,i,s){N(t.indices[z.POSITION],t.vertexAttr[z.POSITION].data,e.transformation,i.position,s,6),B(t.indices[z.NORMAL],t.vertexAttr[z.NORMAL].data,e.invTranspTransformation,i.normal,s,6);{const e=t.vertexAttr[z.UV0].data;let r,n,a,o;if(null==e||e.length<4){const e=this.material.params;r=0,n=0,a=e.texCoordScale[0],o=e.texCoordScale[1]}else r=e[0],n=e[1],a=e[2],o=e[3];a=Math.min(1.99999,a+1),o=Math.min(1.99999,o+1);const c=t.indices[z.POSITION].length,l=i.uv0;let f=s;for(let e=0;e<c;++e)l.set(f,0,r),l.set(f,1,n),f+=1,l.set(f,0,a),l.set(f,1,n),f+=1,l.set(f,0,a),l.set(f,1,o),f+=1,l.set(f,0,a),l.set(f,1,o),f+=1,l.set(f,0,r),l.set(f,1,o),f+=1,l.set(f,0,r),l.set(f,1,n),f+=1}L(t.indices[z.COLOR],t.vertexAttr[z.COLOR].data,4,i.color,s,6);{const e=t.indices[z.SIZE],r=t.vertexAttr[z.SIZE].data,n=e.length,a=i.size;let o=s;for(let t=0;t<n;++t){const i=r[2*e[t]],s=r[2*e[t]+1];for(let e=0;e<6;++e)a.set(o,0,i),a.set(o,1,s),o+=1}}t.indices[z.AUXPOS1]&&t.vertexAttr[z.AUXPOS1]&&G(t.indices[z.AUXPOS1],t.vertexAttr[z.AUXPOS1].data,i.auxpos1,s,6),t.indices[z.AUXPOS2]&&t.vertexAttr[z.AUXPOS2]&&G(t.indices[z.AUXPOS2],t.vertexAttr[z.AUXPOS2].data,i.auxpos2,s,6)}}export{F as HUDMaterial};
