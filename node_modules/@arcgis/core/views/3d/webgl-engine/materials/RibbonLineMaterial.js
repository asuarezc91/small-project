/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{isSome as e}from"../../../../core/maybe.js";import t from"../../../../core/Logger.js";import{clamp as i}from"../../../../core/mathUtils.js";import{createRenderScreenPointArray3 as s}from"../../../../core/screenUtils.js";import{c as r}from"../../../../chunks/vec3f64.js";import{s as n,f as a,d as o,a as c,b as l,g as u,l as h,k as p,i as m}from"../../../../chunks/vec3.js";import{c as f}from"../../../../chunks/vec2.js";import{newLayout as d}from"../../support/buffer/InterleavedLayout.js";import{plane as v,lineSegment as g}from"../../support/geometryUtils.js";import{computeAttachmentOriginLines as S}from"../lib/geometryDataUtils.js";import{isTranslationMatrix as O}from"../lib/Util.js";import{isInstanceHidden as b}from"./renderers/utils.js";import E from"../lib/GLMaterial.js";import{Material as T,materialParametersDefaults as I}from"../lib/Material.js";import C from"./VisualVariableMaterialParameters.js";import{ribbonVertexAttributeLocations as A,RibbonLineTechniqueConfiguration as P,RibbonVertexAttributeConstants as R,RibbonLineTechnique as q}from"../shaders/RibbonLineTechnique.js";const y=t.getLogger("esri.views.3d.webgl-engine.materials.RibbonLineMaterial");class U extends T{constructor(e,t){super(t,e,L),this._vertexAttributeLocations=A,this.techniqueConfig=new P,this.layout=this.createLayout()}isClosed(e,t){return B(this.params,e,t)}dispose(){}getPassParameters(){return this.params}getTechniqueConfig(t,i){this.techniqueConfig.output=t;const s=e(this.params.stipplePattern);return this.techniqueConfig.stippleEnabled=s,this.techniqueConfig.stippleIntegerRepeatsEnabled=s&&this.params.stippleIntegerRepeats,this.techniqueConfig.stippleOffColorEnabled=s&&e(this.params.stippleOffColor),this.techniqueConfig.slicePlaneEnabled=this.params.slicePlaneEnabled,this.techniqueConfig.sceneHasOcludees=this.params.sceneHasOcludees,this.techniqueConfig.roundJoins="round"===this.params.join,this.techniqueConfig.roundCaps="round"===this.params.cap,this.techniqueConfig.transparent=this.params.transparent,this.techniqueConfig.polygonOffset=this.params.polygonOffset,this.techniqueConfig.writeDepth=this.params.writeDepth,this.techniqueConfig.vvColor=this.params.vvColorEnabled,this.techniqueConfig.vvOpacity=this.params.vvOpacityEnabled,this.techniqueConfig.vvSize=this.params.vvSizeEnabled,this.techniqueConfig.innerColorEnabled=this.params.innerWidth>0&&e(this.params.innerColor),this.techniqueConfig.falloffEnabled=this.params.falloff>0,this.techniqueConfig.occluder=8===this.params.renderOccluded,this.techniqueConfig.transparencyPassType=i?i.transparencyPassType:3,this.techniqueConfig}intersect(e,t,i,s,r,n,a,o,c){c?this.intersectDrapedLineGeometry(e,s,n,a):this.intersectLineGeometry(e,t,i,s,this.params.width,a)}intersectDrapedLineGeometry(e,t,s,r){if(!t.options.selectionMode)return;const n=e.getAttribute(R.POSITION).data,a=e.getAttribute(R.SIZE);let o=this.params.width;if(this.params.vvSizeEnabled){const t=e.getAttribute(R.SIZEFEATUREATTRIBUTE).data[0];o*=i(this.params.vvSizeOffset[0]+t*this.params.vvSizeFactor[0],this.params.vvSizeMinSize[0],this.params.vvSizeMaxSize[0])}else a&&(o*=a.data[0]);const c=s[0],l=s[1],u=(o/2+4)*e.screenToWorldRatio;let h=Number.MAX_VALUE;for(let e=0;e<n.length-5;e+=3){const t=n[e],s=n[e+1],r=c-t,a=l-s,o=n[e+3]-t,u=n[e+4]-s,p=i((o*r+u*a)/(o*o+u*u),0,1),m=o*p-r,f=u*p-a,d=m*m+f*f;d<h&&(h=d)}h<u*u&&r()}intersectLineGeometry(e,t,s,r,m,d){if(!r.options.selectionMode||b(t))return;if(!O(s))return void y.error("intersection assumes a translation-only matrix");const S=e.data,E=S.getVertexAttr(),T=E[R.POSITION].data;let I=m;if(this.params.vvSizeEnabled){const e=E[R.SIZEFEATUREATTRIBUTE].data[0];I*=i(this.params.vvSizeOffset[0]+e*this.params.vvSizeFactor[0],this.params.vvSizeMinSize[0],this.params.vvSizeMaxSize[0])}else E[R.SIZE]&&(I*=E[R.SIZE].data[0]);const C=r.camera,A=G;f(A,r.point);const P=I*C.pixelRatio/2+4*C.pixelRatio;n($[0],A[0]-P,A[1]+P,0),n($[1],A[0]+P,A[1]+P,0),n($[2],A[0]+P,A[1]-P,0),n($[3],A[0]-P,A[1]-P,0);for(let e=0;e<4;e++)if(!C.unprojectFromRenderScreen($[e],ee[e]))return;v.fromPoints(C.eye,ee[0],ee[1],te),v.fromPoints(C.eye,ee[1],ee[2],ie),v.fromPoints(C.eye,ee[2],ee[3],se),v.fromPoints(C.eye,ee[3],ee[0],re);let q=Number.MAX_VALUE;const U=z(this.params,E,S.indices)?T.length-2:T.length-5;for(let e=0;e<U;e+=3){V[0]=T[e]+s[12],V[1]=T[e+1]+s[13],V[2]=T[e+2]+s[14];const t=(e+3)%T.length;if(M[0]=T[t]+s[12],M[1]=T[t+1]+s[13],M[2]=T[t+2]+s[14],v.signedDistance(te,V)<0&&v.signedDistance(te,M)<0||v.signedDistance(ie,V)<0&&v.signedDistance(ie,M)<0||v.signedDistance(se,V)<0&&v.signedDistance(se,M)<0||v.signedDistance(re,V)<0&&v.signedDistance(re,M)<0)continue;if(C.projectToRenderScreen(V,J),C.projectToRenderScreen(M,_),J[2]<0&&_[2]>0){a(F,V,M);const e=C.frustum,t=-v.signedDistance(e.planes[4],V)/o(F,v.normal(e.planes[4]));c(F,F,t),l(V,V,F),C.projectToRenderScreen(V,J)}else if(J[2]>0&&_[2]<0){a(F,M,V);const e=C.frustum,t=-v.signedDistance(e.planes[4],M)/o(F,v.normal(e.planes[4]));c(F,F,t),l(M,M,F),C.projectToRenderScreen(M,_)}else if(J[2]<0&&_[2]<0)continue;J[2]=0,_[2]=0;const i=g.distance2(g.fromPoints(J,_,W),A);i<q&&(q=i,u(k,V),u(H,M))}const x=r.rayBeginPoint,L=r.rayEndPoint;if(q<P*P){let e=Number.MAX_VALUE;if(g.closestLineSegmentPoint(g.fromPoints(k,H,W),g.fromPoints(x,L,X),Z)){a(Z,Z,x);const t=h(Z);c(Z,Z,1/t),e=t/p(x,L)}d(e,Z)}}computeAttachmentOrigin(e,t){const i=e.data,s="getVertexAttr"in i?i.getVertexAttr():"vertexAttr"in i?i.vertexAttr:null;if(!s)return null;const r=R.POSITION,n="getVertexAttr"in i?i.indices:null,a=s[r];return S(a,n?n[r]:null,n&&z(this.params,s,n),t)}createLayout(){const e=d().vec3f(R.POSITION).f32(R.SUBDIVISIONFACTOR).vec2f(R.UV0).vec3f(R.AUXPOS1).vec3f(R.AUXPOS2);return this.params.vvSizeEnabled?e.f32(R.SIZEFEATUREATTRIBUTE):e.f32(R.SIZE),this.params.vvColorEnabled?e.f32(R.COLORFEATUREATTRIBUTE):e.vec4f(R.COLOR),this.params.vvOpacityEnabled&&e.f32(R.OPACITYFEATUREATTRIBUTE),e}createBufferWriter(){return new j(this.layout,this.params)}getGLMaterial(e){return 0===e.output||7===e.output||4===e.output||1===e.output?new x(e):void 0}validateParameterValues(e){"miter"!==e.join&&(e.miterLimit=0),this.requiresTransparent(e)&&(e.transparent=!0)}requiresTransparent(e){return!!((e.color&&e.color[3])<1||e.innerWidth>0&&this.colorRequiresTransparent(e.innerColor)||e.stipplePattern&&this.colorRequiresTransparent(e.stippleOffColor)||e.falloff>0)}colorRequiresTransparent(t){return e(t)&&t[3]<1&&t[3]>0}}class x extends E{constructor(e){super(e),this.updateParameters()}updateParameters(e){this.technique=this.techniqueRep.acquireAndReleaseExisting(q,this.material.getTechniqueConfig(this.output,e),this.technique)}beginSlot(e){return this.technique.configuration.occluder?3===e||10===e||11===e:0===this.output||7===this.output?(this.targetSlot=this.technique.configuration.writeDepth?5:8,e===this.targetSlot):3===e}_updateOccludeeState(e){e.hasOccludees!==this.material.params.sceneHasOcludees&&this.material.setParameterValues({sceneHasOcludees:e.hasOccludees})}ensureParameters(e){0!==this.output&&7!==this.output||this._updateOccludeeState(e),this.updateParameters(e)}bind(e,t){e.bindProgram(this.technique.program),this.technique.bindPass(e,this.material.getPassParameters(),t)}getPipelineState(e,t){return this.technique.getPipelineState(e,t)}}const L={width:0,color:[1,1,1,1],join:"miter",cap:"butt",miterLimit:5,writeDepth:!0,polygonOffset:!1,stipplePattern:null,stippleIntegerRepeats:!1,stippleOffColor:null,slicePlaneEnabled:!1,vvFastUpdate:!1,transparent:!1,isClosed:!1,falloff:0,innerWidth:0,innerColor:null,sceneHasOcludees:!1,...I,...C.Default};class j{constructor(e,t){switch(this.params=t,this.numJoinSubdivisions=0,this.vertexBufferLayout=e,this.params.join){case"miter":case"bevel":this.numJoinSubdivisions=t.stipplePattern?1:0;break;case"round":this.numJoinSubdivisions=N}}isClosed(e){return z(this.params,e.vertexAttr,e.indices)}numCapSubdivisions(e){if(this.isClosed(e))return 0;switch(this.params.cap){case"butt":return 0;case"square":return 1;case"round":return w}}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){const t=2*this.numCapSubdivisions(e)+2,i=e.indices[R.POSITION].length/2+1,s=this.isClosed(e);let r=s?2:2*t;const n=s?0:1,a=s?i:i-1;if(e.vertexAttr[R.SUBDIVISIONS]){const t=e.vertexAttr[R.SUBDIVISIONS].data;for(let e=n;e<a;++e){r+=4+2*t[e]}}else{r+=(a-n)*(2*this.numJoinSubdivisions+4)}return r+=2,r}write(e,t,i,s){const r=Y,a=K,o=Q,c=t.vertexAttr[R.POSITION].data,l=t.indices&&t.indices[R.POSITION],h=this.numCapSubdivisions(t);l&&l.length!==2*(c.length/3-1)&&console.warn("RibbonLineMaterial does not support indices");let p=null;t.vertexAttr[R.SUBDIVISIONS]&&(p=t.vertexAttr[R.SUBDIVISIONS].data);let f=1,d=0;this.params.vvSizeEnabled?d=t.vertexAttr[R.SIZEFEATUREATTRIBUTE].data[0]:t.vertexAttr[R.SIZE]&&(f=t.vertexAttr[R.SIZE].data[0]);let v=[1,1,1,1],g=0;this.params.vvColorEnabled?g=t.vertexAttr[R.COLORFEATUREATTRIBUTE].data[0]:t.vertexAttr[R.COLOR]&&(v=t.vertexAttr[R.COLOR].data);let S=0;this.params.vvOpacityEnabled&&(S=t.vertexAttr[R.OPACITYFEATUREATTRIBUTE].data[0]);const O=c.length/3,b=e.transformation,E=new Float32Array(i.buffer),T=this.vertexBufferLayout.stride/4;let I=s*T;const C=I,A=(e,t,i,s,r,n,a)=>{if(E[I++]=t[0],E[I++]=t[1],E[I++]=t[2],E[I++]=s,E[I++]=r,E[I++]=n,E[I++]=e[0],E[I++]=e[1],E[I++]=e[2],E[I++]=i[0],E[I++]=i[1],E[I++]=i[2],this.params.vvSizeEnabled?E[I++]=d:E[I++]=f,this.params.vvColorEnabled)E[I++]=g;else{const e=Math.min(4*a,v.length-4);E[I++]=v[e+0],E[I++]=v[e+1],E[I++]=v[e+2],E[I++]=v[e+3]}this.params.vvOpacityEnabled&&(E[I++]=S)};I+=T,n(a,c[0],c[1],c[2]),b&&m(a,a,b);const P=this.isClosed(t);if(P){const e=c.length-3;n(r,c[e],c[e+1],c[e+2]),b&&m(r,r,b)}else{u(r,a),n(o,c[3],c[4],c[5]),b&&m(o,o,b);for(let e=0;e<h;++e){const t=1-e/h;A(r,a,o,t,1,-4,0),A(r,a,o,t,1,4,0)}A(r,a,o,0,0,-4,0),A(r,a,o,0,0,4,0),u(r,a),u(a,o)}const q=P?O:O-1;for(let e=P?0:1;e<q;e++){const t=(e+1)%O*3;n(o,c[t+0],c[t+1],c[t+2]),b&&m(o,o,b),A(r,a,o,0,1,-1,e),A(r,a,o,0,1,1,e);const i=p?p[e]:this.numJoinSubdivisions;for(let t=0;t<i;++t){const s=(t+1)/(i+1);A(r,a,o,s,1,-2,e),A(r,a,o,s,1,2,e)}A(r,a,o,1,0,-2,e),A(r,a,o,1,0,2,e),u(r,a),u(a,o)}if(P){I=D(E,C+T,E,I,2*T)}else{A(r,a,o,0,1,-5,q),A(r,a,o,0,1,5,q);for(let e=0;e<h;++e){const t=(e+1)/h;A(r,a,o,t,1,-5,q),A(r,a,o,t,1,5,q)}}D(E,C+T,E,C,T);I=D(E,I-T,E,I,T)}}function D(e,t,i,s,r){for(let n=0;n<r;n++)i[s++]=e[t++];return s}function z(e,t,i){return B(e,t[R.POSITION].data,i?i[R.POSITION]:null)}function B(e,t,i){return!!e.isClosed&&(i?i.length>2:t.length>6)}const w=3,N=1,V=r(),M=r(),F=r(),Z=r(),G=r(),J=s(),_=s(),k=r(),H=r(),W=g.create(),X=g.create(),Y=r(),K=r(),Q=r(),$=[s(),s(),s(),s()],ee=[r(),r(),r(),r()],te=v.create(),ie=v.create(),se=v.create(),re=v.create();export{U as RibbonLineMaterial};
