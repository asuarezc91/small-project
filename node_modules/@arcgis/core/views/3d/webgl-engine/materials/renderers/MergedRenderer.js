/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{isNone as e,isSome as t}from"../../../../../core/maybe.js";import{m as s,a,b as i}from"../../../../../chunks/mat4.js";import{someMap as r}from"../../../../../core/MapUtils.js";import{a as n}from"../../../../../chunks/mat4f64.js";import{glLayout as o}from"../../../support/buffer/glUtil.js";import{assert as l,setMatrixTranslation3 as d}from"../../lib/Util.js";import h from"../../../../webgl/BufferObject.js";import{getStride as m}from"../../../../webgl/Util.js";import u from"../../../../webgl/VertexArrayObject.js";import{acquireMaterials as c,releaseMaterials as f,calculateTransformRelToOrigin as g}from"./utils.js";import{ResizableFloat32Array as p}from"../../lib/ResizableFloat32Array.js";import{WaterGLMaterial as b}from"../WaterGLMaterial.js";import{Instance as y,sortInstancesAccordingToRange as C,addOrMerge as _}from"./Instance.js";import{addToRenderStats as w}from"../../statistics/RendererPerformanceInfo.js";const v={begin:0,end:0},O=n(),H=n(),B=n();export default class{constructor(e,t,s){this.type="MergedRenderer",this._dataByOrigin=new Map,this._hasHighlights=!1,this._hasOccludees=!1,this._rctx=e,this._material=s,this._materialRep=t,this._glMaterials=c(this._material,this._materialRep),this._bufferWriter=s.createBufferWriter()}dispose(){f(this._material,this._materialRep),this._dataByOrigin&&(this._dataByOrigin.forEach((e=>{e.vao.dispose(!0),e.vao=null})),this._dataByOrigin.clear(),this._dataByOrigin=null),this._glMaterials&&(this._glMaterials.forEach((e=>{e&&e.dispose()})),this._glMaterials.clear(),this._glMaterials=null)}get isEmpty(){return 0===this._dataByOrigin.size}get hasHighlights(){return this._hasHighlights}get hasOccludees(){return this._hasOccludees}get hasWater(){return!this.isEmpty&&r(this._glMaterials,(e=>e instanceof b))}get rendersOccluded(){return!this.isEmpty&&1!==this._material.renderOccluded}modify(e){this.updateGeometries(e.toUpdate),this.addAndRemoveGeometries(e.toAdd,e.toRemove),this.updateRenderCommands()}addAndRemoveGeometries(e,t){const s=this._bufferWriter,a=s.vertexBufferLayout,i=a.stride/4,r=this._dataByOrigin,n=function(e,t,s,a){const i=new Map,r=t.vertexBufferLayout.stride/4,n=(s,a)=>{const n=s.origin,o=e.get(n.id);let l=i.get(n.id);null==l&&(l={optimalCount:null==o?0:o.optimalCount,sparseCount:null==o?0:o.buffer.size,toAdd:[],toRemove:[],origin:n.vec3},i.set(n.id,l));const d=t.elementCount(s.data)*r;a?(l.optimalCount+=d,l.sparseCount+=d,l.toAdd.push(s)):(l.optimalCount-=d,l.toRemove.push(s))};for(const e of s)n(e,!0);for(const e of a)n(e,!1);return i}(r,s,e,t);n.forEach(((e,t)=>{n.delete(t);const s=e.optimalCount,o=e.sparseCount;let h=r.get(t);if(null==h)l(s>0),h=this.createData(a,s,e.origin),r.set(t,h);else if(0===s)return h.vao.dispose(!0),h.vao=null,void r.delete(t);const m=s<e.sparseCount/2,u=m?s:o,c=v,f=h.buffer.size,g=h.buffer.array,p=h.buffer.resize(u,!1);m||p?this.removeAndRebuild(h,e.toRemove,i,g,c):e.toRemove.length>0?(this.removeByErasing(h,e.toRemove,i,c),e.toAdd.length>0&&(c.end=f)):(c.begin=f,c.end=f);const b=O;d(b,-e.origin[0],-e.origin[1],-e.origin[2]),this.append(h,e.toAdd,i,b,c);const y=h.vao.vertexBuffers.geometry;if(y.byteSize!==h.buffer.array.buffer.byteLength)y.setData(h.buffer.array);else{const{begin:e,end:t}=c;if(e<t){const s=h.buffer.array,a=4,i=e*a,r=t*a;y.setSubData(s,i,i,r)}}h.drawCommandsDirty=!0}))}updateGeometries(e){const t=this._bufferWriter,s=t.vertexBufferLayout.stride/4;for(const a of e){const e=a.updateType,i=a.renderGeometry,r=this._dataByOrigin.get(i.origin.id),n=r&&r.instances.get(i.uniqueName);if(!n)return;if(1&e&&(n.isVisible=i.instanceParameters.visible),9&e){const e=i.instanceParameters.visible;n.hasHighlights=!!i.instanceParameters.highlights&&e}if(16&e&&(n.hasOccludees=!!i.instanceParameters.occludees),6&e){const e=r.buffer.array,a=r.vao;g(i,H,B),t.write({transformation:H,invTranspTransformation:B},i.data,t.vertexBufferLayout.createView(e.buffer),n.from),l(n.from+t.elementCount(i.data)===n.to,"material VBO layout has changed"),a.vertexBuffers.geometry.setSubData(e,n.from*s*4,n.from*s*4,n.to*s*4)}r.drawCommandsDirty=!0}}updateRenderCommands(){this._hasHighlights=!1,this._hasOccludees=!1,this._dataByOrigin.forEach((e=>{e.hasHiddenInstances=!1,e.hasHighlights=!1,e.hasOccludees=!1,r(e.instances,(t=>(t.isVisible?(t.hasHighlights&&(this._hasHighlights=!0,e.hasHighlights=!0),t.hasOccludees&&(this._hasOccludees=!0,e.hasOccludees=!0)):e.hasHiddenInstances=!0,e.hasHiddenInstances&&e.hasHighlights&&e.hasOccludees)))}));this._dataByOrigin.forEach((e=>{e.drawCommandsDirty&&((e=>{if(e.drawCommandsDefault=null,e.drawCommandsHighlight=null,e.drawCommandsOccludees=null,e.stats={default:0,highlight:0,occludees:0},0===e.instances.size)return;if(!(e.hasOccludees||e.hasHighlights||e.hasHiddenInstances)){const t=4*e.buffer.size/m(e.vao.layout.geometry);return e.drawCommandsDefault=[{first:0,count:t}],void(e.stats={default:t,highlight:0,occludees:0})}const t=C([...e.instances.values()]);e.drawCommandsDefault=[],e.drawCommandsHighlight=[],e.drawCommandsOccludees=[];for(const s of t)s.isVisible&&(s.hasOccludees?_(e.drawCommandsOccludees,s):_(e.drawCommandsDefault,s),s.hasHighlights&&_(e.drawCommandsHighlight,s));const s=e=>{let t=0;for(const s of e)t+=s.count;return t/3};e.stats={default:s(e.drawCommandsDefault),highlight:s(e.drawCommandsHighlight),occludees:s(e.drawCommandsOccludees)}})(e),e.drawCommandsDirty=!1)}))}updateLogic(e){return this._material.update(e)}render(s,a,i,r){const n=this._rctx,o=this._glMaterials.get(a.pass),l=5===a.pass;let d=s;if(3===a.pass&&null===d&&(d=22),!o||2!==o.ensureResources(n)||null!=d&&!o.beginSlot(d)||l&&!this._hasHighlights)return!1;o.ensureParameters(i);const h=o.getTechnique(),m=o.getPipelineState(d,!1);n.setPipelineState(m),o.bind(n,i);let u=!1;return this._dataByOrigin.forEach((s=>{if(e(s.drawCommandsDefault)&&e(s.drawCommandsHighlight)&&e(s.drawCommandsOccludees))return;if(l&&!s.hasHighlights)return;i.origin=s.origin,h.bindDraw(i),h.ensureAttributeLocations(s.vao),n.bindVAO(s.vao);const a=h.primitiveType;let c=l?s.drawCommandsHighlight:s.drawCommandsDefault;const f=l?s.stats.highlight:s.stats.default;if(t(c)&&(this.renderCommands(n,a,c),w(c.length,f,r),u=!0),!l&&(c=s.drawCommandsOccludees,t(c))){const e=o.getPipelineState(d,!0);n.setPipelineState(e),this.renderCommands(n,a,c),n.setPipelineState(m),w(c.length,s.stats.occludees,r),u=!0}})),u}renderCommands(e,t,s){for(let a=0;a<s.length;a++)e.drawArrays(t,s[a].first,s[a].count)}createData(e,t,s){return{instances:new Map,vao:new u(this._rctx,this._material.vertexAttributeLocations,{geometry:o(e)},{geometry:h.createVertex(this._rctx,35044)}),buffer:new p(t),optimalCount:0,origin:s,hasHiddenInstances:!1,hasHighlights:!1,hasOccludees:!1,drawCommandsDirty:!1,drawCommandsDefault:null,drawCommandsOccludees:null,drawCommandsHighlight:null,stats:{default:0,highlight:0,occludees:0}}}removeAndRebuild(e,t,s,a,i){for(const a of t){const t=a.uniqueName,i=e.instances.get(t);e.optimalCount-=(i.to-i.from)*s,e.instances.delete(t)}let r=0;const n=e.buffer.array;i.begin=0,i.end=0;let o=-1,l=-1,d=0;e.instances.forEach((e=>{const t=e.from*s,i=e.to*s,h=i-t;o!==l&&l!==t?(n.set(a.subarray(o,l),d),d+=l-o,o=t):-1===o&&(o=t),l=i,e.from=r/s,r+=h,e.to=r/s})),o!==l&&n.set(a.subarray(o,l),d),i.end=r}removeByErasing(e,t,s,a){a.begin=1/0,a.end=-1/0;let i=-1,r=-1;for(const n of t){const t=n.uniqueName,o=e.instances.get(t),l=o.from*s,d=o.to*s;i!==r&&r!==l?(e.buffer.erase(i,r),i=l):-1===i&&(i=l),r=d,e.instances.delete(t),e.optimalCount-=d-l,l<a.begin&&(a.begin=l),d>a.end&&(a.end=d)}i!==r&&e.buffer.erase(i,r)}append(e,r,n,o,d){const h=this._bufferWriter;for(const m of r){const r=t(m.transformation)?s(H,o,m.transformation):o;a(B,r),i(B,B);const u=d.end;h.write({transformation:r,invTranspTransformation:B},m.data,h.vertexBufferLayout.createView(e.buffer.array.buffer),d.end/n);const c=h.elementCount(m.data)*n,f=u+c;l(null==e.instances.get(m.uniqueName));const g=m.instanceParameters.visible,p=!!m.instanceParameters.highlights&&g,b=!!m.instanceParameters.occludees,C=new y(u/n,f/n,g,p,b);e.instances.set(m.uniqueName,C),e.optimalCount+=c,d.end+=c}}get test(){return{material:this._material,glMaterials:this._glMaterials}}}
