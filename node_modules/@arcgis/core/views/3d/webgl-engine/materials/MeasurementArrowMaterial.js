/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{c as e}from"../../../../chunks/vec3f64.js";import{s as t,n as s,f as r,c as i,k as n,i as o}from"../../../../chunks/vec3.js";import{newLayout as a}from"../../support/buffer/InterleavedLayout.js";import{VertexAttrConstants as c}from"../lib/Util.js";import u from"../lib/GLMaterial.js";import{Material as f,materialParametersDefaults as l}from"../lib/Material.js";import{MeasurementArrowTechniqueConfiguration as h,MeasurementArrowTechnique as p}from"../shaders/MeasurementArrowTechnique.js";class m extends f{constructor(e,t){super(t,e,g),this.techniqueConfig=new h}getTechniqueConfig(){return this.techniqueConfig.polygonOffsetEnabled=this.params.polygonOffset,this.techniqueConfig}dispose(){}getPassParameters(){return this.params}intersect(){}createBufferWriter(){return new C}getGLMaterial(e){return 0===e.output?new d(e):void 0}}class d extends u{constructor(e){super(e),this.updateParameters()}updateParameters(){this.technique=this.techniqueRep.acquireAndReleaseExisting(p,this.material.getTechniqueConfig(),this.technique)}beginSlot(e){return 3===e}bind(e,t){e.bindProgram(this.technique.program),this.technique.bindPass(e,this.material.getPassParameters(),t)}}const g={width:32,outlineSize:.2,outlineColor:[1,.5,0,1],stripeLength:1,stripeEvenColor:[1,1,1,1],stripeOddColor:[1,.5,0,1],polygonOffset:!1,...l},v=a().vec3f(c.POSITION).vec3f(c.NORMAL).vec2f(c.UV0).f32(c.AUXPOS1),O=e(),q=e(),P=e(),b=e(),x=e();class C{constructor(){this.vertexBufferLayout=v}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return 2*(e.indices[c.POSITION].length/2+1)}write(e,a,u,f){const l=a.vertexAttr[c.POSITION].data,h=a.vertexAttr[c.NORMAL].data,p=l.length/3,m=a&&a.indices&&a.indices.position;m&&m.length!==2*(p-1)&&console.warn("MeasurementArrowMaterial does not support indices");const d=O,g=q,v=P,C=b,w=x,A=e.transformation,L=e.invTranspTransformation,M=u.position,T=u.normal,j=u.uv0;let I=0;for(let e=0;e<p;++e){const a=3*e;if(t(d,l[a],l[a+1],l[a+2]),e<p-1){const n=3*(e+1);t(g,l[n],l[n+1],l[n+2]),t(w,h[n],h[n+1],h[n+2]),s(w,w),r(v,g,d),s(v,v),i(C,w,v),s(C,C)}const c=n(d,g);A&&L&&(o(d,d,A),o(g,g,A),o(C,C,L));const u=f+2*e,m=u+1;M.setVec(u,d),M.setVec(m,d),T.setVec(u,C),T.setVec(m,C),j.set(u,0,I),j.set(u,1,-1),j.set(m,0,I),j.set(m,1,1),e<p-1&&(I+=c)}const y=u.auxpos1;for(let e=0;e<2*p;++e)y.set(f+e,I)}}export{m as MeasurementArrowMaterial};
