/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{f as e}from"../../../../chunks/vec2f32.js";import{newLayout as t}from"../../support/buffer/InterleavedLayout.js";import{VertexAttrConstants as i}from"../lib/Util.js";import r from"../lib/GLMaterial.js";import{Material as s,materialParametersDefaults as n}from"../lib/Material.js";import{writePosition as a,writeNormal as u,writeBufferVec4 as c}from"./internal/bufferWriterUtils.js";import{LineCalloutTechniqueConfiguration as o,LineCalloutTechnique as h}from"../shaders/LineCalloutTechnique.js";class l extends s{constructor(e,t){super(t,e,d),this.techniqueConfig=new o,this._uniqueMaterialIdentifier=l.uniqueMaterialIdentifier(this.params)}get uniqueMaterialIdentifier(){return this._uniqueMaterialIdentifier}dispose(){}getGLMaterial(e){return 0===e.output?new f(e):void 0}getPassParameters(){return this.params}getTechniqueConfig(e){return this.techniqueConfig.occlusionTestEnabled=this.params.occlusionTest,this.techniqueConfig.verticalOffset=!!this.params.verticalOffset,this.techniqueConfig.screenSizePerspective=!!this.params.screenSizePerspective,this.techniqueConfig.depthHudEnabled=e,this.techniqueConfig.depthHudAlignStartEnabled=!!this.params.depthHUDAlignStart,this.techniqueConfig.screenCenterOffsetUnitsEnabled="screen"===this.params.centerOffsetUnits?1:0,this.techniqueConfig.slicePlaneEnabled=this.params.slicePlaneEnabled,this.techniqueConfig}intersect(){}createBufferWriter(){return new g}validateParameterValues(e){const t=l.uniqueMaterialIdentifier(e);t!==this._uniqueMaterialIdentifier&&(this._uniqueMaterialIdentifier=t)}static uniqueMaterialIdentifier(e){return JSON.stringify({screenOffset:e.screenOffset||[0,0],centerOffsetUnits:e.centerOffsetUnits||"world"})}}class f extends r{constructor(e){super(e),this.isRenderSlot=!0,this.updateParameters()}updateParameters(){this.technique=this.techniqueRep.acquireAndReleaseExisting(h,this.material.getTechniqueConfig(!1),this.technique),this.depthTechnique=this.techniqueRep.acquireAndReleaseExisting(h,this.material.getTechniqueConfig(!0),this.depthTechnique)}beginSlot(e){switch(e){case 20:return this.isRenderSlot=!0,!0;case 21:return this.isRenderSlot=!1,!0}return!1}getTechnique(){return this.isRenderSlot?this.technique:this.depthTechnique}bind(e,t){const i=this.getTechnique();e.bindProgram(i.program),i.bindPass(e,this.material.getPassParameters(),t)}}const d={verticalOffset:null,screenSizePerspective:null,screenOffset:[0,0],color:[0,0,0,1],size:1,borderColor:null,occlusionTest:!1,shaderPolygonOffset:1e-5,depthHUDAlignStart:!1,centerOffsetUnits:"world",slicePlaneEnabled:!1,...n},p=t().vec3f(i.POSITION).vec3f(i.NORMAL).vec2f(i.UV0).vec4f(i.AUXPOS1),m=[e(0,0),e(1,0),e(0,1),e(1,0),e(1,1),e(0,1)];class g{constructor(){this.vertexBufferLayout=p}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return 6*e.indices[i.POSITION].length}write(e,t,r,s){a(t.indices[i.POSITION],t.vertexAttr[i.POSITION].data,e.transformation,r.position,s,6),u(t.indices[i.NORMAL],t.vertexAttr[i.NORMAL].data,e.invTranspTransformation,r.normal,s,6),c(t.indices[i.AUXPOS1],t.vertexAttr[i.AUXPOS1].data,r.auxpos1,s,6);for(let e=0;e<m.length;++e)r.uv0.setVec(s+e,m[e])}}export{l as LineCalloutMaterial};
