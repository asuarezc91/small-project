/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{isSome as e,isNone as t}from"../../../../core/maybe.js";import r from"../../../../core/Logger.js";import{createRenderScreenPointArray3 as s}from"../../../../core/screenUtils.js";import{c as i}from"../../../../chunks/vec3f64.js";import{s as n,f as a,d as o,a as c,b as l,g as u,l as p,k as m}from"../../../../chunks/vec3.js";import{c as f}from"../../../../chunks/vec2.js";import{BufferViewVec3f as h}from"../../support/buffer/BufferView.js";import{plane as d,lineSegment as g}from"../../support/geometryUtils.js";import{computeAttachmentOriginLines as P}from"../lib/geometryDataUtils.js";import{isTranslationMatrix as O,VertexAttrConstants as j}from"../lib/Util.js";import{isInstanceHidden as b}from"./renderers/utils.js";import q from"../lib/GLMaterial.js";import{intersectDrapedRenderLineGeometry as v}from"./internal/MaterialUtil.js";import{Material as x,materialParametersDefaults as C}from"../lib/Material.js";import{writeDefaultAttributes as S}from"./internal/bufferWriterUtils.js";import{PositionColorLayout as y,PositionLayout as A,DefaultBufferWriter as L}from"./internal/DefaultBufferWriter.js";import{NativeLineTechniqueConfiguration as T,NativeLineTechnique as w}from"../shaders/NativeLineTechnique.js";const D=r.getLogger("esri.views.3d.webgl-engine.materials.NativeLineMaterial");class I extends x{constructor(e,t){super(t,e,R),this.techniqueConfig=new T}getTechniqueConfig(t){this.techniqueConfig.output=t,this.techniqueConfig.slicePlaneEnabled=this.params.slicePlaneEnabled,this.techniqueConfig.vertexColors=this.params.vertexColors,this.techniqueConfig.transparent=this.params.color[3]<1||this.params.width<1;const r=e(this.params.stipplePattern);return this.techniqueConfig.stippleEnabled=r,this.techniqueConfig.stippleOffColorEnabled=r&&e(this.params.stippleOffColor),this.techniqueConfig.stippleIntegerRepeatsEnabled=r&&this.params.stippleIntegerRepeats,this.techniqueConfig.sceneHasOcludees=this.params.sceneHasOcludees,this.techniqueConfig}getPassParameters(){return this.params}intersect(e,t,r,s,i,n,a,o,c){c?v(e,s,n,1,a):this.intersectLineGeometry(e,t,r,s,a)}intersectLineGeometry(e,t,r,s,i){if(!s.options.selectionMode||b(t))return;if(!O(r))return void D.error("intersection assumes a translation-only matrix");const h=e.data.getVertexAttr().position.data,P=s.camera,j=F;f(j,s.point);n(z[0],j[0]-2,j[1]+2,0),n(z[1],j[0]+2,j[1]+2,0),n(z[2],j[0]+2,j[1]-2,0),n(z[3],j[0]-2,j[1]-2,0);for(let e=0;e<4;e++)if(!P.unprojectFromRenderScreen(z[e],J[e]))return;d.fromPoints(P.eye,J[0],J[1],K),d.fromPoints(P.eye,J[1],J[2],Q),d.fromPoints(P.eye,J[2],J[3],Y),d.fromPoints(P.eye,J[3],J[0],Z);let q=Number.MAX_VALUE;for(let e=0;e<h.length-5;e+=3){if(U[0]=h[e]+r[12],U[1]=h[e+1]+r[13],U[2]=h[e+2]+r[14],M[0]=h[e+3]+r[12],M[1]=h[e+4]+r[13],M[2]=h[e+5]+r[14],d.signedDistance(K,U)<0&&d.signedDistance(K,M)<0||d.signedDistance(Q,U)<0&&d.signedDistance(Q,M)<0||d.signedDistance(Y,U)<0&&d.signedDistance(Y,M)<0||d.signedDistance(Z,U)<0&&d.signedDistance(Z,M)<0)continue;if(P.projectToRenderScreen(U,H),P.projectToRenderScreen(M,k),H[2]<0&&k[2]>0){a(N,U,M);const e=P.frustum,t=-d.signedDistance(e.planes[4],U)/o(N,d.normal(e.planes[4]));c(N,N,t),l(U,U,N),P.projectToRenderScreen(U,H)}else if(H[2]>0&&k[2]<0){a(N,M,U);const e=P.frustum,t=-d.signedDistance(e.planes[4],M)/o(N,d.normal(e.planes[4]));c(N,N,t),l(M,M,N),P.projectToRenderScreen(M,k)}else if(H[2]<0&&k[2]<0)continue;H[2]=0,k[2]=0;const t=g.distance2(g.fromPoints(H,k,_),j);t<q&&(q=t,u(G,U),u(X,M))}const v=s.rayBeginPoint,x=s.rayEndPoint;if(q<4){let e=Number.MAX_VALUE;if(g.closestLineSegmentPoint(g.fromPoints(G,X,_),g.fromPoints(v,x,W),V)){a(V,V,v);const t=p(V);c(V,V,1/t),e=t/m(v,x)}i(e,V)}}computeAttachmentOrigin(e,t){const r=e.data,s="getVertexAttr"in r?r.getVertexAttr():"vertexAttr"in r?r.vertexAttr:null;if(!s)return null;const i=s[j.POSITION];return P(i,null,!1,t)}createBufferWriter(){const e=this.params.vertexColors?y:A;return t(this.params.stipplePattern)?new L(e):new E(e.clone().vec3f(j.AUXPOS1))}getGLMaterial(e){return 0===e.output||4===e.output?new B(e):void 0}}class B extends q{constructor(e){super(e),this.updateParameters()}updateParameters(){this.technique=this.techniqueRep.acquireAndReleaseExisting(w,this.material.getTechniqueConfig(this.output),this.technique)}beginSlot(e){return 3===e}_updateOccludeeState(e){e.hasOccludees!==this.material.params.sceneHasOcludees&&(this.material.setParameterValues({sceneHasOcludees:e.hasOccludees}),this.updateParameters())}ensureParameters(e){0===this.output&&this._updateOccludeeState(e)}bind(e,t){e.bindProgram(this.technique.program),this.technique.bindPass(e,this.material.getPassParameters(),t)}getPipelineState(e,t){return this.technique.getPipelineState(t)}}class E{constructor(e){this.vertexBufferLayout=e}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return e.indices[j.POSITION].length}write(e,t,r,s){S(t,this.vertexBufferLayout,e.transformation,e.invTranspTransformation,r,s),this.writeAuxpos1(e,t,r,s)}writeAuxpos1(e,t,r,s){const i=r.getField(j.AUXPOS1,h),n=t.indices[j.POSITION],a=t.vertexAttr[j.POSITION].data,o=e.transformation,c=i.typedBufferStride,l=i.typedBuffer;s*=c;for(let e=0;e<n.length;e+=2){const t=3*n[e],r=a[t],i=a[t+1],u=a[t+2],p=o[0]*r+o[4]*i+o[8]*u+o[12],m=o[1]*r+o[5]*i+o[9]*u+o[13],f=o[2]*r+o[6]*i+o[10]*u+o[14];for(let e=0;e<2;++e)l[s]=p,l[s+1]=m,l[s+2]=f,s+=c}}}const R={color:[1,1,1,1],vertexColors:!1,slicePlaneEnabled:!1,width:1,stipplePattern:null,stippleIntegerRepeats:!1,stippleOffColor:null,sceneHasOcludees:!1,...C},U=i(),M=i(),N=i(),V=i(),H=s(),k=s(),G=i(),X=i(),_=g.create(),W=g.create(),F=i(),z=[s(),s(),s(),s()],J=[i(),i(),i(),i()],K=d.create(),Q=d.create(),Y=d.create(),Z=d.create();export{I as NativeLineMaterial};
