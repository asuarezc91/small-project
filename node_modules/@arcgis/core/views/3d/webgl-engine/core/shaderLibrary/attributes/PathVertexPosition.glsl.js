/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{glsl as e}from"../../shaderModules/interfaces.js";import{PositionAttribute as o}from"./PositionAttribute.glsl.js";function i(i,r){i.attributes.add("featureValue","vec4"),i.vertex.code.add(e`
  bool isCapVertex() {
    return featureValue.w == 1.0;
  }
  `),i.vertex.uniforms.add("size","vec3"),r.vvSize?(i.vertex.uniforms.add("vvSizeMinSize","vec3"),i.vertex.uniforms.add("vvSizeMaxSize","vec3"),i.vertex.uniforms.add("vvSizeOffset","vec3"),i.vertex.uniforms.add("vvSizeFactor","vec3"),i.vertex.code.add(e`
    vec2 getSize() {
      return size.xy*clamp(vvSizeOffset + featureValue.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).xz;
    }
    `)):i.vertex.code.add(e`
    vec2 getSize(){
      return size.xy;
    }
    `),r.vvOpacity?(i.vertex.defines.addInt("VV_OPACITY_N",8),i.vertex.code.add(e`
    uniform float vvOpacityValues[VV_OPACITY_N];
    uniform float vvOpacityOpacities[VV_OPACITY_N];

    vec4 applyOpacity(vec4 color) {
      float value = featureValue.z;
      if (value <= vvOpacityValues[0]) {
        return vec4( color.xyz, vvOpacityOpacities[0]);
      }

      for (int i = 1; i < VV_OPACITY_N; ++i) {
        if (vvOpacityValues[i] >= value) {
          float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);
          return vec4( color.xyz, mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f));
        }
      }

      return vec4( color.xyz, vvOpacityOpacities[VV_OPACITY_N - 1]);
    }
    `)):i.vertex.code.add(e`
    vec4 applyOpacity(vec4 color){
      return color;
    }
    `),r.vvColor?(i.vertex.defines.addInt("VV_COLOR_N",8),i.vertex.code.add(e`
    uniform float vvColorValues[VV_COLOR_N];
    uniform vec4 vvColorColors[VV_COLOR_N];

    vec4 getColor() {
      float value = featureValue.y;
      if (value <= vvColorValues[0]) {
        return applyOpacity(vvColorColors[0]);
      }

      for (int i = 1; i < VV_COLOR_N; ++i) {
        if (vvColorValues[i] >= value) {
          float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);
          return applyOpacity(mix(vvColorColors[i-1], vvColorColors[i], f));
        }
      }

      return applyOpacity(vvColorColors[VV_COLOR_N - 1]);
    }
    `)):i.vertex.code.add(e`
    vec4 getColor(){
      return applyOpacity(vec4(1, 1, 1, 1));
    }
    `),i.include(o),i.attributes.add("profileRight","vec4"),i.attributes.add("profileUp","vec4"),i.attributes.add("profileVertexAndNormal","vec4"),i.vertex.code.add(e`
  vec3 calculateVPos() {
    vec2 size = getSize();
    vec3 origin = position;
    vec3 right = profileRight.xyz;
    vec3 up = profileUp.xyz;
    vec3 forward = cross(up, right);
    vec2 profileVertex = profileVertexAndNormal.xy * size;
    vec2 profileNormal = profileVertexAndNormal.zw;
    float positionOffsetAlongProfilePlaneNormal = 0.0;
    float normalOffsetAlongProfilePlaneNormal = 0.0;
    `),i.vertex.code.add(e`
    if(!isCapVertex()) {
      vec2 rotationRight = vec2(profileRight.w, profileUp.w);
      float maxDistance = length(rotationRight);
  `),i.vertex.code.add(e`
      rotationRight = maxDistance > 0.0 ? normalize(rotationRight) : vec2(0, 0);

      // decompose vertex into rotationRight and rotationUp
      // limit rotation right component to maxDistance
      // and reassemble profile vertex from rotationRight and rotationUp
      float rx = dot(profileVertex, rotationRight);
      if (abs(rx) > maxDistance) {
        // NB: we do the tangent by x=-y and y=x
        vec2 rotationUp = vec2(-rotationRight.y, rotationRight.x);
        float ry = dot(profileVertex, rotationUp);
        profileVertex = rotationRight * maxDistance * sign(rx) + rotationUp * ry;
      }
    }else{
       positionOffsetAlongProfilePlaneNormal = profileRight.w * size[0];
       normalOffsetAlongProfilePlaneNormal = profileUp.w;
    }

    vec3 offset = right * profileVertex.x + up * profileVertex.y + forward * positionOffsetAlongProfilePlaneNormal;

    return origin + offset; // localPosition
  }
  `),i.vertex.code.add(e`
  vec3 localNormal() {
    vec3 right = profileRight.xyz;
    vec3 up = profileUp.xyz;
    vec3 forward = cross(up, right);
    vec2 profileNormal = profileVertexAndNormal.zw;

    vec3 normal = right * profileNormal.x + up * profileNormal.y;

    if(isCapVertex()) {
      normal += forward * profileUp.w;
    }

    return normal;
  }
  `)}function r(e,o){o.vvSizeEnabled&&(e.setUniform3fv("vvSizeMinSize",o.vvSizeMinSize),e.setUniform3fv("vvSizeMaxSize",o.vvSizeMaxSize),e.setUniform3fv("vvSizeOffset",o.vvSizeOffset),e.setUniform3fv("vvSizeFactor",o.vvSizeFactor)),o.vvColorEnabled&&(e.setUniform1fv("vvColorValues",o.vvColorValues),e.setUniform4fv("vvColorColors",o.vvColorColors)),o.vvOpacityEnabled&&(e.setUniform1fv("vvOpacityValues",o.vvOpacityValues),e.setUniform1fv("vvOpacityOpacities",o.vvOpacityOpacities))}export{i as PathVertexPosition,r as setVVUniforms};
