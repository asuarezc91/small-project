/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{isSome as e,isNone as t,applySome as o,unwrap as r}from"../../../../../core/maybe.js";import n from"../../../../../core/Logger.js";import{c as i}from"../../../../../chunks/vec3f64.js";import{h as s,r as a,t as c,g as m}from"../../../../../chunks/vec3.js";import{d as l,t as p,e as h}from"../../../../../chunks/mat3.js";import{c as f}from"../../../../../chunks/vec4.js";import{a as u,c as g}from"../../../../../chunks/mat3f32.js";import{glLayout as d}from"../../../support/buffer/glUtil.js";import{newLayout as b}from"../../../support/buffer/InterleavedLayout.js";import{assert as y}from"../../lib/Util.js";import C from"../../../../webgl/BufferObject.js";import j from"../../../../webgl/VertexArrayObject.js";import{encodeSymbolColor as w}from"../../../layers/support/symbolColorUtils.js";import{c as M}from"../../../../../chunks/vec4f32.js";import{clone as x}from"../../../support/orientedBoundingBox.js";import _ from"./ComponentData.js";import{VISIBLE_BIT as S,isVaryingComponentParameters as v}from"./interface.js";import{BucketedObjectStore as D}from"../../core/util/BucketedObjectStore.js";import P from"./ComponentObject.js";import{getVisibility as k,updateVisibilityWithCount as O}from"../../lib/ComponentUtils.js";import B from"./IntersectionGeometry.js";import G from"./Renderable.js";import I from"./RenderGeometry.js";import{RenderSubmitSystem as U}from"./RenderSubmitSystem.js";import{createVertexBufferLayout as A}from"./SourceGeometry.js";import{ComponentDrawParameters as R}from"./Material/ComponentTechnique.js";import{ComponentParametersVarying as T,ComponentParametersUniform as E,ComponentMaterial as V}from"./Material/ComponentMaterial.js";import{TwoVectorPosition as L}from"../../core/util/TwoVectorPosition.js";import{BufferManager as q}from"../../lib/TextureBackedBuffer/BufferManager.js";const F=n.getLogger("esri.views.3d.webgl-engine.collections.Component.ComponentObjectCollection");class H{constructor(e){this._renderManager=e,this._objects=new D,this._renderSubmit=new U(this),this._renderManager.register(this._renderSubmit),this._componentBufferManager=new q(e.rctx)}dispose(){y(0===this._objects.count,"ObjectCollection should be empty upon disposal"),this._componentBufferManager.destroy()}createObject(e){const t=new P;return t.toMapSpace=e.toMapSpace.slice(),t.transform=e.transform,t.obb=x(e.obb),t.components=new _(this._componentBufferManager,e.geometry.componentOffsets),t.renderable=this._createRenderable(e,t.components),t.intersectionGeometry=new B(e.geometry.positionData,t.components),this._objects.add(e.visible?S:0,t),t}destroyObject(e){const t=e;this._objects.remove(t),t.dispose(),this._notifyDirty()}setObjectVisibility(e,t){const o=e;if(t!==o.visible){const e=t?o.bucketKey|S:o.bucketKey&~S;this._objects.updateKey(o,e),this._notifyDirty()}}preSubmit(e){const t=e.camera.eye;this._objects.forEach(((e,o)=>{o&S&&e.forEach((e=>{const o=s(t,e.obb.center);e.renderable.meta.cameraDepthSquared=o}))}))}getMaterial(e){return e.renderable.material}updateMaterial(e,t){const o=e.renderable.material;t(o),o.dirty&&this._notifyDirty()}setAllComponentVisibilities(e,t){const o=e;o.components.visibility.reset(t),o.components.visibilityDirty(),this._notifyDirty()}forEachVisibleComponent(e,t){return e.components.visibility.forEachComponent(t)}getComponentCount(e){const t=e,o=t.components.visibility.componentCount();return{visible:o,invisible:t.components.count-o}}setComponentData(e,t){const o=e,r=o.renderable.material;if(v(t)){const e=o.components,n=e.materialDataBuffer,i=e.materialDataIndices,s={castShadows:!0,pickable:!0,externalColor:M(),externalColorMixMode:1},a=n.textureBuffer,c=new Uint8Array(4),m=new Uint32Array(c.buffer);let l=0,p=0,h=0,f=!1,u=0;for(let o=0;o<e.count;o++)t(o,s),l+=+(s.externalColor[3]<1),p+=+(3===s.externalColorMixMode&&1===s.externalColor[3]),h+=+s.castShadows,w(s.externalColor,s.externalColorMixMode,c),c[2]=254&c[2]|+s.castShadows,a.setData(i[o],0,c[0],c[1],c[2],c[3]),f=f||o>0&&u!==m[0],u=m[0],s.pickable!==k(e.pickability,o)&&(e.pickability=O(e.pickability,e.count,o,s.pickable));f?(r.componentParameters=new T,r.componentParameters.castShadows=K(h,e.count),r.componentParameters.transparent=K(l,e.count),r.componentParameters.opaqueOverride=K(p,e.count),r.componentParameters.texture=a,a.updateTexture()):(r.componentParameters=new E,r.componentParameters.castShadows=s.castShadows?0:2,r.componentParameters.externalColor=s.externalColor,r.componentParameters.externalColorMixMode=s.externalColorMixMode)}else r.componentParameters=new E,r.componentParameters.castShadows=t.castShadows?0:2,r.componentParameters.externalColor=t.externalColor,r.componentParameters.externalColorMixMode=t.externalColorMixMode;this._notifyDirty()}getComponentAabb(e,t,o){return e.intersectionGeometry.getComponentAabb(t,o)}getComponentObb(e){return e.obb}getObjectTransform(e){return e.transform}getComponentPositions(e,t,o){return e.intersectionGeometry.getComponentPositions(t,o)}intersect(t,o,r,n,i,s){const m=t;e(i)&&(i.localOrigin=m.transform.position);const h=l(N,m.transform.rotationScale);a(J,o,m.transform.position),a(Q,r,m.transform.position),c(J,J,h),c(Q,Q,h);const f=p(N,h);return m.intersectionGeometry.intersect(J,Q,n,f,i,s)}addEdges(e,t,o,r){const n=e,{indices:i,positions:s}=n.intersectionGeometry,a=n.components.offsets;return t.addComponentObject(e,n.transform,n.obb.center,s,i,a,o,r)}addComponentHighlight(e,o){const r=e.components;t(r.highlightCounts)&&(r.highlightCounts=new Uint32Array(r.count+1));0===r.highlightCounts[o]++&&(r.highlightsDirty(),this._notifyDirty()),r.highlightCounts[r.count]++}removeComponentHighlight(e,o){const r=e.components;if(t(r.highlightCounts))return void F.warn("Removing non-existing highlight.");const n=r.highlightCounts[o],i=r.highlightCounts[r.count];if(0!==n){if(n>1)return r.highlightCounts[o]=n-1,void(r.highlightCounts[r.count]=i-1);r.highlightCounts[o]=0,r.highlightsDirty(),this._notifyDirty(),1===i?r.highlightCounts=null:r.highlightCounts[r.count]=i-1}else F.warn("Removing non-existing highlight.")}clearHighlights(t){const o=t.components;e(o.highlightCounts)&&(o.highlightCounts=null,o.highlightsDirty(),this._notifyDirty())}getObjectGPUMemoryUsage(e){return e.renderable.meta.gpuMemoryEstimate}get visibleObjects(){return this._objects.getBucket(S)}get performanceInfo(){const e=this._objects.getPerformanceInfo(S);return{shown:e.added,hidden:e.removed}}_createRenderable(t,n){const i=this._renderManager.rctx,s=t.geometry,a=s.vertices.layoutParameters,c=C.createVertex(i,35044,s.vertices.data),g=o(s.indices,(e=>C.createIndex(i,35044,e))),b=d(A(a)),y=new Uint16Array(s.vertices.count);for(let t=0;t<n.count;t++){const o=n.offsets[t],r=n.offsets[t+1],i=n.materialDataIndices[t];if(e(s.indices))for(let e=o;e<r;e++){y[s.indices[e]]=i}else for(let e=o;e<r;e++)y[e]=i}const w=C.createVertex(i,35044,y.buffer),M=new L(t.transform.position),x=u(t.transform.rotationScale);l(x,x),p(x,x);const _=new R;m(_.worldFromModel_TL,M.low),m(_.worldFromModel_TH,M.high),h(_.worldFromModel_RS,t.transform.rotationScale),h(_.transformNormal_GlobalFromModel,x),f(_.toMapSpace,t.toMapSpace);const S=new V,v=new j(i,S.attributeLocations,{data:b,componentIndices:z},{data:c,componentIndices:w},r(g)),D=new G;return D.material=S,D.drawParameters=_,D.geometry=new I(v,s.primitiveType,a,e(g)),D.meta.cameraDepthSquared=.5,D.meta.gpuMemoryEstimate=c.byteSize+w.byteSize+(e(g)?g.byteSize:0),D}_notifyDirty(){this._renderManager.notifyDirty()}}const z=d(b().u16("componentIndex"));function K(e,t){return e===t?0:0===e?2:1}const N=g(),J=i(),Q=i();export{H as ComponentObjectCollection};
