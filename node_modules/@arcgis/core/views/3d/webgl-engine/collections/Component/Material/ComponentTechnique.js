/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../../../chunks/tslib.es6.js";import{isSome as o,unwrap as r}from"../../../../../../core/maybe.js";import{a as t}from"../../../../../../chunks/mat3f64.js";import{a as s}from"../../../../../../chunks/vec4f64.js";import{ReloadableShaderModule as i}from"../../../core/shaderTechnique/ReloadableShaderModule.js";import{ShaderTechnique as a}from"../../../core/shaderTechnique/ShaderTechnique.js";import{ShaderTechniqueConfiguration as n,parameter as l}from"../../../core/shaderTechnique/ShaderTechniqueConfiguration.js";import d from"../../../../../webgl/Program.js";import{makePipelineState as u,defaultDepthWriteParams as c,defaultColorWriteParams as p}from"../../../../../webgl/renderState.js";import{Slice as m}from"../../../core/shaderLibrary/Slice.glsl.js";import{OutputHighlight as h}from"../../../core/shaderLibrary/output/OutputHighlight.glsl.js";import{blendingDefault as O,OITBlending as f,OITDepthTest as b,OITPolygonOffset as x}from"../../../lib/OrderIndependentTransparency.js";import{stencilWriteMaskOn as T,replaceBitWhenDepthTestPasses as g,stencilBaseAllZerosParams as M}from"../../../lib/StencilUtils.js";import{ScreenSpaceReflections as v}from"../../../core/shaderLibrary/shading/ScreenSpaceReflections.glsl.js";import{doublePrecisionRequiresObfuscation as y}from"../../../core/shaderLibrary/util/DoublePrecision.glsl.js";import{PhysicallyBasedRenderingParameters as S}from"../../../core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js";import{VertexPosition as C}from"../../../core/shaderLibrary/attributes/VertexPosition.glsl.js";import{C as E}from"../../../../../../chunks/ComponentShader.glsl.js";const R={DIFFUSE:0,COMPONENT_COLOR:1,NORMAL:2,EMISSION:3,OCCLUSION:4,METALLIC_ROUGHNESS:5,OVERLAY0_COLOR:2,OVERLAY1_COLOR:3,OVERLAY0_NORMAL:4,OVERLAY1_NORMAL:5,SSAO:6,SHADOW_MAP:7,PREPASS_LINEAR_DEPTH:8,LAST_FRAME_COLOR:9};class L extends a{bindPass(e,o){const r=this.program;C.bindViewProjTransform(r,o.viewTransform),m.bindUniforms(this.program,this.configuration,o.slicePlane),0===o.identifier&&void 0!==o.ssrParams&&(o.ssrParams.lastFrameColorTextureID=R.LAST_FRAME_COLOR,o.ssrParams.linearDepthTextureID=R.PREPASS_LINEAR_DEPTH,v.bindUniforms(this.program,e,o.ssrParams)),0===o.identifier&&(r.setUniformMatrix3fv("uTransformNormal_ViewFromGlobal",o.transformNormal_ViewFromGlobal),2===o.subPass&&r.setUniform2fv("uCameraNearFar",o.cameraNearFar),0===o.subPass&&(o.ambientOcclusionEnabled&&o.ambientOcclusion.bind(r,R.SSAO),o.shadowsEnabled&&o.shadowMap.bind(r,R.SHADOW_MAP),o.lighting.setUniforms(this.program,o.integratedMesh))),1===o.identifier&&this.program.setUniform2fv("uCameraNearFar",o.cameraNearFar),2===o.identifier&&h.bindOutputHighlight(e,this.program,o)}bindDraw(e,o){if(C.bindModelTransform(this.program,e),this.program.setUniformMatrix3fv("uTransformNormal_GlobalFromModel",e.transformNormal_GlobalFromModel),o.isIntegratedMesh){const r=o.overlayTexScale,t=o.overlayTexOffset;this.program.setUniform4fv("overlayTexOffset",[e.toMapSpace[0]*r[0]+t[0],e.toMapSpace[1]*r[1]+t[1],e.toMapSpace[0]*r[2]+t[2],e.toMapSpace[1]*r[3]+t[3]]),this.program.setUniform4fv("overlayTexScale",[e.toMapSpace[2]*r[0],e.toMapSpace[3]*r[1],e.toMapSpace[2]*r[2],e.toMapSpace[3]*r[3]])}}bindMaterial(e,t,s){const i=this.program;i.setUniform4fv("uBaseColor",t.baseColor),i.setUniform1f("uObjectOpacity",t.objectOpacity),i.setUniform1f("textureAlphaCutoff",t.alphaCutoff),1===t.componentParameters.type?t.componentParameters.texture.bind(i,{texName:"uComponentColorTex",invDimName:"uComponentColorTexInvDim",unit:R.COMPONENT_COLOR}):(i.setUniform4fv("uExternalColor",t.componentParameters.externalColor),i.setUniform1i("uExternalColorMixMode",t.componentParameters.externalColorMixMode)),o(t.baseColorTexture)&&t.baseColorTexture.bind(e,i,"uBaseColorTexture",R.DIFFUSE,"uBaseColorTextureSize"),0!==this.configuration.output&&7!==this.configuration.output||(S.bindUniforms(this.program,t),o(t.metallicRoughnessTexture)&&t.metallicRoughnessTexture.bind(e,i,"texMetallicRoughness",R.METALLIC_ROUGHNESS,"texMetallicRoughnessSize"),o(t.emissionTexture)&&t.emissionTexture.bind(e,i,"texEmission",R.EMISSION,"texEmissionSize"),o(t.occlusionTexture)&&t.occlusionTexture.bind(e,i,"texOcclusion",R.OCCLUSION,"texOcclusionSize"),o(t.normalTexture)&&t.normalTexture.bind(e,i,"normalTexture",R.NORMAL,"normalTextureSize")),t.isIntegratedMesh&&(0===s.identifier&&0===s.subPass?(e.bindTexture(r(t.overlayColorInner),R.OVERLAY0_COLOR),e.bindTexture(r(t.overlayColorOuter),R.OVERLAY1_COLOR),e.bindTexture(r(t.overlayNormalInner),R.OVERLAY0_NORMAL),e.bindTexture(r(t.overlayNormalOuter),R.OVERLAY1_NORMAL),i.setUniform1i("ovInnerNormalTex",R.OVERLAY0_NORMAL),i.setUniform1i("ovOuterNormalTex",R.OVERLAY1_NORMAL)):2===s.identifier&&(e.bindTexture(r(t.overlayHighlightInner),R.OVERLAY0_COLOR),e.bindTexture(r(t.overlayHighlightOuter),R.OVERLAY1_COLOR)),i.setUniform1i("ovInnerColorTex",R.OVERLAY0_COLOR),i.setUniform1i("ovOuterColorTex",R.OVERLAY1_COLOR),i.setUniform1f("overlayOpacity",1))}initializeProgram(e){const o=L.shader.get(),r=this.configuration,t=o.build({OITEnabled:0===r.transparencyPassType,output:r.output,normalType:0===r.integratedMeshMode?r.hasNormals?1:3:2,attributeColor:r.hasVertexColors,attributeTextureCoordinates:r.vertexTextureCoordinates,componentData:r.componentData,alphaDiscardMode:r.alphaDiscardMode,baseColorTexture:r.baseColorTexture,doubleSidedMode:r.doubleSidedMode,receiveAmbientOcclusion:r.receiveAmbientOcclusion,receiveShadows:r.receiveShadows,slicePlaneEnabled:r.slicePlaneEnabled,sliceHighlightDisabled:!1,sliceEnabledForVertexPrograms:!1,viewingMode:e.viewingMode,vertexDiscardMode:r.vertexDiscardMode,pbrMode:3===r.integratedMeshMode?4:r.usePBR?1:0,hasMetalnessAndRoughnessTexture:r.hasMetalnessAndRoughnessTexture,hasEmissionTexture:r.hasEmissionTexture,hasOcclusionTexture:r.hasOcclusionTexture,hasNormalTexture:r.hasNormalTexture,vertexTangets:!1,useOldSceneLightInterface:!1,supportsTextureAtlas:!0,doublePrecisionRequiresObfuscation:y(e.rctx),overlayEnabled:2===r.integratedMeshMode||3===r.integratedMeshMode,ssrEnabled:r.ssrEnabled,highStepCount:!1,ellipsoidMode:r.ellipsoidMode});return new d(e.rctx,t.generateSource("vertex"),t.generateSource("fragment"),o.attributeLocations)}setPipelineState(e){const o=this.configuration,r=0!==o.integratedMeshMode,t=3===e,s=2===e;return u({blending:0!==o.output&&7!==o.output||!o.blendingEnabled?null:t?O:f(e),culling:A[o.cullFace],depthTest:{func:b(e)},depthWrite:t||s?c:null,colorWrite:p,stencilWrite:r||o.sceneHasOcludees?T:null,stencilTest:r?g(1):o.sceneHasOcludees?M:null,polygonOffset:t||s?o.polygonOffsetEnabled?{factor:2,units:2}:null:x})}initializePipeline(){return this.setPipelineState(this.configuration.transparencyPassType)}}L.shader=new i(E,(()=>import("./shader/ComponentShader.glsl.js")));const A=[];A[0]=null,A[2]={face:1029,mode:2305},A[1]={face:1028,mode:2305};class P extends C.ModelTransform{constructor(){super(...arguments),this.transformNormal_GlobalFromModel=t(),this.toMapSpace=s()}}class N extends n{constructor(){super(...arguments),this.output=0,this.hasVertexColors=!1,this.hasNormals=!1,this.vertexTextureCoordinates=0,this.componentData=0,this.slicePlaneEnabled=!1,this.cullFace=2,this.baseColorTexture=!1,this.receiveAmbientOcclusion=!0,this.receiveShadows=!0,this.vertexDiscardMode=0,this.doubleSidedMode=2,this.blendingEnabled=!0,this.alphaDiscardMode=1,this.integratedMeshMode=0,this.ssrEnabled=!1,this.polygonOffsetEnabled=!1,this.usePBR=!1,this.hasMetalnessAndRoughnessTexture=!1,this.hasEmissionTexture=!1,this.hasOcclusionTexture=!1,this.hasNormalTexture=!1,this.sceneHasOcludees=!1,this.transparencyPassType=3,this.ellipsoidMode=1}}e([l({count:8})],N.prototype,"output",void 0),e([l()],N.prototype,"hasVertexColors",void 0),e([l()],N.prototype,"hasNormals",void 0),e([l({count:3})],N.prototype,"vertexTextureCoordinates",void 0),e([l({count:2})],N.prototype,"componentData",void 0),e([l()],N.prototype,"slicePlaneEnabled",void 0),e([l({count:3})],N.prototype,"cullFace",void 0),e([l()],N.prototype,"baseColorTexture",void 0),e([l()],N.prototype,"receiveAmbientOcclusion",void 0),e([l()],N.prototype,"receiveShadows",void 0),e([l({count:3})],N.prototype,"vertexDiscardMode",void 0),e([l({count:3})],N.prototype,"doubleSidedMode",void 0),e([l()],N.prototype,"blendingEnabled",void 0),e([l({count:4})],N.prototype,"alphaDiscardMode",void 0),e([l({count:4})],N.prototype,"integratedMeshMode",void 0),e([l()],N.prototype,"ssrEnabled",void 0),e([l()],N.prototype,"polygonOffsetEnabled",void 0),e([l()],N.prototype,"usePBR",void 0),e([l()],N.prototype,"hasMetalnessAndRoughnessTexture",void 0),e([l()],N.prototype,"hasEmissionTexture",void 0),e([l()],N.prototype,"hasOcclusionTexture",void 0),e([l()],N.prototype,"hasNormalTexture",void 0),e([l()],N.prototype,"sceneHasOcludees",void 0),e([l({count:4})],N.prototype,"transparencyPassType",void 0),e([l({count:4})],N.prototype,"ellipsoidMode",void 0);export{P as ComponentDrawParameters,L as ComponentTechnique,N as ComponentTechniqueConfiguration,R as TextureUnits};
