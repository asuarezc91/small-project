/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import"../../../../core/has.js";import{clamp as e}from"../../../../core/mathUtils.js";import{c as o}from"../../../../chunks/vec3f64.js";import{s as t}from"../../../../chunks/vec3.js";import{i,g as n,e as r,f as s,c as l,d as a,m as u,s as f,t as c}from"../../../../chunks/mat4.js";import{meterIn as p}from"../../../../renderers/support/lengthUtils.js";import{a as v}from"../../../../chunks/mat3f64.js";import{a as d}from"../../../../chunks/mat4f64.js";import{f as z}from"../../../../chunks/mat3.js";import m from"../../support/debugFlags.js";function y(e){return null!=e}function S(e){return"number"==typeof e}function h(e){return"string"==typeof e}function x(e,o){e&&e.push(o)}function b(e,o,t,i,n){const r=e.minSize,s=e.maxSize;if(e.expression)return x(n,"Could not convert size info: expression not supported"),!1;if(e.useSymbolValue){const e=i.symbolSize[t];return o.minSize[t]=e,o.maxSize[t]=e,o.offset[t]=o.minSize[t],o.factor[t]=0,o.type[t]=1,!0}if(y(e.field))return y(e.stops)?2===e.stops.length&&S(e.stops[0].size)&&S(e.stops[1].size)?(C(e.stops[0].size,e.stops[1].size,e.stops[0].value,e.stops[1].value,o,t),o.type[t]=1,!0):(x(n,"Could not convert size info: stops only supported with 2 elements"),!1):S(r)&&S(s)&&y(e.minDataValue)&&y(e.maxDataValue)?(C(r,s,e.minDataValue,e.maxDataValue,o,t),o.type[t]=1,!0):null!=p[e.valueUnit]?(o.minSize[t]=-1/0,o.maxSize[t]=1/0,o.offset[t]=0,o.factor[t]=1/p[e.valueUnit],o.type[t]=1,!0):"unknown"===e.valueUnit?(x(n,"Could not convert size info: proportional size not supported"),!1):(x(n,"Could not convert size info: scale-dependent size not supported"),!1);if(!y(e.field)){if(e.stops&&e.stops[0]&&S(e.stops[0].size))return o.minSize[t]=e.stops[0].size,o.maxSize[t]=e.stops[0].size,o.offset[t]=o.minSize[t],o.factor[t]=0,o.type[t]=1,!0;if(S(r))return o.minSize[t]=r,o.maxSize[t]=r,o.offset[t]=r,o.factor[t]=0,o.type[t]=1,!0}return x(n,"Could not convert size info: unsupported variant of sizeInfo"),!1}function C(e,o,t,i,n,r){const s=Math.abs(i-t)>0?(o-e)/(i-t):0;n.minSize[r]=s>0?e:o,n.maxSize[r]=s>0?o:e,n.offset[r]=e-t*s,n.factor[r]=s}function M(e,o,t,i){if(e.normalizationField||e.valueRepresentation)return x(i,"Could not convert size info: unsupported property"),null;if(null!=(n=e.field)&&!h(n))return x(i,"Could not convert size info: field is not a string"),null;var n;if(o.size){if(e.field)if(o.size.field){if(e.field!==o.size.field)return x(i,"Could not convert size info: multiple fields in use"),null}else o.size.field=e.field}else o.size={field:e.field,minSize:[0,0,0],maxSize:[0,0,0],offset:[0,0,0],factor:[0,0,0],type:[0,0,0]};let r;switch(e.axis){case"width":return r=b(e,o.size,0,t,i),r?o:null;case"height":return r=b(e,o.size,2,t,i),r?o:null;case"depth":return r=b(e,o.size,1,t,i),r?o:null;case"width-and-depth":return r=b(e,o.size,0,t,i),r&&b(e,o.size,1,t,i),r?o:null;case null:case void 0:case"all":return r=b(e,o.size,0,t,i),r=r&&b(e,o.size,1,t,i),r=r&&b(e,o.size,2,t,i),r?o:null;default:return x(i,`Could not convert size info: unknown axis "${e.axis}""`),null}}function g(e,o,t){e[4*o+0]=t.r/255,e[4*o+1]=t.g/255,e[4*o+2]=t.b/255,e[4*o+3]=t.a}function V(e,o,t){const i=2===t&&"arithmetic"===e.rotationType;o.offset[t]=i?90:0,o.factor[t]=i?-1:1,o.type[t]=1}function T(e,o,t){if(!e)return null;const i=!o.supportedTypes||!!o.supportedTypes.size,n=!o.supportedTypes||!!o.supportedTypes.color,r=!o.supportedTypes||!!o.supportedTypes.rotation,s=!!o.supportedTypes&&!!o.supportedTypes.opacity,l=e.reduce(((e,l)=>{if(!e)return e;if(l.valueExpression)return x(t,"Could not convert visual variables: arcade expressions not supported"),null;switch(l.type){case"size":return i?M(l,e,o,t):e;case"color":return n?function(e,o,t){if(e.normalizationField)return x(t,"Could not convert color info: unsupported property"),null;if(h(e.field)){if(!e.stops)return x(t,"Could not convert color info: missing stops or colors"),null;{if(e.stops.length>8)return x(t,"Could not convert color info: too many color stops"),null;o.color={field:e.field,values:[0,0,0,0,0,0,0,0],colors:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]};const i=e.stops;for(let e=0;e<8;++e){const t=i[Math.min(e,i.length-1)];o.color.values[e]=t.value,g(o.color.colors,e,t.color)}}}else{if(!(e.stops&&e.stops.length>=0))return x(t,"Could not convert color info: no field and no colors/stops"),null;{const t=e.stops&&e.stops.length>=0&&e.stops[0].color;o.color={field:null,values:[0,0,0,0,0,0,0,0],colors:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]};for(let e=0;e<8;e++)o.color.values[e]=1/0,g(o.color.colors,e,t)}}return o}(l,e,t):e;case"opacity":return s?function(e,o,t){if(e.normalizationField)return x(t,"Could not convert opacity info: unsupported property"),null;if(h(e.field)){if(!e.stops)return x(t,"Could not convert opacity info: missing stops or opacities"),null;{if(e.stops.length>8)return x(t,"Could not convert opacity info: too many opacity stops"),null;o.opacity={field:e.field,values:[0,0,0,0,0,0,0,0],opacityValues:[0,0,0,0,0,0,0,0]};const i=e.stops;for(let e=0;e<8;++e){const t=i[Math.min(e,i.length-1)];o.opacity.values[e]=t.value,o.opacity.opacityValues[e]=t.opacity}}}else{if(!(e.stops&&e.stops.length>=0))return x(t,"Could not convert opacity info: no field and no opacities/stops"),null;{const t=e.stops&&e.stops.length>=0&&e.stops[0].opacity;o.opacity={field:null,values:[0,0,0,0,0,0,0,0],opacityValues:[0,0,0,0,0,0,0,0]};for(let e=0;e<8;e++)o.opacity.values[e]=1/0,o.opacity.opacityValues[e]=t}}return o}(l,e,t):null;case"rotation":return r?function(e,o,t){if(!h(e.field))return x(t,"Could not convert rotation info: field is not a string"),null;if(o.rotation){if(e.field)if(o.rotation.field){if(e.field!==o.rotation.field)return x(t,"Could not convert rotation info: multiple fields in use"),null}else o.rotation.field=e.field}else o.rotation={field:e.field,offset:[0,0,0],factor:[1,1,1],type:[0,0,0]};switch(e.axis){case"tilt":return V(e,o.rotation,0),o;case"roll":return V(e,o.rotation,1),o;case null:case void 0:case"heading":return V(e,o.rotation,2),o;default:return x(t,`Could not convert rotation info: unknown axis "${e.axis}""`),null}}(l,e,t):e;default:return null}}),{size:null,color:null,opacity:null,rotation:null});return!(e.length>0&&l)||l.size||l.color||l.opacity||l.rotation?l&&l.size&&!function(e,o,t){for(let t=0;t<3;++t){let i=o.unitInMeters;1===e.type[t]&&(i*=o.modelSize[t],e.type[t]=2),e.minSize[t]=e.minSize[t]/i,e.maxSize[t]=e.maxSize[t]/i,e.offset[t]=e.offset[t]/i,e.factor[t]=e.factor[t]/i}let i;if(0!==e.type[0])i=0;else if(0!==e.type[1])i=1;else{if(0===e.type[2])return x(t,"No size axis contains a valid size or scale"),!1;i=2}for(let o=0;o<3;++o)0===e.type[o]&&(e.minSize[o]=e.minSize[i],e.maxSize[o]=e.maxSize[i],e.offset[o]=e.offset[i],e.factor[o]=e.factor[i],e.type[o]=e.type[i]);return!0}(l.size,o,t)?null:l:null}function O(e){return e&&null!=e.size}function E(e,o){if(!e)return{enabled:!1};if(m.DISABLE_FAST_UPDATES)return{enabled:!1};const t=T(e.visualVariables,o);return t?{enabled:!0,visualVariables:t,materialParameters:w(t,o),requiresShaderTransformation:O(t)}:{enabled:!1}}function j(e,o,t){if(!o||!e.enabled)return!1;const i=e.visualVariables,n=T(o.visualVariables,t);return!!n&&(!!(k(i.size,n.size,"size")&&k(i.color,n.color,"color")&&k(i.rotation,n.rotation,"rotation")&&k(i.opacity,n.opacity,"opacity"))&&(e.visualVariables=n,e.materialParameters=w(n,t),e.requiresShaderTransformation=O(n),!0))}function k(e,o,t){if(!!e!=!!o)return!1;if(e&&e.field!==o.field)return!1;if(e&&"rotation"===t){const t=e,i=o;for(let e=0;e<3;e++)if(t.type[e]!==i.type[e]||t.offset[e]!==i.offset[e]||t.factor[e]!==i.factor[e])return!1}return!0}function w(e,o){const t={vvSizeEnabled:!1,vvSizeMinSize:null,vvSizeMaxSize:null,vvSizeOffset:null,vvSizeFactor:null,vvSizeValue:null,vvColorEnabled:!1,vvColorValues:null,vvColorColors:null,vvOpacityEnabled:!1,vvOpacityValues:null,vvOpacityOpacities:null,vvSymbolAnchor:null,vvSymbolRotationMatrix:null},l=O(e);return e&&e.size?(t.vvSizeEnabled=!0,t.vvSizeMinSize=e.size.minSize,t.vvSizeMaxSize=e.size.maxSize,t.vvSizeOffset=e.size.offset,t.vvSizeFactor=e.size.factor):e&&l&&(t.vvSizeValue=o.transformation.scale),e&&l&&(t.vvSymbolAnchor=o.transformation.anchor,t.vvSymbolRotationMatrix=v(),i(A),function(e,o,t,i=d()){const l=e||0,a=o||0,u=t||0;0!==l&&n(i,i,-l/180*Math.PI),0!==a&&r(i,i,a/180*Math.PI),0!==u&&s(i,i,u/180*Math.PI)}(o.transformation.rotation[2],o.transformation.rotation[0],o.transformation.rotation[1],A),z(t.vvSymbolRotationMatrix,A)),e&&e.color&&(t.vvColorEnabled=!0,t.vvColorValues=e.color.values,t.vvColorColors=e.color.colors),e&&e.opacity&&(t.vvOpacityEnabled=!0,t.vvOpacityValues=e.opacity.values,t.vvOpacityOpacities=e.opacity.opacityValues),t}var F;!function(i){const n=d(),r=o();i.evaluateModelTransform=function(o,t,i){if(!o.vvSizeEnabled)return i;l(n,i);const s=o.vvSymbolRotationMatrix;a(A,s[0],s[1],s[2],0,s[3],s[4],s[5],0,s[6],s[7],s[8],0,0,0,0,1),u(n,n,A);for(let i=0;i<3;++i){const n=o.vvSizeOffset[i]+t[0]*o.vvSizeFactor[i];r[i]=e(n,o.vvSizeMinSize[i],o.vvSizeMaxSize[i])}return f(n,n,r),c(n,n,o.vvSymbolAnchor),n},i.evaluateModelTransformScale=function(o,i,n){if(!i.vvSizeEnabled)return t(o,1,1,1);for(let t=0;t<3;++t){const r=i.vvSizeOffset[t]+n[0]*i.vvSizeFactor[t];o[t]=e(r,i.vvSizeMinSize[t],i.vvSizeMaxSize[t])}return o}}(F||(F={}));const A=d(),D=F.evaluateModelTransform,I=F.evaluateModelTransformScale;export{T as convertVisualVariables,D as evaluateModelTransform,I as evaluateModelTransformScale,w as getMaterialParams,E as initFastSymbolUpdatesState,j as updateFastSymbolUpdatesState};
