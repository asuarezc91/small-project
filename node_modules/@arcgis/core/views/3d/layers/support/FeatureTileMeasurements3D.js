/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{createScreenPointArray as e,createRenderScreenPointArray3 as t}from"../../../../core/screenUtils.js";import{c as i}from"../../../../chunks/vec3f64.js";import{a as s,b as r}from"../../../../chunks/vec3.js";import{create as o,fromValues as a,distance as n,empty as c,height as l,expandPointInPlace as h,expand as m,intersection as p,area as u}from"../../../../geometry/support/aaBoundingRect.js";import{triangle as d,plane as f}from"../../support/geometryUtils.js";import S from"../../webgl-engine/lib/Camera.js";import j from"./FeatureTileVisibility3D.js";class b{constructor(e){this.camera=new S,this.focusOnMap=[0,0],this.screenRect=o(),this.tileSize=e.tileSize,this.maxVerticalScreenSize=e.maxVerticalScreenSize,this.renderCoordsHelper=e.renderCoordsHelper,this.tilingScheme=e.tilingScheme,this.visibility=new j({renderCoordsHelper:e.renderCoordsHelper})}begin(e,t,i){this.camera.copyFrom(e),this.surfaceElevation=i,this.focusOnMap[0]=t.x,this.focusOnMap[1]=t.y,a(0,0,e.fullWidth,e.fullHeight,this.screenRect),this.visibility.begin(this.camera,i)}end(){this.visibility.end()}updateTile(e){e.measures.visibility=this.visibility.calculate(e),0!==e.measures.visibility&&this.updateScreenMeasure(e),this.updateDistanceMeasure(e)}updateDistanceMeasure(e){e.measures.distance=n(e.extent,this.focusOnMap)}updateScreenMeasure(e){const t=y,i=1<<t,s=e.measures.screenRect;c(s);let r=0;const o=e.lij[0]+t,a=e.lij[1]<<t,n=e.lij[2]<<t,h=this.tileSizeWithBias(e),m=h*h;let p=!1;for(let t=0;t<i;t++){for(let c=0;c<i;c++){if(r+=this.computeScreenArea(e,o,a+t,n+c,s).area,p=r>m&&l(s)>this.maxVerticalScreenSize,p)break}if(p)break}e.measures.shouldSplit=r>m}tileSizeWithBias(e){return 1===e.measures.visibility?this.tileSize*R:this.tileSize}computeScreenArea(e,t,i,s,r){const o=1===e.measures.visibility,a=C.points;this.projectToScreen(t,i,s,o,a),c(g);for(let e=0;e<4;e++)h(g,a[e]);return m(r,g),p(g,this.screenRect,v),C.screenOverlap=u(v)/u(g),C.area=d.areaPoints2d(a[0],a[1],a[2])+d.areaPoints2d(a[0],a[2],a[3]),C}projectToScreen(e,t,i,s,r){this.tilingScheme.ensureMaxLod(e),this.tilingScheme.getExtent(e,t,i,x),this.toRenderCoords(x,0,3,T[0]),this.toRenderCoords(x,2,3,T[1]),this.toRenderCoords(x,2,1,T[2]),this.toRenderCoords(x,0,1,T[3]),s&&(this.projectToPlane(T,this.camera.frustum.planes[4]),this.projectToPlane(T,this.camera.frustum.planes[3]),this.projectToPlane(T,this.camera.frustum.planes[2]));for(let e=0;e<4;e++)this.camera.projectToRenderScreen(T[e],H),this.camera.renderToScreen(H,r[e])}projectToPlane(e,t){for(let i=0;i<4;i++)z[i]=f.signedDistance(t,e[i]);const i=Math.max(z[0],z[1],z[2],z[3]);if(i>0){const o=s(M,f.normal(t),-i);for(let t=0;t<4;t++)r(e[t],e[t],o)}}toRenderCoords(e,t,i,s){return M[0]=e[t],M[1]=e[i],M[2]=this.surfaceElevation,this.renderCoordsHelper.toRenderCoords(M,this.tilingScheme.spatialReference,s),s}}const g=o(),v=o(),y=2,R=5,C={points:[e(),e(),e(),e()],area:0,screenOverlap:0},x=o(),M=i(),T=[i(),i(),i(),i()],z=[0,0,0,0],H=t();export default b;export{b as FeatureTileMeasurements3D};
