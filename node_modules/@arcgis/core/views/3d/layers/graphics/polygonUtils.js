/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{isSome as t}from"../../../../core/maybe.js";import i from"../../../../geometry/Extent.js";import o from"../../../../geometry/Polygon.js";import"../../../../geometry.js";import{projectBuffer as n}from"../../../../geometry/projection.js";import{pathsToTriangulationInfo as e}from"../../../../geometry/support/triangulationUtils.js";import{VertexAttrConstants as a}from"../../webgl-engine/lib/Util.js";import{GeometryData as s}from"../../webgl-engine/lib/GeometryData.js";import{applyPerVertexElevationAlignment as r}from"./elevationAlignmentUtils.js";import{DRAPED_Z as p}from"../../terrain/OverlayRenderer.js";function u(i){const o={},n={};if(n[a.POSITION]={size:3,data:i.attributeData.position},o[a.POSITION]=i.indices,t(i.attributeData.color)){const t=new Uint32Array(i.indices.length);n[a.COLOR]={size:4,data:i.attributeData.color},o[a.COLOR]=t}return t(i.attributeData.uvMapSpace)&&(n[a.UVMAPSPACE]={size:4,data:i.attributeData.uvMapSpace},o[a.UVMAPSPACE]=i.indices),t(i.attributeData.bound1)&&(n[a.BOUND1]={size:3,data:i.attributeData.bound1},o[a.BOUND1]=i.indices),t(i.attributeData.bound2)&&(n[a.BOUND2]={size:3,data:i.attributeData.bound2},o[a.BOUND2]=i.indices),t(i.attributeData.bound3)&&(n[a.BOUND3]={size:3,data:i.attributeData.bound3},o[a.BOUND3]=i.indices),t(i.attributeData.mapPosition)&&(n.mapPos={size:3,data:i.attributeData.mapPosition},o.mapPos=i.indices),new s(n,o)}function c(i){const o={},n={};return n[a.POSITION]={size:3,data:i.attributeData.position},o[a.POSITION]=i.indices,n[a.UV0]={size:2,data:i.attributeData.uv0},o[a.UV0]=i.indices,t(i.attributeData.mapPosition)&&(n.mapPos={size:3,data:i.attributeData.mapPosition},o.mapPos=i.indices),new s(n,o)}function m(t){switch(t.type){case"extent":if(t instanceof i)return o.fromExtent(t);break;case"polygon":return t}return null}function l(t,i,o,n){const a=e(t.rings,t.hasZ,1),s=new Float64Array(a.position.length),p=r(a.position,t.spatialReference,0,s,0,a.position,0,a.position.length/3,i,o,n),u=null!=p;return{position:a.position,mapPosition:s,polygons:f(a.polygons,a.position,s),outlines:b(a.outlines,a.position,s),projectionSuccess:u,sampledElevation:p}}function d(t,i){const o=e(t.rings,!1,1),a=n(o.position,t.spatialReference,0,o.position,i,0,o.position.length/3);for(let t=2;t<o.position.length;t+=3)o.position[t]=p;return{position:o.position,polygons:f(o.polygons,o.position),outlines:b(o.outlines,o.position),projectionSuccess:a}}function b(t,i,o){const n=new Array;for(const{index:e,count:a}of t){if(a<=1)continue;const t=3*e,s=t+3*a;n.push({index:e,count:a,position:i.subarray(t,s),mapPosition:o?o.subarray(t,s):void 0})}return n}function f(t,i,o){const n=new Array;for(const{index:e,count:a,holeIndices:s,pathLengths:r}of t){if(a<=1)continue;const t=3*e,p=t+3*a,u=s.map((t=>t-e));n.push({index:e,count:a,holeIndices:u,pathLengths:r,position:i.subarray(t,p),mapPosition:o?o.subarray(t,p):void 0})}return n}export{u as createColorGeometryData,c as createWaterGeometryData,m as geometryAsPolygon,l as geometryToRenderInfo,d as geometryToRenderInfoDraped};
