/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{slice as t}from"../../../../core/typedArrayUtil.js";import{isNone as e,isSome as o,unwrapOr as n}from"../../../../core/maybe.js";import{acosClamped as r}from"../../../../core/mathUtils.js";import{c as i}from"../../../../chunks/vec3f64.js";import{s as a,n as s,d as f,a as c}from"../../../../chunks/vec3.js";import{projectBuffer as u}from"../../../../geometry/projection.js";import{pathsToTriangulationInfo as l}from"../../../../geometry/support/triangulationUtils.js";import{GeometryData as I}from"../../webgl-engine/lib/GeometryData.js";import{applyPerVertexElevationAlignment as p}from"./elevationAlignmentUtils.js";import{RibbonVertexAttributeConstants as d}from"../../webgl-engine/shaders/RibbonLineTechnique.js";import{DRAPED_Z as m}from"../../terrain/OverlayRenderer.js";import{WHITE_UNIT as T}from"./constants.js";function y(i){const u={},l={};!function(e,o,n){const{attributeData:{position:r},removeDuplicateStartEnd:i}=e,a=function(t){const e=t.length;return t[0]===t[e-3]&&t[1]===t[e-2]&&t[2]===t[e-1]}(r)&&1===i,s=r.length/3-(a?1:0),f=new Uint32Array(2*(s-1)),c=a?t(r,0,r.length-3):r;let u=0;for(let t=0;t<s-1;t++)f[u++]=t,f[u++]=t+1;o[d.POSITION]={size:3,data:c,offsetIdx:0,strideIdx:3},n[d.POSITION]=f}(i,l,u);const p=new Uint32Array(u[d.POSITION].length);return function(t,o,n){const r=t.attributeData.mapPosition;if(e(r))return;n.mapPos=n[d.POSITION],o.mapPos={size:3,data:r,offsetIdx:0,strideIdx:3}}(i,l,u),function(t,e,r,i){if(o(t.attributeData.colorFeature))return;const a=t.attributeData.color;e[d.COLOR]={size:4,data:n(a,T),offsetIdx:0,strideIdx:4},r[d.COLOR]=i}(i,l,u,p),function(t,e,r,i){if(o(t.attributeData.sizeFeature))return;const a=t.attributeData.size;e[d.SIZE]={size:1,data:new Float32Array([n(a,1)]),offsetIdx:0,strideIdx:1},r[d.SIZE]=i}(i,l,u,p),function(t,o,n,r){const i=t.attributeData.colorFeature;if(e(i))return;o[d.COLORFEATUREATTRIBUTE]={size:1,data:new Float32Array([i]),offsetIdx:0,strideIdx:1},n[d.COLOR]=r}(i,l,u,p),function(t,o,n,r){const i=t.attributeData.sizeFeature;if(e(i))return;o[d.SIZEFEATUREATTRIBUTE]={size:1,data:new Float32Array([i]),offsetIdx:0,strideIdx:1},n[d.SIZEFEATUREATTRIBUTE]=r}(i,l,u,p),function(t,o,n,r){const i=t.attributeData.opacityFeature;if(e(i))return;o[d.OPACITYFEATUREATTRIBUTE]={size:1,data:new Float32Array([i]),offsetIdx:0,strideIdx:1},n[d.OPACITYFEATUREATTRIBUTE]=r}(i,l,u,p),function(t,e,o){if("round"!==t.join)return;const i=e[d.POSITION].data,u=i.length/3,l=new Float32Array(u),I=E,p=S;a(I,0,0,0);const m=n(t.uniformSize,1);for(let t=-1;t<u;++t){const e=t<0?u+t:t,o=(t+1)%u;if(a(p,i[3*o+0]-i[3*e+0],i[3*o+1]-i[3*e+1],i[3*o+2]-i[3*e+2]),s(p,p),t>=0){const e=1*((Math.PI-r(f(I,p)))*x)*A(m);l[t]=Math.max(Math.floor(e),0)}c(I,p,-1)}e[d.SUBDIVISIONS]={size:1,data:l,offsetIdx:0,strideIdx:1},o[d.SUBDIVISIONS]=o[d.POSITION]}(i,l,u),new I(l,u,"line")}function O(t,e,o,n){const r="polygon"===t.type?1:0,i="polygon"===t.type?t.rings:t.paths,{position:a,outlines:s}=l(i,t.hasZ,r),f=new Float64Array(a.length),c=p(a,t.spatialReference,0,f,0,a,0,a.length/3,e,o,n),u=null!=c;return{lines:u?g(s,a,f):[],projectionSuccess:u,sampledElevation:c}}function g(t,e,o){const n=new Array;for(const{index:r,count:i}of t){if(i<=1)continue;const t=3*r,a=t+3*i;n.push({position:e.subarray(t,a),mapPosition:o?o.subarray(t,a):void 0})}return n}function h(t,e){const o="polygon"===t.type?1:0,n="polygon"===t.type?t.rings:t.paths,{position:r,outlines:i}=l(n,!1,o),a=u(r,t.spatialReference,0,r,e,0,r.length/3);for(let t=2;t<r.length;t+=3)r[t]=m;return{lines:a?g(i,r):[],projectionSuccess:a}}function A(t){return 1.863798+-2.0062872/Math.pow(1+t/18.2313,.8856294)}const E=i(),S=i(),x=4/Math.PI;export{y as createGeometryData,O as geometryToRenderInfo,h as geometryToRenderInfoDraped};
