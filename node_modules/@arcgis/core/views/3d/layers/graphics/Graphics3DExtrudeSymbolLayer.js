/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{get as e,isSome as t,isNone as r}from"../../../../core/maybe.js";import s from"../../../../core/Error.js";import{d as a,c as n}from"../../../../chunks/vec3f64.js";import{g as i,n as o,s as l,f as c,c as h,i as m}from"../../../../chunks/vec3.js";import{a as p}from"../../../../chunks/mat4.js";import{computeLinearTransformation as d}from"../../../../geometry/projection.js";import{a as u}from"../../../../chunks/mat3f64.js";import{I as g,a as f}from"../../../../chunks/mat4f64.js";import{earcut as y}from"../../../../core/libs/earcut/earcut.js";import{n as _}from"../../../../chunks/mat3.js";import{BufferViewVec3f64 as b}from"../../support/buffer/BufferView.js";import{t as E,a as x}from"../../../../chunks/vec32.js";import{create as v,empty as P,expandWithBuffer as w,intersectsClippingArea as j}from"../../../../geometry/support/aaBoundingBox.js";import{SamplePosition as S}from"../../support/ElevationProvider.js";import{VertexAttrConstants as L}from"../../webgl-engine/lib/Util.js";import{GeometryData as A}from"../../webgl-engine/lib/GeometryData.js";import M from"../../webgl-engine/lib/Object3D.js";import{validateSymbolLayerSize as B,computeCentroid as C}from"./graphicUtils.js";import{needsElevationUpdates3D as O,evaluateElevationAlignmentAtPoint as I}from"./elevationAlignmentUtils.js";import{ElevationContext as G}from"./ElevationContext.js";import T from"./Graphics3DObject3DGraphicLayer.js";import R from"../../webgl-engine/lib/Geometry.js";import{createMaterial as z}from"../support/edgeUtils.js";import{Graphics3DSymbolLayer as D}from"./Graphics3DSymbolLayer.js";import{getDriverAxisSizeValue as U}from"../../../../renderers/support/renderingInfoUtils.js";import{geometryAsPolygon as V,geometryToRenderInfo as N}from"./polygonUtils.js";import{DefaultMaterial as k}from"../../webgl-engine/materials/DefaultMaterial.js";class F extends D{constructor(e,t,r,s){super(e,t,r,s),this.ensureDrapedStatus(!1)}async doLoad(){if(!this._drivenProperties.size){const e=B(this._getSymbolSize());if(e)throw new s("graphics3dextrudesymbollayer:invalid-size",e)}const t=e(this.symbolLayer,"material","color"),r=this._getCombinedOpacityAndColor(t),n=a(r),i=r[3],o={usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0,diffuse:n,ambient:n,opacity:i,transparent:i<1||this.needsDrivenTransparentPass,vertexColors:!0,slicePlaneEnabled:this._context.slicePlaneEnabled,castShadows:this.symbolLayer.castShadows,offsetTransparentBackfaces:!0};this._material=new k(o,this._getIdHint("_3dlinemat")),this._bottomMaterial=new k({...o,cullFace:2},this._getIdHint("_3dlinematbot")),this._context.stage.add(3,this._material),this._context.stage.add(3,this._bottomMaterial)}destroy(){super.destroy(),this._material&&(this._context.stage.remove(3,this._material.id),this._context.stage.remove(3,this._bottomMaterial.id))}createGraphics3DGraphic(e){const t=e.graphic;if(!this._validateGeometryType(t.geometry,F.validGeometryTypes,this.symbolLayer.type)||!this._validateGeometry(t.geometry))return null;const r="graphic"+t.uid,s=this._getVertexOpacityAndColor(e.renderingInfo,Float32Array,255),a=this.setGraphicElevationContext(t,new G);return this._createAs3DShape(t,e.renderingInfo,s,a,r,t.uid)}layerOpacityChanged(r,s){const a=e(this.symbolLayer,"material","color"),n=this._getCombinedOpacity(a),i=n<1||this.needsDrivenTransparentPass;this._material.setParameterValues({opacity:n,transparent:i}),this._bottomMaterial.setParameterValues({opacity:n,transparent:i});const o=this._getLayerOpacity();return r.forEach((e=>{const r=s(e);t(r)&&r.layerOpacityChanged(o,this._context.isAsync)})),!0}layerElevationInfoChanged(e,t){return this.updateGraphics3DGraphicElevationInfo(e,t,O)}slicePlaneEnabledChanged(e,r){return this._material.setParameterValues({slicePlaneEnabled:this._context.slicePlaneEnabled}),this._bottomMaterial.setParameterValues({slicePlaneEnabled:this._context.slicePlaneEnabled}),e.forEach((e=>{const s=r(e);t(s)&&s.slicePlaneEnabledChanged(this._context.slicePlaneEnabled,this._context.isAsync)})),!0}physicalBasedRenderingChanged(){return this._material.setParameterValues({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),this._bottomMaterial.setParameterValues({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),!0}pixelRatioChanged(){return!0}_getExtrusionSize(e){let t;var r;e.size&&this._drivenProperties.size?t=null!=(r=U(e.size,2))?r:0:t=this._getSymbolSize();return t/=this._context.renderCoordsHelper.unitInMeters,t}_getSymbolSize(){var e;return null!=(e=this.symbolLayer.size)?e:1}_createAs3DShape(e,s,a,i,o,l){const c=V(e.geometry);if(r(c))return null;const h=N(c,this._context.elevationProvider,this._context.renderCoordsHelper,i);if(this._logGeometryCreationWarnings(h,c.rings,"rings","ExtrudeSymbol3DLayer"),0===c.rings.length||!c.rings.some((e=>e.length>0)))return null;const m=C(c);if(r(m))return null;const S=new Array,L=new Array,A=new Array,B=v(),I=f(),G=n(),z=1===this._context.renderCoordsHelper.viewingMode;z||this._context.renderCoordsHelper.worldUpAtPosition(null,G),d(c.spatialReference,[m.x,m.y,0],I,this._context.renderCoordsHelper.spatialReference);const D=f();p(D,I);const U=u();_(U,D);const{polygons:k,mapPosition:F,position:Y}=h,Z=Y.length/3,W=new Float64Array(3*Z*6),q=new Float64Array(3*Z*6),J=new Float64Array(3*Z*6),K=new Float64Array(1*Z*6);let Q=0;for(let e=0;e<k.length;++e){const t=k[e],r=t.count;if(this._context.clippingExtent&&(P(B),w(B,t.mapPosition),!j(B,this._context.clippingExtent)))continue;const n=y(t.mapPosition,t.holeIndices,3);if(0===n.length)continue;const i=3*r*2+n.length,l=new Uint32Array(i),c=new Uint32Array(n.length),h=6*r,m=3*W.BYTES_PER_ELEMENT,p=new b(W.buffer,Q*m,m,(Q+h)*m),d=3*q.BYTES_PER_ELEMENT,u=new b(q.buffer,Q*d,d,(Q+h)*d),f=new Float64Array(J.buffer,3*Q*J.BYTES_PER_ELEMENT,3*h),_=new Float64Array(K.buffer,1*Q*K.BYTES_PER_ELEMENT,1*h),v=this._getExtrusionSize(s);H(Y,F,n,t,p.typedBuffer,f,u.typedBuffer,_,0,l,c,v,G,z),E(p,p,D),x(u,u,U),Q+=6*r;const M=this._createExtrudeGeometry(l,{positions:p.typedBuffer,elevation:f,normals:u.typedBuffer,heights:_},a),C=new R(M,o+"path"+e);S.push(C),L.push(this._material),A.push(g);const O=this._createExtrudeGeometry(c,{positions:p.typedBuffer,elevation:f,normals:u.typedBuffer,heights:_},a),I=new R(O,o+"bottompath"+e);S.push(I),L.push(this._bottomMaterial),A.push(g)}if(0===S.length)return null;const X=new M({geometries:S,materials:L,transformations:A,castShadow:!0,metadata:{layerUid:this._context.layer.uid,graphicUid:l,isElevationSource:!0},idHint:o});X.objectTransformation=I;const $=te,ee=this._createEdgeMaterial(),re=t(ee)?{baseMaterial:this._material,edgeMaterials:[ee],properties:{mergeGeometries:!0,slicePlaneEnabled:this._context.slicePlaneEnabled}}:null,se=new T(this,X,S,null,null,$,i,re);return se.alignedSampledElevation=h.sampledElevation,se.needsElevationUpdates=O(i.mode),se}_createExtrudeGeometry(e,t,r){const s=new Uint32Array(e.length),a={};a[L.POSITION]=e,a[L.NORMAL]=e,a[L.COLOR]=s;const n={};return n[L.POSITION]={size:3,data:t.positions},n[L.NORMAL]={size:3,data:t.normals},n[L.COLOR]={size:4,data:r},n[L.SIZE]={size:1,data:t.heights},t.elevation&&(n.mapPos={size:3,data:t.elevation},a.mapPos=e),new A(n,a)}_createEdgeMaterial(){const e={opacity:this._getLayerOpacity()};return z(this.symbolLayer,e)}}function H(e,t,r,s,a,n,l,c,h,m,p,d,u,g){const f=r.length/3;let y=0,_=2*s.count;!function(e,t,r,s,a,n,l,c,h,m,p,d,u,g,f,y,_,b){i(se,_);const E=y>0?1:-1;let x=3*r,v=d,P=3*v,w=d+s,j=3*w;for(let r=0;r<s;++r)b&&(se[0]=e[x+0],se[1]=e[x+1],se[2]=e[x+2],o(se,se)),c[P+0]=e[x+0],c[P+1]=e[x+1],c[P+2]=e[x+2],h[P+0]=t[x+0],h[P+1]=t[x+1],h[P+2]=t[x+2],m[P+0]=-E*se[0],m[P+1]=-E*se[1],m[P+2]=-E*se[2],p[v]=0,c[j+0]=e[x+0]+y*se[0],c[j+1]=e[x+1]+y*se[1],c[j+2]=e[x+2]+y*se[2],h[j+0]=t[x+0],h[j+1]=t[x+1],h[j+2]=t[x+2],m[j+0]=E*se[0],m[j+1]=E*se[1],m[j+2]=E*se[2],p[w]=y,P+=3,j+=3,x+=3,v+=1,w+=1;x=3*n,P=0,j=3*f;const S=y<0?ne:ae,L=y<0?ae:ne;for(let e=0;e<l;++e)g[P+0]=a[x+S[0]],g[P+1]=a[x+S[1]],g[P+2]=a[x+S[2]],u[j+0]=a[x+L[0]]+s,u[j+1]=a[x+L[1]]+s,u[j+2]=a[x+L[2]]+s,P+=3,j+=3,x+=3}(e,t,s.index,s.count,r,0,f,a,n,l,c,h,m,p,_,d,u,g),h+=2*s.count,_=0,W(a,n,c,l,y,s.pathLengths[0],s.count,h,m,_,d),h+=4*s.pathLengths[0],_+=2*s.pathLengths[0],y+=s.pathLengths[0];for(let e=1;e<s.pathLengths.length;++e)W(a,n,c,l,y,s.pathLengths[e],s.count,h,m,_,d),h+=4*s.pathLengths[e],_+=2*s.pathLengths[e],y+=s.pathLengths[e]}function Y(e,t,r,s,a,n,i){s[n]=s[i],i*=3,e[(n*=3)+0]=e[i+0],e[n+1]=e[i+1],e[n+2]=e[i+2],t[n+0]=t[i+0],t[n+1]=t[i+1],t[n+2]=t[i+2],r[n+0]=a[0],r[n+1]=a[1],r[n+2]=a[2]}F.validGeometryTypes=["polygon","extent"];const Z=n();function W(e,t,r,s,a,n,i,o,l,c,h){let m=a,p=a+1,d=a+i,u=a+i+1,g=o,f=o+1,y=o+2*n,_=o+2*n+1;h<0&&(m=a+i+1,u=a),c*=3;for(let o=0;o<n;++o)o===n-1&&(h>0?(p=a,u=a+i):(p=a,m=a+i)),$(e,m,p,d,Z),Y(e,t,s,r,Z,g,m),Y(e,t,s,r,Z,f,p),Y(e,t,s,r,Z,y,d),Y(e,t,s,r,Z,_,u),l[c++]=g,l[c++]=y,l[c++]=_,l[c++]=g,l[c++]=_,l[c++]=f,m++,p++,d++,u++,g+=2,f+=2,y+=2,_+=2}const q=n(),J=n(),K=n(),Q=n(),X=n();function $(e,t,r,s,a){t*=3,r*=3,s*=3,l(q,e[t++],e[t++],e[t++]),l(J,e[r++],e[r++],e[r++]),l(K,e[s++],e[s++],e[s++]),c(Q,J,q),c(X,K,q),h(a,X,Q),o(a,a)}const ee=n();function te(e,t,r,s){const a=e.stageObject,n=a.geometryRecords,i=n.length,o="absolute-height"!==t.mode;let c=0;const h=a.objectTransformation,d=p(f(),h);for(let e=0;e<i;e+=2){const i=n[e].geometry,p=i.data.getVertexAttr(),u=p[L.POSITION].data,g=p[L.SIZE].data,f=p.mapPos.data,y=new S(f),_=u.length/3;let b=0,E=!1,x=0;for(let e=0;e<_;e++){ee[0]=u[b],ee[1]=u[b+1],ee[2]=u[b+2];const e=I(y,r,t,s,o?ie:null);o&&(x+=ie.sampledElevation),l(re,u[b+0],u[b+1],u[b+2]),m(re,re,h),s.setAltitude(e+g[b/3],re),m(re,re,d),u[b]=re[0],u[b+1]=re[1],u[b+2]=re[2];const a=.01/s.unitInMeters;(Math.abs(ee[0]-u[b])>a||Math.abs(ee[1]-u[b+1])>a||Math.abs(ee[2]-u[b+2])>a)&&(E=!0),y.offset+=3,b+=3}E&&(i.invalidateBoundingInfo(),a.geometryVertexAttrsUpdated(e),n[e+1].geometry.invalidateBoundingInfo(),a.geometryVertexAttrsUpdated(e+1)),c+=x/_}return c/i}const re=n(),se=n(),ae=[0,2,1],ne=[0,1,2],ie={verticalDistanceToGround:0,sampledElevation:0};export default F;export{F as Graphics3DExtrudeSymbolLayer};
