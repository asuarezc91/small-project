/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{isNone as t}from"../../../../core/maybe.js";import e from"../../../../geometry/Point.js";import{c as o}from"../../../../chunks/vec3f64.js";import{s as a}from"../../../../chunks/vec3.js";import{c as r}from"../../../../chunks/mat4.js";import{computeLinearTransformation as s}from"../../../../geometry/projection.js";import{a as n}from"../../../../chunks/mat4f64.js";import{BufferViewVec3f64 as i,BufferViewVec4f as l}from"../../support/buffer/BufferView.js";import{VertexAttrConstants as m}from"../../webgl-engine/lib/Util.js";import c from"../../support/debugFlags.js";import{updateVertexAttributeAuxpos1w as f}from"./graphicUtils.js";import{evaluateElevationAlignmentAtPoint as p}from"./elevationAlignmentUtils.js";import{requiresUVUpdates as d,createMapSpaceUVCoords as u}from"../support/uvUtils.js";const T=m;function g(t,e,o,a){const r=t.stageObject,s=o.spatialReference;j.spatialReference=s;const n=r.geometryRecords,i=n.length,l="absolute-height"!==e.mode;let m=0;for(let t=0;t<i;t++){const s=n[t].geometry,i=n[t].getShaderTransformation();R[0]=i[12],R[1]=i[13],R[2]=i[14],s.invalidateBoundingInfo();const f=s.data.getVertexAttr(),d=f[T.POSITION],u=d.data,g=f.mapPos.data,b=d.size,A=u.length/b;let E=0,h=0,I=!1,O=0;for(let t=0;t<A;t++){j.x=g[h++],j.y=g[h++],j.z=g[h++],D[0]=u[E],D[1]=u[E+1],D[2]=u[E+2];const t=p(j,o,e,a,l?M:null);if(l&&(O+=M.sampledElevation),S[0]=u[E]+R[0],S[1]=u[E+1]+R[1],S[2]=u[E+2]+R[2],a.setAltitude(t,S),u[E]=S[0]-R[0],u[E+1]=S[1]-R[1],u[E+2]=S[2]-R[2],c.TESTS_DISABLE_UPDATE_THRESHOLDS)I=!0;else{const t=y/a.unitInMeters;(Math.abs(D[0]-u[E])>=t||Math.abs(D[1]-u[E+1])>=t||Math.abs(D[2]-u[E+2])>=t)&&(I=!0)}E+=b}m+=O/A,I&&r.geometryVertexAttrsUpdated(t)}return m/i}function b(t,e,o,a){const r=g(t,e,o,a),s=t.stageObject.geometryRecords;for(let t=0;t<s.length;t++)if(d(s[t])){const e=s[t].geometry.data.getVertexAttr(),o=e[T.POSITION].data,r=e[T.BOUND1].data,n=e[T.BOUND2].data,m=e[T.BOUND3].data,c=e[T.UVMAPSPACE].data;u(l.fromTypedArray(c),i.fromTypedArray(o),a,i.fromTypedArray(r),i.fromTypedArray(n),i.fromTypedArray(m))}return r}function A(t,e,o,n){const i=t.stageObject,l=e.centerPointInElevationSR;let m=0,d=0;if(i.metadata.usesVerticalDistanceToGround)m=p(l,o,e,n,M),f(i,M.verticalDistanceToGround),d=M.sampledElevation;else{const t="absolute-height"!==e.mode;m=p(l,o,e,n,t?M:null),t&&(d=M.sampledElevation)}const u=r(E,i.objectTransformation),T=a(v,u[12],u[13],u[14]);c.DISABLE_ELEVATION_ALIGNERS_ITERATIVE_UPDATES?(S[0]=l.x,S[1]=l.y,S[2]=m,s(l.spatialReference,S,u,n.spatialReference)&&(i.objectTransformation=u)):n.setAltitudeOfTransformation(m,u);const g=y/n.unitInMeters;return(Math.abs(u[12]-T[0])>=g||Math.abs(u[13]-T[1])>=g||Math.abs(u[14]-T[2])>=g)&&(i.objectTransformation=u),d}const E=n();function h(e,o,r,n){const i=e.graphics3DSymbolLayer.lodRenderer;if(t(i))return 0;const l=o.centerPointInElevationSR;let m=0,f=0;const d="absolute-height"!==o.mode;m=p(l,r,o,n,d?M:null),d&&(f=M.sampledElevation);const u=i.instanceData,T=e.instanceIndex,g=O;u.getGlobalTransform(T,g);const b=a(v,g[12],g[13],g[14]);c.DISABLE_ELEVATION_ALIGNERS_ITERATIVE_UPDATES?(S[0]=l.x,S[1]=l.y,S[2]=m,s(l.spatialReference,S,g,n.spatialReference)&&u.setGlobalTransform(T,g)):n.setAltitudeOfTransformation(m,g);const A=y/n.unitInMeters;return(Math.abs(g[12]-b[0])>=A||Math.abs(g[13]-b[1])>=A||Math.abs(g[14]-b[2])>=A)&&u.setGlobalTransform(T,g),f}let y=.01,I=!0;const j=new e,S=o(),R=o(),D=o(),O=n(),v=o(),M={verticalDistanceToGround:0,sampledElevation:0};export{I as iterativeUpdatesEnabled,h as perLodInstanceElevationAligner,A as perObjectElevationAligner,g as perVertexElevationAligner,y as updateThresholdInMeters,b as uvElevationAligner};
