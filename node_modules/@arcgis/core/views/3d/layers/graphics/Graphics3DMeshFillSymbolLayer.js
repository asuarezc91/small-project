/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import"../../../../core/has.js";import{isSome as e,get as t}from"../../../../core/maybe.js";import r from"../../../../Color.js";import{Z as a,O as s,c as o}from"../../../../chunks/vec3f64.js";import{b as n,a as i,d as l,n as u,f as c,c as m,i as h,t as p}from"../../../../chunks/vec3.js";import{a as f}from"../../../../chunks/mat4.js";import{projectBuffer as d,computeLinearTransformation as g,canProjectWithoutEngine as x}from"../../../../geometry/projection.js";import{a as _}from"../../../../chunks/mat3f64.js";import{b,a as y}from"../../../../chunks/mat4f64.js";import{O as v}from"../../../../chunks/vec4f64.js";import T from"../../../../geometry/support/MeshMaterialMetallicRoughness.js";import C from"../../../../geometry/support/MeshComponent.js";import{f as w,t as A}from"../../../../chunks/mat3.js";import{projectNormalToECEF as O,projectTangentToECEF as M}from"../../../../geometry/support/meshUtils/projection.js";import{empty as I,expandWithBuffer as N,intersectsClippingArea as P,create as R}from"../../../../geometry/support/aaBoundingBox.js";import{VertexAttrConstants as S}from"../../webgl-engine/lib/Util.js";import{GeometryData as j}from"../../webgl-engine/lib/GeometryData.js";import E from"../../webgl-engine/lib/Object3D.js";import B from"../../support/debugFlags.js";import{needsElevationUpdates3D as F}from"./elevationAlignmentUtils.js";import{perObjectElevationAligner as V}from"./ElevationAligners.js";import{ElevationContext as L}from"./ElevationContext.js";import U from"./Graphics3DObject3DGraphicLayer.js";import G from"../../webgl-engine/lib/Geometry.js";import{createMaterial as $}from"../support/edgeUtils.js";import{Graphics3DSymbolLayer as D}from"./Graphics3DSymbolLayer.js";import{DefaultMaterial as z}from"../../webgl-engine/materials/DefaultMaterial.js";import k from"../../webgl-engine/lib/Texture.js";import{parseColorMixMode as H,encodeSymbolColor as W}from"../support/symbolColorUtils.js";import{NativeLineMaterial as q}from"../../webgl-engine/materials/NativeLineMaterial.js";const Y=S;class Z extends D{constructor(e,t,r,a){super(e,t,r,a),this._materials=new Map,this._textures=new Map,this.ensureDrapedStatus(!1)}async doLoad(){B.DRAW_MESH_GEOMETRY_NORMALS&&(this._debugVertexNormalMaterial=new q({color:[1,0,1,1]},"debugVertexNormal"),this._debugFaceNormalMaterial=new q({color:[0,1,1,1]},"debugFAceNormal"))}destroy(){super.destroy(),this._materials.forEach((e=>{this._context.stage.remove(3,e.material.id)})),this._textures.forEach((e=>{this._context.stage.remove(4,e.id)})),this._materials.clear(),this._textures.clear()}createGraphics3DGraphic(e){const t=e.graphic;if(!this._validateGeometryType(t.geometry,Z.validGeometryTypes,"fill on mesh-3d"))return null;if(!this._validateGeometry(t.geometry))return null;const r="graphic"+t.uid,a=this.setGraphicElevationContext(t,new L),s=e.renderingInfo;return this._createAs3DShape(t,s,a,r,t.uid)}layerOpacityChanged(t,r){const a=this._getLayerOpacity();return this._materials.forEach((e=>{e.material.setParameterValues({layerOpacity:a});const t=e.material.params;this._setMaterialTransparentParameter(t,e),e.material.setParameterValues({transparent:t.transparent})})),t.forEach((t=>{const s=r(t);e(s)&&s.layerOpacityChanged(a,this._context.isAsync)})),!0}layerElevationInfoChanged(e,t){return this.updateGraphics3DGraphicElevationInfo(e,t,F)}slicePlaneEnabledChanged(t,r){return this._materials.forEach((e=>{e.material.setParameterValues({slicePlaneEnabled:this._context.slicePlaneEnabled})})),t.forEach((t=>{const a=r(t);e(a)&&a.slicePlaneEnabledChanged(this._context.slicePlaneEnabled,this._context.isAsync)})),!0}physicalBasedRenderingChanged(){return this._materials.forEach((e=>{const{isSchematic:t}=e.material.params;e.material.setParameterValues({usePBR:this._usePBR(t)})})),!0}pixelRatioChanged(){return!0}_requiresSymbolVertexColors(){return this._drivenProperties.color||this._drivenProperties.opacity}_colorOrTextureUid(e){return e?e instanceof r?e.toHex():e.contentHash:"-"}_materialPropertiesDefault(e,t){const r=this._requiresSymbolVertexColors(),a=!!e.vertexAttributes.color,s=!!e.vertexAttributes.tangent;return{hasSymbolVertexColors:r,hasVertexColors:a,hasVertexTangents:s,uid:`vc:${a},vt:${s},vct${t},svc:${r}`}}_materialProperties(e,t,r){const a=this._materialPropertiesDefault(e,r);if(!t.material)return a;const{color:s,colorTexture:o,normalTexture:n,doubleSided:i,alphaCutoff:l,alphaMode:u}=t.material,c=this._colorOrTextureUid(s),m=this._colorOrTextureUid(o),h=this._colorOrTextureUid(n);if(a.color=s,a.colorTexture=o,a.normalTexture=n,a.uid=`${a.uid},cmuid:${c},ctmuid:${m},ntmuid:${h},ds:${i},ac:${l},am:${u}`,t.material instanceof T){const{metallic:e,roughness:r,metallicRoughnessTexture:s,emissiveColor:o,emissiveTexture:n,occlusionTexture:i}=t.material,l=this._colorOrTextureUid(s),u=this._colorOrTextureUid(o),c=this._colorOrTextureUid(n),m=this._colorOrTextureUid(i);a.metallic=e,a.roughness=r,a.metallicRoughnessTexture=s,a.emissiveColor=o,a.emissiveTexture=n,a.occlusionTexture=i,a.uid=`${a.uid},mrm:${e},mrr:${r},mrt:${l},emuid:${u},etmuid:${c},otmuid:${m}`}return a}_setInternalColorValueParameters(e,t){t.diffuse=r.toUnitRGB(e),t.opacity=e.a}_getLoadableTextureResource(e){return e.data?e.data:e.url}_getInternalTextureId(e,t){const r=this._getLoadableTextureResource(e);if(!r)return;const a=e.contentHash;let s=this._textures.get(a);return s||(s=new k(r,`${t}_${a}_tex`,{mipmap:!0,wrap:this._castTextureWrap(e.wrap),noUnpackFlip:!0,preMultiplyAlpha:!0}),this._textures.set(a,s),this._context.stage.add(4,s)),s.id}_castTextureWrap(e="repeat"){if("string"==typeof e){const t=this._castTextureWrapIndividual(e);return{s:t,t:t}}return{s:this._castTextureWrapIndividual(e.horizontal),t:this._castTextureWrapIndividual(e.vertical)}}_castTextureWrapIndividual(e){switch(e){case"clamp":return 33071;case"mirror":return 33648;case"repeat":default:return 10497}}_setInternalMaterialParameters(e,t,a){e.color&&this._setInternalColorValueParameters(e.color,a),e.colorTexture&&(a.textureId=this._getInternalTextureId(e.colorTexture,t)),e.normalTexture&&(a.normalTextureId=this._getInternalTextureId(e.normalTexture,t)),e.emissiveColor&&(a.emissiveFactor=r.toUnitRGB(e.emissiveColor)),e.emissiveTexture&&(a.emissiveTextureId=this._getInternalTextureId(e.emissiveTexture,t)),e.occlusionTexture&&(a.occlusionTextureId=this._getInternalTextureId(e.occlusionTexture,t)),e.metallicRoughnessTexture&&(a.metallicRoughnessTextureId=this._getInternalTextureId(e.metallicRoughnessTexture,t))}_setExternalMaterialParameters(t){const a=this._drivenProperties.color;let s=e(this.symbolLayer.material)?this.symbolLayer.material.colorMixMode:null;if(a)t.externalColor=v;else{const a=e(this.symbolLayer.material)?this.symbolLayer.material.color:null;e(a)?t.externalColor=r.toUnitRGBA(a):(s=null,t.externalColor=v)}s&&(t.colorMixMode=s),t.castShadows=!!this.symbolLayer.castShadows}_hasTransparentVertexColors(e){const t=e.vertexAttributes.color;if(!t)return!1;for(let e=3;e<t.length;e+=4)if(255!==t[e])return!0;return!1}_getOrCreateMaterial(e,t){const r=t.material&&t.material.color,o=t.material&&t.material.colorTexture,n=t.material&&"blend"===t.material.alphaMode,i=!(t.material&&"opaque"===t.material.alphaMode)&&(this._hasTransparentVertexColors(e)||r&&r.a<1||o&&o.transparent||n),l=this._materialProperties(e,t,i),u=this._materials.get(l.uid);if(u)return u.material;const c={material:null,isComponentTransparent:i,alphaMode:t.material?t.material.alphaMode:"opaque"},m=this._getIdHint(),h=null==l.metallicRoughnessTexture&&null==l.metallic&&null==l.roughness,p={usePBR:this._usePBR(h),isSchematic:h,vertexColors:l.hasVertexColors,symbolColors:l.hasSymbolVertexColors,vertexTangents:l.hasVertexTangents,ambient:a,diffuse:s,opacity:1,doubleSided:!0,doubleSidedType:"winding-order",cullFace:0,textureAlphaPremultiplied:!0,layerOpacity:this._getLayerOpacity(),slicePlaneEnabled:this._context.slicePlaneEnabled,initTextureTransparent:!0};h||(p.mrrFactors=[null!=l.metallic?l.metallic:1,null!=l.roughness?l.roughness:1,.5]),t.material&&(p.doubleSided=t.material.doubleSided,p.cullFace=t.material.doubleSided?0:2,p.textureAlphaCutoff=t.material.alphaCutoff),this._setInternalMaterialParameters(l,m,p),this._setExternalMaterialParameters(p),this._setMaterialTransparentParameter(p,c);const f=new z(p,`${m}_${l.uid}_mat`);return c.material=f,this._materials.set(l.uid,c),this._context.stage.add(3,f),f}_usePBR(e){return!e||this._context.physicalBasedRenderingEnabled}_setMaterialTransparentParameter(e,t){e.transparent=this.needsDrivenTransparentPass||t.isComponentTransparent||e.layerOpacity<1||e.opacity<1||e.externalColor&&e.externalColor[3]<1,"auto"===t.alphaMode?e.textureAlphaMode=e.transparent?3:1:e.textureAlphaMode="opaque"===t.alphaMode?1:"mask"===t.alphaMode?2:0}_addDebugNormals(e,t,r,a){const s=t.length,o=e.spatialReference.isGeographic?20015077/180:1,l=.1*Math.max(e.extent.width*o,e.extent.height*o,e.extent.zmax-e.extent.zmin),u=[],c=[],m=[],h=[];for(let e=0;e<s;e++){const r=t[e],a=r.data.getAttribute(Y.POSITION),s=r.data.getAttribute(Y.NORMAL),o=r.data.getIndices(Y.POSITION),p=r.data.getIndices(Y.NORMAL),f=a.data,d=s.data;for(let e=0;e<o.length;e++){const t=3*o[e],r=3*p[e];for(let e=0;e<3;e++)u.push(f[t+e]);for(let e=0;e<3;e++)u.push(f[t+e]+d[r+e]*l);if(c.push(c.length),c.push(c.length),e%3==0){this._calculateFaceNormal(f,o,e,ee),this._getFaceVertices(f,o,e,K,Q,X),n(K,K,Q),n(K,K,X),i(K,K,1/3);for(let e=0;e<3;e++)m.push(K[e]);for(let e=0;e<3;e++)m.push(K[e]+ee[e]*l);h.push(h.length),h.push(h.length)}}}{const e={[Y.POSITION]:{data:new Float64Array(u),size:3}},s={[Y.POSITION]:new Uint32Array(c)},o=new j(e,s,"line"),n=new G(o,"debugVertexNormal");t.push(n),r.push(this._debugVertexNormalMaterial),a.push(b(a[0]))}{const e={[Y.POSITION]:{data:new Float64Array(m),size:3}},s={[Y.POSITION]:new Uint32Array(h)},o=new j(e,s,"line"),n=new G(o,"debugFaceNormal");t.push(n),r.push(this._debugFaceNormalMaterial),a.push(b(a[0]))}}_createAs3DShape(t,r,a,s,o){const n=t.geometry;if("mesh"!==n.type)return null;const i=this._createGeometryInfo(n,r,s);if(!i)return null;const{geometries:l,materials:u,transformations:c,objectTransformation:m}=i;B.DRAW_MESH_GEOMETRY_NORMALS&&this._addDebugNormals(n,l,u,c);const h=new E({geometries:l,materials:u,transformations:c,castShadow:!0,metadata:{layerUid:this._context.layer.uid,graphicUid:o},idHint:s});h.objectTransformation=m;const p=V,f=this._createEdgeMaterial(),d=e(f)?{baseMaterial:u[0],edgeMaterials:[f],properties:{mergeGeometries:!0,slicePlaneEnabled:this._context.slicePlaneEnabled}}:null,g=new U(this,h,l,null,null,p,a,d);g.needsElevationUpdates=F(a.mode);const x=n.extent.center.clone();return x.z=0,g.elevationContext.centerPointInElevationSR=x,g.alignedSampledElevation=p(g,g.elevationContext,this._context.elevationProvider,this._context.renderCoordsHelper),g}_createComponentNormals(e,t,r,a){switch(r.shading||"flat"){case"source":return this._createComponentNormalsSource(e,t,r,a);case"flat":return this._createComponentNormalsFlat(e,a);case"smooth":return this._createComponentNormalsSmooth(e,a);default:return}}_createComponentNormalsSource(e,t,r,a){if(!t)return this._createComponentNormalsFlat(e,a);let s=!1;if(!r.trustSourceNormals)for(let r=0;r<a.length;r+=3){this._calculateFaceNormal(e,a,r,ee);for(let e=0;e<3;e++){const o=3*a[r+e];K[0]=t[o+0],K[1]=t[o+1],K[2]=t[o+2],l(ee,K)<0&&(t[o+0]=-t[o+0],t[o+1]=-t[o+1],t[o+2]=-t[o+2],s=!0)}}return{normals:t,indices:a,didFlipNormals:s}}_createComponentNormalsFlat(e,t){const r=new Float32Array(t.length),a=new Uint32Array(3*t.length);for(let s=0;s<t.length;s+=3){const o=this._calculateFaceNormal(e,t,s,ee);for(let e=0;e<3;e++)r[s+e]=o[e],a[s+e]=s/3}return{normals:r,indices:a,didFlipNormals:!1}}_createComponentNormalsSmooth(e,t){const r={};for(let a=0;a<t.length;a+=3){const s=this._calculateFaceNormal(e,t,a,ee);for(let e=0;e<3;e++){const i=t[a+e];let l=r[i];l||(l={normal:o(),count:0},r[i]=l),n(l.normal,l.normal,s),l.count++}}const a=new Float32Array(3*t.length),s=new Uint32Array(3*t.length);for(let e=0;e<t.length;e++){const o=r[t[e]];1!==o.count&&(u(o.normal,o.normal),o.count=1);for(let t=0;t<3;t++)a[3*e+t]=o.normal[t];s[e]=e}return{normals:a,indices:s,didFlipNormals:!1}}_getFaceVertices(e,t,r,a,s,o){const n=3*t[r+0],i=3*t[r+1],l=3*t[r+2];a[0]=e[n+0],a[1]=e[n+1],a[2]=e[n+2],s[0]=e[i+0],s[1]=e[i+1],s[2]=e[i+2],o[0]=e[l+0],o[1]=e[l+1],o[2]=e[l+2]}_calculateFaceNormal(e,t,r,a){return this._getFaceVertices(e,t,r,K,Q,X),c(Q,Q,K),c(X,X,K),m(K,Q,X),u(a,K),a}_getOrCreateComponents(e){return e.components?e.components:se}_createPositionBuffer(e){const t=e.vertexAttributes.position,r=new Float64Array(t.length),a=this._context.renderCoordsHelper.spatialReference;return d(e.vertexAttributes.position,e.spatialReference,0,r,a,0,t.length/3),r}_createNormalBuffer(e,t){const r=e.vertexAttributes.normal;if(!r)return null;if("local"===this._context.layerView.view.viewingMode)return r;const a=e.vertexAttributes.position,s=new Float32Array(r.length);return O(r,a,t,e.spatialReference,s)}_createTangentBuffer(e,t){const r=e.vertexAttributes.tangent;if(!r)return null;if("local"===this._context.layerView.view.viewingMode)return r;const a=e.vertexAttributes.position,s=new Float32Array(r.length);return M(r,a,t,e.spatialReference,s)}_createColorBuffer(e){return e.vertexAttributes.color}_createSymbolColorBuffer(e){if(this._requiresSymbolVertexColors()){const r=this._getVertexOpacityAndColor(e),a=H(t(this.symbolLayer,"material","colorMixMode")),s=new Uint8Array(4);return W(r,a,s),s}return null}_createColorIndices(e){const t=new Uint32Array(e.length);for(let e=0;e<t.length;e++)t[e]=0;return t}_createBuffers(e,t){const r=e.vertexAttributes&&e.vertexAttributes.position;if(!r)return this.logger.warn("Mesh geometry must contain position vertex attributes"),null;const a=e.vertexAttributes.normal,s=e.vertexAttributes.uv,o=e.vertexAttributes.tangent;if(a&&a.length!==r.length)return this.logger.warn("Mesh normal vertex buffer must contain the same number of elements as the position buffer"),null;if(o&&o.length/4!=r.length/3)return this.logger.warn("Mesh tangent vertex buffer must contain the same number of elements as the position buffer"),null;if(s&&s.length/2!=r.length/3)return this.logger.warn("Mesh uv vertex buffer must contain the same number of elements as the position buffer"),null;const n=this._createPositionBuffer(e),i=this._createColorBuffer(e),l=this._createSymbolColorBuffer(t),u=this._createNormalBuffer(e,n);return{positionBuffer:n,normalBuffer:u,tangentBuffer:this._createTangentBuffer(e,n),uvBuffer:s,colorBuffer:i,symbolColorBuffer:l,objectTransformation:this._transformCenterLocal(e,n,u)}}_transformCenterLocal(e,t,r){const a=e.extent.center,s=this._context.renderCoordsHelper.spatialReference;J[0]=a.x,J[1]=a.y,J[2]=0;const o=y();g(e.spatialReference,J,o,s),f(te,o);for(let e=0;e<t.length;e+=3)K[0]=t[e+0],K[1]=t[e+1],K[2]=t[e+2],h(K,K,te),t[e+0]=K[0],t[e+1]=K[1],t[e+2]=K[2];if(r){w(re,o),A(re,re);for(let e=0;e<r.length;e+=3)K[0]=r[e+0],K[1]=r[e+1],K[2]=r[e+2],p(K,K,re),r[e+0]=K[0],r[e+1]=K[1],r[e+2]=K[2]}return o}_validateFaces(e,t){const r=e.vertexAttributes.position.length/3,a=t.faces;if(a){let e=-1;for(let t=0;t<a.length;t++){const r=a[t];r>e&&(e=r)}if(r<=e)return this.logger.warn(`Vertex index ${e} is out of bounds of the mesh position buffer`),!1}else if(r%3!=0)return this.logger.warn("Mesh position buffer length must be a multiple of 9 if no component faces are defined (3 values per vertex * 3 vertices per triangle)"),!1;return!0}_getOrCreateFaces(e,t){if(t.faces)return t.faces;{const t=new Uint32Array(e.vertexAttributes.position.length/3);for(let e=0;e<t.length;e++)t[e]=e;return t}}_isOutsideClippingArea(e){if(!this._context.clippingExtent)return!1;const t=e.vertexAttributes&&e.vertexAttributes.position;if(!t)return!1;const r=this._context.elevationProvider.spatialReference;let a;const s=t.length/3;return e.spatialReference.equals(r)?a=t:(a=new Float64Array(t.length),d(e.vertexAttributes.position,e.spatialReference,0,a,r,0,s)),I(ae),N(ae,a,0,s),!P(ae,this._context.clippingExtent)}_createGeometryInfo(e,t,r){if(!x(e.spatialReference,this._context.layerView.view.spatialReference))return this.logger.warn("Geometry spatial reference is not compatible with the view"),null;if(this._isOutsideClippingArea(e))return null;const a=this._createBuffers(e,t);if(!a)return null;const{positionBuffer:s,uvBuffer:o,colorBuffer:n,symbolColorBuffer:i,normalBuffer:l,tangentBuffer:u,objectTransformation:c}=a,m=this._getOrCreateComponents(e),h=[],p=[],f=[];let d=!1;for(const t of m){if(!this._validateFaces(e,t))return null;const a=this._getOrCreateFaces(e,t);if(0===a.length)continue;const c=this._createComponentNormals(s,l,t,a);c.didFlipNormals&&(d=!0);const m={[Y.POSITION]:{size:3,data:s},[Y.NORMAL]:{size:3,data:c.normals}},g={[Y.POSITION]:a,[Y.NORMAL]:c.indices};n&&(m[Y.COLOR]={size:4,data:n},g[Y.COLOR]=a),i&&(m[Y.SYMBOLCOLOR]={size:4,data:i},g[Y.SYMBOLCOLOR]=this._createColorIndices(a)),e.vertexAttributes.uv&&(m[Y.UV0]={size:2,data:o},g[Y.UV0]=a),e.vertexAttributes.tangent&&(m[Y.TANGENT]={size:4,data:u},g[Y.TANGENT]=a);const x=new j(m,g),_=new G(x,`${r}_mesh`);h.push(_),p.push(y()),f.push(this._getOrCreateMaterial(e,t))}return d&&this.logger.warn("Normals have been automatically flipped to be consistent with the counter clock wise face winding order. It is better to generate mesh geometries that have consistent normals."),{geometries:h,transformations:p,materials:f,objectTransformation:c}}_createEdgeMaterial(){const e={opacity:this._getLayerOpacity()};return $(this.symbolLayer,e)}}Z.validGeometryTypes=["mesh"];const J=o(),K=o(),Q=o(),X=o(),ee=o(),te=y(),re=_(),ae=R(),se=[new C];export default Z;export{Z as Graphics3DMeshFillSymbolLayer};
