/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{mixin as e}from"../../../../core/lang.js";import{isSome as t,unwrap as r}from"../../../../core/maybe.js";import n from"../../../../core/Logger.js";import a from"../../../../core/Error.js";import{throwIfAbortError as s,resolve as o,all as i}from"../../../../core/promiseUtils.js";import u from"../../../../request.js";import{result as l}from"../../../../core/asyncUtils.js";import{d as c}from"../../../../chunks/vec3f64.js";import{Version as p}from"../../../../core/Version.js";import{empty as m,expandWithVec3 as f}from"../../../../geometry/support/aaBoundingBox.js";import{requestImage as d}from"../../../../support/requestImageUtils.js";import{GeometryData as y}from"../../webgl-engine/lib/GeometryData.js";import g from"../../webgl-engine/lib/Geometry.js";import{DefaultMaterial as x}from"../../webgl-engine/materials/DefaultMaterial.js";import w from"../../webgl-engine/lib/Texture.js";const b=n.getLogger("esri.views.3d.layers.graphics.objectResourceUtils");async function h(e,n){const a=await async function(e,n){const a=t(n)&&n.streamDataRequester;if(a)return async function(e,t,r){const n=await l(t.request(e,"json",r));if(!0===n.ok)return n.value;return s(n.error),void v(n.error.details.url)}(e,a,n);const o=await l(u(e,r(n)));if(!0===o.ok)return o.value.data;return s(o.error),void v(o.error)}(e,n);return{resource:a,textures:await M(a.textureDefinitions,n)}}function v(e){throw new a("",`Request for object resource failed: ${e}`)}function j(e){const t=e.params,r=t.topology;let n=!0;switch(t.vertexAttributes||(b.warn("Geometry must specify vertex attributes"),n=!1),t.topology){case"PerAttributeArray":break;case"Indexed":case null:case void 0:{const e=t.faces;if(e){if(t.vertexAttributes)for(const r in t.vertexAttributes){const t=e[r];t&&t.values?(null!=t.valueType&&"UInt32"!==t.valueType&&(b.warn(`Unsupported indexed geometry indices type '${t.valueType}', only UInt32 is currently supported`),n=!1),null!=t.valuesPerElement&&1!==t.valuesPerElement&&(b.warn(`Unsupported indexed geometry values per element '${t.valuesPerElement}', only 1 is currently supported`),n=!1)):(b.warn(`Indexed geometry does not specify face indices for '${r}' attribute`),n=!1)}}else b.warn("Indexed geometries must specify faces"),n=!1;break}default:b.warn(`Unsupported topology '${r}'`),n=!1}e.params.material||(b.warn("Geometry requires material"),n=!1);const a=e.params.vertexAttributes;for(const e in a){a[e].values||(b.warn("Geometries with externally defined attributes are not yet supported"),n=!1)}return n}function A(r,n){const a=[],s=[],o=[],i=[],u=r.resource,l=p.parse(u.version||"1.0","wosr");P.validate(l);const m=u.model.name,f=u.model.geometries,d=u.materialDefinitions,b=r.textures;let h=0;const v=new Map;for(let r=0;r<f.length;r++){const u=f[r];if(!j(u))continue;const l=T(u),p=u.params.vertexAttributes,A={};for(const e in p){const t=p[e],r=t.values;A[e]={data:r,size:t.valuesPerElement}}const U={};if("PerAttributeArray"===u.params.topology){const e=k(A.position.data.length/A.position.size);for(const t in A)U[t]=e}else{const e=u.params.faces;for(const t in e)U[t]=new Uint32Array(e[t].values)}const M=b&&b[l.texture];if(M&&!v.has(l.texture)){const{image:e,params:t}=M,r=new w(e,m,t);i.push(r),v.set(l.texture,r)}const P=v.get(l.texture),B=P?P.id:void 0;let E=o[l.material]?o[l.material][l.texture]:null;if(!E){const r=d[l.material.substring(l.material.lastIndexOf("/")+1)].params;1===r.transparency&&(r.transparency=0);const a=M&&M.alphaChannelUsage,s=r.transparency>0||"transparency"===a||"maskAndTransparency"===a,i={ambient:c(r.diffuse),diffuse:c(r.diffuse),opacity:1-(r.transparency||0),transparent:s,textureAlphaMode:M?I(M.alphaChannelUsage):void 0,textureAlphaCutoff:.33,textureId:B,initTextureTransparent:!0,doubleSided:!0,cullFace:0,colorMixMode:r.externalColorMixMode||"tint",textureAlphaPremultiplied:!0};t(n)&&n.materialParamsMixin&&e(i,n.materialParamsMixin),E=new x(i,m),o[l.material]||(o[l.material]={}),o[l.material][l.texture]=E}s.push(E);const q=new g(new y(A,U),m);h+=U.position?U.position.length:0,a.push(q)}return{name:m,stageResources:{textures:i,materials:s,geometries:a},pivotOffset:u.model.pivotOffset,boundingBox:U(a),numberOfVertices:h,lodThreshold:null}}function U(e){const t=m();return e.forEach((e=>{const r=e.boundingInfo;f(t,r.getBBMin()),f(t,r.getBBMax())})),t}async function M(e,r){const n=[];for(const a in e){const s=e[a],i=s.images[0].data;if(!i){b.warn("Externally referenced texture data is not yet supported");continue}const u=s.encoding+";base64,"+i,l="/textureDefinitions/"+a,c={noUnpackFlip:!0,wrap:{s:10497,t:10497},preMultiplyAlpha:!0},p=t(r)&&r.disableTextures?o(null):d(u,r);n.push(p.then((e=>({refId:l,image:e,params:c,alphaChannelUsage:"rgba"===s.channels?s.alphaChannelUsage||"transparency":"none"}))))}const a=await i(n),s={};for(const e of a)s[e.refId]=e;return s}function I(e){switch(e){case"mask":return 2;case"maskAndTransparency":return 3;case"none":return 1;case"transparency":default:return 0}}function T(e){const t=e.params;return{id:1,material:t.material,texture:t.texture,region:t.texture}}function k(e){const t=new Uint32Array(e);for(let r=0;r<e;r++)t[r]=r;return t}const P=new p(1,2,"wosr");export{M as createTextureResources,h as load,A as processLoadResult};
