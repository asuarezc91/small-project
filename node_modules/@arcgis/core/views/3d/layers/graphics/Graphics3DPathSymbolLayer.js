/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{mixin as e}from"../../../../core/lang.js";import{isSome as t,get as i}from"../../../../core/maybe.js";import r from"../../../../core/Error.js";import{sign as a,acosClamped as s,reciprocalClamped as o}from"../../../../core/mathUtils.js";import{d as n,c as l}from"../../../../chunks/vec3f64.js";import{s as h,b as c,d as p,c as m,a as d,n as u,p as f,f as y}from"../../../../chunks/vec3.js";import{projectBuffer as g}from"../../../../geometry/projection.js";import{f as _}from"../../../../chunks/vec2f64.js";import{s as b,a as v}from"../../../../chunks/vec2.js";import{create as x,empty as w,expandWithBuffer as S,intersectsClippingArea as P}from"../../../../geometry/support/aaBoundingBox.js";import{makeDehydratedPoint as C}from"../../../../layers/graphics/dehydratedFeatures.js";import{c as D}from"../../../../chunks/vec3f32.js";import R from"../../webgl-engine/lib/Object3D.js";import{isValidSize as V}from"./graphicUtils.js";import{needsElevationUpdates3D as j,evaluateElevationAlignmentAtPoint as E}from"./elevationAlignmentUtils.js";import{ElevationContext as L}from"./ElevationContext.js";import z from"./Graphics3DObject3DGraphicLayer.js";import A from"../../webgl-engine/lib/Geometry.js";import{Graphics3DSymbolLayer as G,getAttributeValue as U}from"./Graphics3DSymbolLayer.js";import{DefaultMaterial as k}from"../../webgl-engine/materials/DefaultMaterial.js";import{initFastSymbolUpdatesState as F,updateFastSymbolUpdatesState as B}from"../support/FastSymbolUpdates.js";import{s as M}from"../../../../chunks/mat2.js";import I from"../../webgl-engine/lib/pathGeometryUtils.js";import{PathMaterial as T}from"../../webgl-engine/materials/PathMaterial.js";class O extends G{constructor(e,t,i,r){super(e,t,i,r),this._intrinsicSize=_(1,1),this.upVectorAlignment="path",this.stencilWidth=.1,this.ensureDrapedStatus(!1)}async doLoad(){const a=t(this.symbolLayer.width)?this.symbolLayer.width:t(this.symbolLayer.height)?this.symbolLayer.height:this.symbolLayer.size,s=t(this.symbolLayer.height)?this.symbolLayer.height:a;this._vvConvertOptions={modelSize:[1,1,1],symbolSize:[a,1,s],unitInMeters:this._context.renderCoordsHelper.unitInMeters,transformation:{anchor:[0,0,0],scale:[1,1,1],rotation:[0,0,0]},supportedTypes:{size:!0,color:!0,opacity:!0,rotation:!1}},this._context.renderer&&this._context.renderer.visualVariables&&this._context.renderer.visualVariables.length>0?this._fastUpdates=F(this._context.renderer,this._vvConvertOptions):this._fastUpdates={enabled:!1};const o=this.symbolLayer.anchor||"center";this.upVectorAlignment="path","heading"===this.symbolLayer.profileRotation&&(this.upVectorAlignment="world");const l=this.symbolLayer.profile||"circle";switch(l){case"circle":default:this._profile=I.Profile.circle(Y);break;case"quad":this._profile=I.Profile.rect()}let h=[0,0];"center"!==o&&(h={left:[.5,0],right:[-.5,0],top:[0,-.5],bottom:[0,.5]}[o],this._profile.translate(h[0],h[1]));switch(this.symbolLayer.join||"simple"){case"round":this._extruder=new I.MiterExtruder(0,Q);break;case"bevel":this._extruder=new I.MiterExtruder(0,1);break;case"miter":this._extruder=new I.MiterExtruder(.8*Math.PI,1);break;case"simple":default:this._extruder=new I.SimpleExtruder}const c=this.symbolLayer.cap||"butt";switch(c){case"none":this._startCap=new I.NoCapBuilder,this._endCap=new I.NoCapBuilder;break;case"butt":default:this._startCap=new I.TriangulationCapBuilder(this._profile,0),this._endCap=new I.TriangulationCapBuilder(this._profile,0,!0);break;case"square":this._startCap=new I.TriangulationCapBuilder(this._profile,-.5),this._endCap=new I.TriangulationCapBuilder(this._profile,.5,!0);break;case"round":{const e="quad"===l;this._startCap=new I.RoundCapBuilder({profile:this._profile,flip:!1,breakNormals:e,subdivisions:X}),this._endCap=new I.RoundCapBuilder({profile:this._profile,flip:!0,breakNormals:e,subdivisions:X});break}}const p=this._getIdHint(),m=i(this.symbolLayer,"material","color"),d=this._getCombinedOpacityAndColor(m),u=n(d),f=d[3],y={diffuse:u,ambient:u,opacity:f,transparent:f<1||this.needsDrivenTransparentPass,vertexColors:!1,slicePlaneEnabled:this._context.slicePlaneEnabled,castShadows:this.symbolLayer.castShadows,cullFace:"none"===c?0:void 0,offsetTransparentBackfaces:!0};if(!this._drivenProperties.size&&(b(this._intrinsicSize,a,s),!V(this._intrinsicSize[0])||!V(this._intrinsicSize[1])))throw new r("graphics3dpathsymbollayer:invalid-size","Symbol sizes may not be negative values");this._fastUpdates.enabled&&this._fastUpdates.visualVariables.size||v(this._intrinsicSize,this._intrinsicSize,1/this._context.renderCoordsHelper.unitInMeters),this._fastUpdates.enabled?(e(y,this._fastUpdates.materialParameters,{size:[this._intrinsicSize[0],this._intrinsicSize[1],0]}),this._material=new T(y,`${p}_pathmat`)):(y.vertexColors=this._drivenProperties.color||this._drivenProperties.opacity,this._material=new k(y,`${p}_pathmat`)),this._material.setParameterValues({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),this._context.stage.add(3,this._material)}destroy(){super.destroy(),this._material&&(this._context.stage.remove(3,this._material.id),this._material=null)}createGraphics3DGraphic(e){const t=e.graphic;if(!this._validateGeometryType(t.geometry,O.validGeometryTypes,this.symbolLayer.type))return null;if(!this._validateGeometry(t.geometry))return null;const i="graphic"+t.uid,r=this.setGraphicElevationContext(t,new L),a=e.renderingInfo;return this._createAs3DShape(t,a,r,i,t.uid)}layerOpacityChanged(){const e=i(this.symbolLayer,"material","color"),t=this._getCombinedOpacity(e),r=t<1||this.needsDrivenTransparentPass;return this._material.setParameterValues({opacity:t,transparent:r}),!0}layerElevationInfoChanged(e,t){return this.updateGraphics3DGraphicElevationInfo(e,t,j)}slicePlaneEnabledChanged(){return this._material.setParameterValues({slicePlaneEnabled:this._context.slicePlaneEnabled}),!0}physicalBasedRenderingChanged(){return this._material.setParameterValues({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),!0}pixelRatioChanged(){return!0}applyRendererDiff(e,t){for(const i in e.diff)switch(i){case"visualVariables":if(!B(this._fastUpdates,t,this._vvConvertOptions))return!1;this._material.setParameterValues(this._fastUpdates.materialParameters);break;default:return!1}return!0}getVertexData(e){let t=0;const i=e.paths,r=[],a=e.spatialReference,s=this._context.elevationProvider.spatialReference,o=this._context.renderCoordsHelper.spatialReference;for(const e of i)t+=e.length;const n=new Float64Array(3*t),l=new Float64Array(3*t),h=new Float64Array(3*t);let c=0;for(const t of i){r.push({index:c,numVertices:t.length});for(const i of t)n[c++]=i[0],n[c++]=i[1],n[c++]=e.hasZ?i[2]:0}let p=!0;return a.equals(s)?this._copyVertices(n,0,l,0,t):p=g(n,a,0,l,s,0,t),s.equals(o)?this._copyVertices(l,0,h,0,t):g(l,s,0,h,o,0,t),{pathVertexDataInfos:r,vertexDataGS:n,vertexDataES:l,vertexDataRS:h,projectionSuccess:p,terrainElevation:0}}_copyVertices(e,t,i,r,a){t*=3,r*=3;for(let s=0;s<a;++s)i[r++]=e[t++],i[r++]=e[t++],i[r++]=e[t++]}_createAs3DShape(e,i,r,a,s){const o=e.geometry,n=[],l=[],c=[],p=o.spatialReference,m=x(),d=this._context.renderCoordsHelper,u=this.getVertexData(o);if(!u.projectionSuccess)return this.logger.warn("PathSymbol3DLayer geometry failed to be created (failed to project geometry to view spatial reference)"),null;if(u.pathVertexDataInfos.length>0){for(let s=0;s<u.pathVertexDataInfos.length;++s){const o=u.pathVertexDataInfos[s],f=o.index,y=o.numVertices;if(y<2){this.logger.warn("PathSymbol3DLayer geometry failed to be created (paths should contain at least 2 vertices)");continue}if(t(this._context.clippingExtent)&&(w(m),S(m,u.vertexDataES,3*f,y),!P(m,this._context.clippingExtent)))continue;const g=[];for(let e=f;e<f+3*y;){const t=e++,i=e++,a=e++,s=new I.PathVertex;h(s.posGS,u.vertexDataGS[t],u.vertexDataGS[i],u.vertexDataGS[a]),h(s.posES,u.vertexDataES[t],u.vertexDataES[i],u.vertexDataES[a]);const o=E(s.posES,this._context.elevationProvider,r,d,null);h(Z,u.vertexDataRS[t],u.vertexDataRS[i],u.vertexDataRS[a]),d.setAltitude(o,Z),h(s.pos,Z[0],Z[1],Z[2]),g.push(s)}const _=new I.Path(g);H(_,this.upVectorAlignment,this._context.renderCoordsHelper);const b=new I.Builder(_,this._profile,this._extruder,this._startCap,this._endCap);let v=null;if(this._fastUpdates.enabled){const t=this._fastUpdates.visualVariables,i=t.size?U(t.size.field,e):0,r=t.color?U(t.color.field,e):0,a=t.opacity?U(t.opacity.field,e):0;v=new I.FastUpdatePathGeometry(b,i,r,a)}else{const e=[this._intrinsicSize[0],this._intrinsicSize[1]];this._drivenProperties.size&&(e[0]*=q(i.size[0],"symbol-value"===i.size[2]?this.symbolLayer.height||0:i.size[2],this.symbolLayer.width||0),e[1]*=q(i.size[2],"symbol-value"===i.size[0]?this.symbolLayer.width||0:i.size[0],this.symbolLayer.height||0));let t=null;this._drivenProperties.color&&(t=i.color),this._drivenProperties.opacity&&null!=i.opacity&&(t=t?[t[0],t[1],t[2],i.opacity]:[1,1,1,i.opacity]);const r=new I.StaticPathGeometry(b);r.bake(e),t&&r.bakeVertexColors(t),v=r}const x=v.createGeometryData(),C=new A(x,a+"path"+s),D={pathGeometry:v,geometrySR:p,upVectorAlignment:this.upVectorAlignment,stencilWidth:this.stencilWidth};C.metadata=D,n.push(C),l.push(this._material),c.push(v.xform)}const o={layerUid:this._context.layer.uid,graphicUid:s};if(n.length>0){const e=new R({geometries:n,materials:l,transformations:c,castShadow:!0,metadata:o,idHint:a}),t=new z(this,e,n,null,null,W,r);return t.alignedSampledElevation=u.terrainElevation,t.needsElevationUpdates=j(r.mode),t}}else this.logger.warn("PathSymbol3DLayer geometry failed to be created (no paths were defined)");return null}}function H(e,t,i){switch(t){case"world":for(const t of e.vertices)c(J,t.pos,e.offset),i.worldUpAtPosition(J,Z),t.setFrameFromUpVector(Z),t.computeRotationAxisAndAngleFromUpVector();break;case"path":c(J,e.vertices[0].pos,e.offset),i.worldUpAtPosition(J,Z),I.computeMinimumRotationTangentFrame(e,Z);for(const t of e.vertices){const e=a(p(t.frame.right,t.vRight));m(t.rotationFrame.up,t.vRight,t.vLeft),d(t.rotationFrame.up,t.rotationFrame.up,e),u(t.rotationFrame.up,t.rotationFrame.up);const i=p(t.rotationFrame.up,t.frame.up),r=p(t.rotationFrame.up,t.frame.right);if(d(J,t.frame.up,-r),d(K,t.frame.right,i),c(J,J,K),u(t.rotationFrame.right,J),I.vertexSpaceToProfileSpace(t.rotationRight,t.frame,t.rotationFrame.right),f(J,t.vLeft),t.rotationAngle=-e*(Math.PI-s(p(J,t.vRight))),Math.abs(t.rotationAngle)>0){const e=o(Math.cos(.5*t.rotationAngle));M(t.miterStretch,1+(e-1)*t.rotationRight[0]*t.rotationRight[0],(e-1)*t.rotationRight[0]*t.rotationRight[1],(e-1)*t.rotationRight[0]*t.rotationRight[1],1+(e-1)*t.rotationRight[1]*t.rotationRight[1])}const n=Math.PI-t.rotationAngle;t.maxStretchDistance=Math.abs(Math.min(t.vLeftLength,t.vRightLength)*o(Math.cos(.5*n)))}}}function q(e,t,i){switch(e){case"symbol-value":return i;case"proportional":return t;default:return e}}function N(e,t,i,r){let a=0;for(const s of e.vertices){const o=E(s.posES,i,t,r,ee);a+=ee.sampledElevation,c(Z,s.pos,e.offset),r.setAltitude(o,Z),y(s.pos,Z,e.offset)}return e.updatePathVertexInformation(),a/e.vertices.length}function W(e,t,i,r){const a=e.stageObject,s=a.geometryRecords,o=s.length;let n=0;$.spatialReference=r.spatialReference;for(let e=0;e<o;e++){const o=s[e].geometry,l=o.metadata,h=l.pathGeometry,c=h.builder.path;l.geometrySR;n+=N(c,t,i,r),"world"!==c.upVector&&H(c,l.upVectorAlignment,r),h.onPathChanged(),o.invalidateBoundingInfo(),a.geometryVertexAttrsUpdated(e)}return n/o}O.validGeometryTypes=["polyline"];const $=C(0,0,0,null),Z=l(),J=D(),K=D(),Q=3,X=3,Y=10,ee={verticalDistanceToGround:0,sampledElevation:0};export default O;export{O as Graphics3DPathSymbolLayer,Y as NUM_CIRCLE_PROFILE_SUBDIVISIONS,X as NUM_ROUND_CAP_EXTRUSION_SUBDIVISIONS,Q as NUM_ROUND_JOIN_SUBDIVISIONS};
