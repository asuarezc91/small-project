/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{isNone as t,isSome as e,get as s}from"../../../../core/maybe.js";import{onAbortOrThrow as r,throwIfAborted as o}from"../../../../core/promiseUtils.js";import{forEach as a}from"../../../../core/asyncUtils.js";import i from"./Graphics3DObject3DGraphicLayer.js";import{Loadable as n}from"./Loadable.js";import{totalSymbolComplexities as y}from"./symbolComplexity.js";import l from"./Graphics3DGraphic.js";import{make as h}from"./Graphics3DSymbolLayerFactory.js";const c={renderPriority:0,renderPriorityStep:1,ignoreDrivers:!1};export default class extends n{constructor(t,e,s){super(),this._symbol=t,this._context=e,this._backgroundLayers=s,this._destroyed=!1,this.symbolLayers=[],this.referenced=0,this._extentPadding=0}set symbol(e){if(this._symbol=e,this.symbolLayers)for(let s=0;s<e.symbolLayers.length;s++){const r=this.symbolLayers[s];t(r)||(r.symbol=e,r.symbolLayer=e.symbolLayers.items[s])}}get symbol(){return this._symbol}async doLoad(t){let s=this._symbol.symbolLayers;this._extentPadding=0,this._backgroundLayers&&(s=this._backgroundLayers.concat(s));const i=s.length;for(;this.symbolLayers.length<s.length;)this.symbolLayers.push(null);this.symbolLayers.length=s.length;const n=[];for(let e=0;e<i;e++){const o=s.getItemAt(e);if(!1===o.enabled)continue;c.renderPriority=1-(1+e)/i,c.renderPriorityStep=1/i,c.ignoreDrivers=o._ignoreDrivers;const a=h(this.symbol,o,this._context,c);n.push(r(t,(()=>{this.symbolLayers[e]=null,a.destroy()}))),this.symbolLayers[e]=a}await a(this.symbolLayers,(async(t,s)=>{if(e(t))try{await t.load(),this._extentPadding+=Math.max(this._extentPadding,t.extentPadding)}catch{this.symbolLayers[s]=null}}));for(const t of n)null==t||t.remove();if(n.length=0,o(t),this.symbolLayers.length&&!this.symbolLayers.some((t=>!!t)))throw new Error}getSymbolLayerSize(t){const s=this.symbolLayers[t];return e(s)?s.getCachedSize():null}get extentPadding(){return this._extentPadding}createGraphics3DGraphic(t,s){const r=t.graphic,o=new Array(this.symbolLayers.length);for(let s=0;s<this.symbolLayers.length;s++){const r=this.symbolLayers[s];o[s]=e(r)?r.createGraphics3DGraphic(t):null}const a=this._context.arcade||this._context.featureExpressionInfoContext&&this._context.featureExpressionInfoContext.arcade&&this._context.featureExpressionInfoContext.arcade.modules||null;return new l(r,s||this,o,t.layer,a)}get complexity(){return y(this.symbolLayers.map((t=>s(t,"complexity"))))}globalPropertyChanged(t,s){const r=this.symbolLayers.length;for(let o=0;o<r;o++){const r=this.symbolLayers[o],a=t=>{const e=t._graphics[o];return e instanceof i?e:null};if(e(r)&&!r.globalPropertyChanged(t,s,a))return!1}return!0}applyRendererDiff(e,s){return 1===this.loadStatus&&this.symbolLayers.reduce(((r,o)=>r&&(t(o)||o.applyRendererDiff(e,s))),!0)}prepareSymbolPatch(s){if(2===this.loadStatus)return;if("partial"!==s.diff.type)return;const r=s.diff.diff;if(!r.symbolLayers||"partial"!==r.symbolLayers.type)return;const o=r.symbolLayers.diff;this.symbolLayers.forEach(((r,a)=>{if(t(r))return;const i=o[a];if(i){const t={diff:i,graphics3DGraphicPatches:[],symbolLayerStatePatches:[]};r.prepareSymbolLayerPatch(t),s.symbolStatePatches.push(...t.symbolLayerStatePatches),t.graphics3DGraphicPatches.length&&s.graphics3DGraphicPatches.push(((s,r)=>{const o=s._graphics[a];e(o)&&t.graphics3DGraphicPatches.forEach((t=>t(o,r)))}))}}))}updateGeometry(e,s){for(let r=0;r<this.symbolLayers.length;r++){const o=this.symbolLayers[r];if(t(o))continue;const a=e._graphics[r];if(t(a)||!o.updateGeometry(a,s))return!1}return!0}onRemoveGraphic(s){for(let r=0;r<this.symbolLayers.length;r++){const o=this.symbolLayers[r];if(t(o))continue;const a=s._graphics[r];e(a)&&o.onRemoveGraphic(a)}}getFastUpdateStatus(){let e=0,s=0,r=0;return this.symbolLayers.forEach((o=>{t(o)||(0===o.loadStatus?e++:o.isFastUpdatesEnabled()?r++:s++)})),{loading:e,slow:s,fast:r}}destroy(){if(this.destroyed)console.error("Graphics3DSymbol.destroy called when already destroyed!");else{this.abortLoad();for(const t of this.symbolLayers)e(t)&&t.destroy();this.symbolLayers.length=0,this._destroyed=!0}}get destroyed(){return this._destroyed}}
