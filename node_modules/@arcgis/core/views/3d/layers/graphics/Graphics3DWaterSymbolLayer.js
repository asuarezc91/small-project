/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{isSome as e,isNone as t,unwrap as r}from"../../../../core/maybe.js";import o from"../../../../Color.js";import{t as i}from"../../../../chunks/common.js";import{getMetersPerUnitForSR as a}from"../../../../core/unitUtils.js";import{empty as n,expandPointInPlace as s,create as l}from"../../../../geometry/support/aaBoundingRect.js";import{I as u}from"../../../../chunks/mat4f64.js";import{f as c,a as m}from"../../../../chunks/vec2f64.js";import{earcut as d}from"../../../../core/libs/earcut/earcut.js";import{s as h}from"../../../../chunks/vec2.js";import{b as p}from"../../../../chunks/vec4.js";import{empty as y,expandWithBuffer as g,intersectsClippingArea as f,expandWithAABB as v,create as _}from"../../../../geometry/support/aaBoundingBox.js";import x from"../../webgl-engine/lib/Object3D.js";import{elevationModeChangeUpdateType as D,SymbolUpdateType as b,needsElevationUpdates2D as C}from"./elevationAlignmentUtils.js";import{perVertexElevationAligner as E}from"./ElevationAligners.js";import{ElevationContext as w}from"./ElevationContext.js";import G from"./Graphics3DObject3DGraphicLayer.js";import S from"../../webgl-engine/lib/Geometry.js";import{Graphics3DSymbolLayer as T}from"./Graphics3DSymbolLayer.js";import{geometryAsPolygon as j,geometryToRenderInfo as A,createWaterGeometryData as U,geometryToRenderInfoDraped as P}from"./polygonUtils.js";import M from"./Graphics3DDrapedGraphicLayer.js";import B from"../../webgl-engine/lib/RenderGeometry.js";import{defaultWaterMaterialParameters as R,wavePresets as O}from"../../webgl-engine/materials/internal/waterMaterialUtils.js";import{WaterMaterial as L}from"../../webgl-engine/materials/WaterMaterial.js";class N extends T{constructor(e,t,r,o){super(e,t,r,o)}async doLoad(){}destroy(){super.destroy(),e(this._material)&&(this._context.stage.remove(3,this._material.id),this._material=null)}createGraphics3DGraphic(e){const t=e.graphic;if(!this._validateGeometryType(t.geometry,N.validGeometryTypes,this.symbolLayer.type))return null;if(!this._validateGeometry(t.geometry))return null;const r="graphic"+t.uid,o=this.setGraphicElevationContext(t,new w);return this.ensureDrapedStatus("on-the-ground"===o.mode),this.ensureMaterial(),this.draped?this._createAsOverlay(t,r):this._createAs3DShape(t,o,r,t.uid)}ensureMaterial(){if(e(this._material))return;const t={...R},r=this.symbolLayer.color;e(r)&&(t.color=o.toUnitRGBA(r));const i=this._getCombinedOpacity(r,{hasIntrinsicColor:!0});t.color=[t.color[0],t.color[1],t.color[2],i],t.transparent=i<1||this.needsDrivenTransparentPass,t.waveDirection=e(this.symbolLayer.waveDirection)?N.headingVectorFromAngle(this.symbolLayer.waveDirection):c(0,0);const a=this.symbolLayer.waveStrength+"-"+this.symbolLayer.waterbodySize,n=O[a];t.waveStrength=n.waveStrength,t.waveTextureRepeat=n.textureRepeat,t.waveVelocity=n.waveVelocity,t.flowStrength=n.perturbationStrength,t.slicePlaneEnabled=this._context.slicePlaneEnabled,t.isDraped=this.draped,this._material=new L(t,"water"),this._context.stage.add(3,this._material)}layerOpacityChanged(){if(t(this._material))return!0;const e=this._material.params.color,r=this._getCombinedOpacity(this.symbolLayer.color,{hasIntrinsicColor:!0}),o=r<1||this.needsDrivenTransparentPass;return this._material.setParameterValues({color:[e[0],e[1],e[2],r],transparent:o}),!0}layerElevationInfoChanged(e,t,r){const o=this._elevationContext.mode,i=D(N.elevationModeChangeTypes,r,o);if(i!==b.UPDATE)return i;const a=C(o);return this.updateGraphics3DGraphicElevationInfo(e,t,(()=>a))}slicePlaneEnabledChanged(){return e(this._material)&&this._material.setParameterValues({slicePlaneEnabled:this._context.slicePlaneEnabled}),!0}physicalBasedRenderingChanged(){return!0}pixelRatioChanged(){return!0}_createAs3DShape(e,r,o,i){const a=j(e.geometry);if(t(a))return null;W.renderData=A(a,this._context.elevationProvider,this._context.renderCoordsHelper,r);const n=W.renderData.position.length/3;if(W.uvCoords=new Float64Array(2*n),W.idHint=o,W.outNum=0,W.outGeometries=[],W.outTransforms=[],W.outMaterials=[],this._create3DShapeGeometries(W),this._logGeometryCreationWarnings(W.renderData,a.rings,"rings","WaterSymbol3DLayer"),0===W.outNum)return null;this._createUVCoordsFromVertices(W.uvCoords,W.renderData.mapPosition,n,this._context.elevationProvider.spatialReference);const s=new x({geometries:W.outGeometries,materials:W.outMaterials,transformations:W.outTransforms,castShadow:!1,metadata:{layerUid:this._context.layer.uid,graphicUid:i},idHint:o}),l=E,u=new G(this,s,W.outGeometries,null,null,l,r);return u.alignedSampledElevation=W.renderData.sampledElevation,u.needsElevationUpdates=C(r.mode),u}_createUVCoordsFromVertices(e,t,r,o){const i=a(o);n(F);for(let e=0;e<r;e++)h(H,t[3*e+0],t[3*e+1]),s(F,H);p(F,F,i);const l=F[0]%N.unitSizeOfTexture,u=F[1]%N.unitSizeOfTexture;V[0]=F[0]-l,V[1]=F[1]-u;for(let o=0;o<r;o++)e[2*o+0]=(t[3*o+0]*i-V[0])/N.unitSizeOfTexture,e[2*o+1]=(t[3*o+1]*i-V[1])/N.unitSizeOfTexture}_create3DShapeGeometries(t){const o=t.renderData.polygons,i=t.uvCoords;for(const{count:a,index:n,position:s,mapPosition:l,holeIndices:c}of o){if(e(this._context.clippingExtent)&&(y(I),g(I,l),!f(I,this._context.clippingExtent)))continue;const o=d(l,c,3);if(0===o.length)continue;const m=new Uint32Array(o),h=new Float64Array(i.buffer,2*n*i.BYTES_PER_ELEMENT,2*a),p=U({indices:m,attributeData:{position:s,uv0:h,mapPosition:l}}),v=new S(p,t.idHint);t.outGeometries.push(v),t.outMaterials.push(r(this._material)),t.outTransforms.push(u),t.outNum++}}_createAsOverlay(e,o){const i=j(e.geometry);if(t(i))return null;r(this._material).renderPriority=this._renderPriority,z.renderData=P(i,this._context.overlaySR),z.idHint=o;const a=z.renderData.position.length/3;return z.uvCoords=new Float64Array(2*a),z.outNum=0,z.outGeometries=[],z.outBoundingBox=y(),z.layerUid=this._context.layer.uid,z.graphicsUid=e.uid,this._createAsOverlayWater(z),this._logGeometryCreationWarnings(z.renderData,i.rings,"rings","WaterSymbol3DLayer"),0===z.outNum?null:(this._createUVCoordsFromVertices(z.uvCoords,z.renderData.position,a,this._context.overlaySR),z.outNum>0?new M(this,z.outGeometries,z.outBoundingBox):null)}_createAsOverlayWater(e){const t=e.uvCoords,o=e.renderData.polygons;for(const{position:i,holeIndices:a,index:n,count:s}of o){if(y(I),g(I,i),!f(I,this._context.clippingExtent))continue;v(e.outBoundingBox,I);const o=d(i,a,3);if(0===o.length)continue;const l=new Uint32Array(o),u=new Float64Array(t.buffer,2*n*t.BYTES_PER_ELEMENT,2*s),c=U({indices:l,attributeData:{position:i,uv0:u}}),m=new B(c);m.data.layerUid=e.layerUid,m.data.graphicUid=e.graphicsUid,m.material=r(this._material);const h=I;m.center=[.5*(h[0]+h[3]),.5*(h[1]+h[4]),0],m.bsRadius=.5*Math.sqrt((h[3]-h[0])*(h[3]-h[0])+(h[4]-h[1])*(h[4]-h[1])),e.outGeometries.push(m),e.outNum++}}static headingVectorFromAngle(e){const t=m(),r=i(e);return t[0]=Math.sin(r),t[1]=Math.cos(r),t}get test(){return{create3DShape:e=>this._createAs3DShape(e.graphic,e.elevationContext,e.idHint,e.graphicUid),ensureMaterial:()=>this.ensureMaterial()}}}N.validGeometryTypes=["polyline","polygon","extent"],N.unitSizeOfTexture=100,N.elevationModeChangeTypes={definedChanged:b.RECREATE,staysOnTheGround:b.NONE,onTheGroundChanged:b.RECREATE};const V=m(),F=l(),H=m(),I=_(),W={idHint:null,renderData:null,uvCoords:null,outNum:0,outBoundingBox:null,outGeometries:null,outMaterials:null,outTransforms:null},z={idHint:null,renderData:null,uvCoords:null,outNum:0,outBoundingBox:null,outGeometries:null,outMaterials:null,outTransforms:null};export default N;export{N as Graphics3DWaterSymbolLayer};
