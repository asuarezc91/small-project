/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{isNone as e,unwrap as t,get as s,isSome as i}from"../../../../core/maybe.js";import r from"../../../../core/Logger.js";import{splitIntoChunks as a,remove as n}from"../../../../core/arrayUtils.js";import{createAbortController as o,whenOrAbort as c,all as d}from"../../../../core/promiseUtils.js";import{formatNumber as h}from"../../../../intl/number.js";import l from"../../../../request.js";import{resultOrAbort as u,result as m}from"../../../../core/asyncUtils.js";import{estimateStringByteSize as g,estimateNumberByteSize as p}from"../../../../core/byteSizeEstimations.js";import{getMaximumQuerySize as b,queryAllJSON as f}from"../../../../layers/support/featureQueryAll.js";const y=r.getLogger("esri.views.3d.layers.i3s.I3SAttributeOverrides");class v{constructor(e,t){this.layer=e,this.warnMaximumChangedObjectsExceeded=!1,this.changedObjectIds=new Set,this.pendingFetchAbortController=o(),this.interactiveEditingSessions=null,this.memCache=t.getMemCache(`${e.uid}-attribute-overrides`),this.pendingFetchChangedObjectIds=this.fetchChangedObjectIds(this.pendingFetchAbortController.signal),this.pendingFetchChangedObjectIds.then((()=>this.pendingFetchAbortController=null))}destroy(){this.layer=null,this.memCache.destroy(),this.memCache=null,this.pendingFetchAbortController&&(this.pendingFetchAbortController.abort(),this.pendingFetchAbortController=null),this.pendingFetchChangedObjectIds=null}createInteractiveEditSession(t){this.changedObjectIds.add(t),e(this.interactiveEditingSessions)&&(this.interactiveEditingSessions=[]);const s=this.interactiveEditingSessions,i=new j(t,{rollback:()=>{n(s,i),0===s.length&&(this.interactiveEditingSessions=null)},commit:e=>{for(const[s,i]of e)this.updateValue(t,s,i)}});return s.unshift(i),i}async apply(t,s,i){if(e(s))return;const{loadedAttributes:r,attributeData:a}=s;if(e(r)||0===r.length||e(a))return;if(await c(this.pendingFetchChangedObjectIds,i),0===this.changedObjectIds.size)return;const n={loadedAttributes:r,attributeData:a},o=this.getOverridesFromCache(t,n,this.changedObjectIds),{objectIds:d,fieldNames:h}=o,l=await this.queryOverridesFromAssociatedLayer(d,h,i);e(l)||this.processOverridesFromAssociatedLayer(t,l,h,n)}updateValue(e,t,s){this.changedObjectIds.add(e),this.cacheValue(e,t,s)}cacheValue(e,t,s){this.memCache.put(this.getCacheKey(e,t),s,this.memCacheValueSize(s))}getOverridesFromCache(e,{loadedAttributes:t,attributeData:s},i){const r=new Set,a=new Array;for(const e of t)a[e.index]=s[e.name];const n=new Set;for(let s=0;s<e.length;s++){const o=e[s];if(i.has(o))for(const e of t){const t=this.fromCache(o,e.index);void 0===t?(r.add(o),n.add(e.name)):a[e.index][s]=t}}return{objectIds:Array.from(r),fieldNames:Array.from(n)}}fromCache(e,t){const s=this.fromInteractiveEditingSession(e,t);if(void 0!==s)return s;const i=this.getCacheKey(e,t);return this.memCache.get(i)}fromInteractiveEditingSession(t,s){if(!e(this.interactiveEditingSessions))for(const e of this.interactiveEditingSessions){if(e.objectId!==t)continue;const i=e.get(s);if(void 0!==i)return i}}getCacheKey(e,t){return`${e}-${t}`}async queryOverridesFromAssociatedLayer(e,s,i){if(0===e.length||0===s.length)return null;e=e.sort(((e,t)=>e-t)),this.warnMaximumChangedObjectsExceeded&&(this.warnMaximumChangedObjectsExceeded=!1,this.logMaximumObjectsExceededWarning());const r=t(this.layer.associatedLayer),n=r.createQuery();n.where="1=1",n.returnGeometry=!1,n.outFields=[r.objectIdField,...s],n.cacheHint=!0,n.objectIds=e;const o=b(r),c=e.length>o?a(e,o).map((e=>{const t=n.clone();return t.objectIds=e,u(f(r,t,{signal:i}))})):[u(f(r,n,{signal:i}))];return(await d(c)).reduce(((e,t)=>e.concat(t.ok?t.value.features:[])),[])}logMaximumObjectsExceededWarning(){let e=`The number of edited objects that are not yet cached in the scene service exceeds the maximum limit. Attribute changes will only be available for the first ${h(I)} objects. Please consider re-caching the scene service`;const t=this.layer.portalItem;t&&t.loaded?e+=` (${t.portal.url}/home/item.html?id=${t.id}#settings)`:e+=` (${this.layer.parsedUrl.path})`,y.warn(`("${this.layer.title}"):`,`${e}.`)}processOverridesFromAssociatedLayer(e,s,i,{loadedAttributes:r,attributeData:a}){const n=t(this.layer.associatedLayer).objectIdField,o=i.map((e=>a[e])),c=new Map(r.map((e=>[e.name,e.index]))),d=i.map((e=>c.get(e))),h=new Map(Array.from(e,((e,t)=>[e,t])));for(const e of s){const t=e.attributes[n];for(let s=0;s<i.length;s++){const r=d[s],a=h.get(t),n=e.attributes[i[s]];o[s][a]=n,this.cacheValue(t,r,n)}}}memCacheValueSize(e){return"string"==typeof e?g(e):p()}async fetchChangedObjectIds(t){var r,a,n;const o=this.layer;if(this.changedObjectIds.clear(),e(o.associatedLayer)||null==(r=o.associatedLayer.capabilities)||null==(a=r.operations)||!a.supportsChangeTracking)return;const c=this.getFetchChangedObjectIdsServerGen();if(e(c))return null;const d=o.associatedLayer.layerId,h=await m(l(`${o.associatedLayer.url}/extractChanges`,{method:"post",query:{f:"json",returnIdsOnly:!0,layers:`${d}`,returnUpdates:!0,returnDeletes:!1,returnInserts:!1,layerServerGens:JSON.stringify([{id:d,serverGen:c}])},timeout:C,signal:t})),u=h.ok&&null!=(n=h.value.data)&&n.edits?s(h.value.data.edits[0],"objectIds","updates"):null;if(i(u)){const e=Math.min(I,u.length);e<u.length&&(this.warnMaximumChangedObjectsExceeded=!0);const t=u.sort(((e,t)=>e-t));for(let s=0;s<e;s++)this.changedObjectIds.add(t[s])}}getFetchChangedObjectIdsServerGen(){const e=this.layer;if(i(e.serviceUpdateTimeStamp)&&i(e.serviceUpdateTimeStamp.lastUpdate))return e.serviceUpdateTimeStamp.lastUpdate;const t=e.associatedLayer;return i(t)&&i(t.serverGens)&&i(t.serverGens.minServerGen)?t.serverGens.minServerGen:null}}class j{constructor(e,t){this.objectId=e,this.options=t,this.updates=new Map,this.state=0}get(e){return this.updates.get(e)}set(e,t){this.isActive&&this.updates.set(e,t)}rollback(){this.isActive&&(this.state=2,this.options.rollback())}commit(){this.isActive&&(this.state=1,this.options.commit(this.updates),this.updates.clear())}get isActive(){return 0===this.state}}const C=1e4,I=5e4;export{v as I3SAttributeOverrides};
