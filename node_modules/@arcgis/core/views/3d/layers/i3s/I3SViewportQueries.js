/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{isSome as t,isNone as e}from"../../../../core/maybe.js";import{c as s}from"../../../../chunks/vec3f64.js";import{h as i,k as r,l as n,a,d as o,o as h,f as c,b as m}from"../../../../chunks/vec3.js";import{getSphericalPCPF as p}from"../../../../geometry/projectionEllipsoid.js";import{projectBoundingSphere as l}from"../../../../geometry/projection.js";import{c as d}from"../../../../chunks/vec4.js";import{makeDehydratedPoint as u}from"../../../../layers/graphics/dehydratedFeatures.js";import{frustum as _,sphere as b}from"../../support/geometryUtils.js";import{evaluateElevationAlignmentAtPoint as x}from"../graphics/elevationAlignmentUtils.js";import{createContextWithoutExpressionSupport as M,extractExpressionInfo as f}from"../graphics/featureExpressionInfoUtils.js";import{ElevationContext as v}from"../graphics/ElevationContext.js";import{create as D,isVisible as g}from"../../support/orientedBoundingBox.js";import{transformObb as P,intersectBoundingBoxWithMbs as R}from"./I3SUtil.js";export default class{constructor(t,e,i,r,n,a,o={}){this.indexSR=t,this._renderCoordsHelper=e,this.extent=r,this.elevationProvider=n,this.options=o,this._fp=_.create(),this._poi=s(),this.minDistance=1/0,this.maxDistance=0,this.maxLodLevel=2,this._tmp1=s(),this._tmp2=s(),this._tmp3=s(),this._tmp0=s(),this.screenspaceErrorBias=o.screenspaceErrorBias||1,this.progressiveLoadFactor=o.progressiveLoadFactor||1,this.updateCamera(i),this.engineSR=this._renderCoordsHelper.spatialReference,this.updateElevationInfo(a),this.tmpPoint=u(0,0,0,t)}updateElevationInfo(t){null!=t?(this._elevationContext=v.fromElevationInfo(t),this._elevationContext.updateFeatureExpressionInfoContext(M(f(t,!1)))):this._elevationContext=null}updateCamera(t){_.fromMatrix(t.viewMatrix,t.projectionMatrix,this._fp),this._screenSizeFactor=1/(t.perScreenPixelRatio/2),this._camPos=t.eye,this.minDistance=1/0,this.maxDistance=0}setPointOfInterest(t){this._poi=t}updateScreenSpaceErrorBias(t){const e=this.screenspaceErrorBias;return this.screenspaceErrorBias=t,e}updateExtent(t){this.extent=t}getRenderMbs(t){const e=t.renderMbs;return e[3]<0&&(d(e,t.mbs),this._elevationContext&&e[3]<1e5&&(this.tmpPoint.x=e[0],this.tmpPoint.y=e[1],this.tmpPoint.z=e[2],e[2]=x(this.tmpPoint,this.elevationProvider,this._elevationContext,this._renderCoordsHelper)),l(e,this.indexSR,e,this.engineSR)),e}getVisibilityObb(s){if(t(s.visibilityObb))return s.visibilityObb;const i=s.serviceObb;return e(i)||i.halfSize[0]<0?void 0:(s.serviceObbInRenderSR=this._computeRenderObb(i,s.serviceObbInRenderSR,s.mbs[3]),s.serviceObbInRenderSR)}_computeRenderObb(t,s,i){if(e(s)&&(s=D()),s.halfSize[0]<0){let e=0;this._elevationContext&&i<1e5&&(this.tmpPoint.x=t.center[0],this.tmpPoint.y=t.center[1],this.tmpPoint.z=t.center[2],e=x(this.tmpPoint,this.elevationProvider,this._elevationContext,this._renderCoordsHelper)-t.center[2]),P(t,this.indexSR,s,this.engineSR,e)}return s}isNodeVisible(e){const s=this.getRenderMbs(e);if(!this.isMBSinExtent(s))return!1;const i=this.getVisibilityObb(e);return t(i)?g(i,this._fp):_.intersectsSphere(this._fp.planes,b.wrap(s[3],s))}isGeometryVisible(e){const s=e.geometryObb;return t(s)?g(s,this._fp):this.isNodeVisible(e)}isMBSinExtent(t){return!this.extent||0!==R(this.extent,t)}screenSpaceDiameterMbs(t,e){const s=this.getRenderMbs(t),r=Math.sqrt(i(s,this._camPos)),n=r-s[3];return this._updateMinMaxDistance(r),n<0?.5*Number.MAX_VALUE:e/n*this._screenSizeFactor}calcCameraDistance(t){return this.calcCameraDistanceToCenter(t)-this.getRenderMbs(t)[3]}calcCameraDistanceToCenter(t){const e=this.getRenderMbs(t),s=r(e,this._camPos);return this._updateMinMaxDistance(s),s}calcAngleDependentLoD(t){const e=this.getRenderMbs(t),s=e[3],i=(Math.abs(e[0]*(e[0]-this._camPos[0])+e[1]*(e[1]-this._camPos[1])+e[2]*(e[2]-this._camPos[2]))/n(e)+s)/r(e,this._camPos);return Math.min(1,i)}hasLOD(t){return 0!==t.lodMetric}getDistancePlanarMode(t,e){const s=t[0]-e[0],i=t[1]-e[1],r=t[2]-e[2],n=s*s+i*i,a=e[3];if(n<=a*a)return Math.abs(r);const o=Math.sqrt(n)-a;return Math.sqrt(r*r+o*o)}getDistanceGlobeMode(t,e){const s=n(e),p=n(t)-s;a(this._tmp0,t,o(t,e)/h(t));const l=i(e,this._tmp0),d=e[3];if(l<=d*d)return Math.abs(p);{const i=a(this._tmp0,e,1/s),h=s,l=d*d/2/h,u=a(this._tmp1,i,h-l),_=t,b=c(this._tmp2,_,u),x=c(this._tmp2,b,a(this._tmp3,i,o(i,b))),M=m(this._tmp2,u,a(this._tmp2,x,d/n(x)));let f=r(_,M);if(p>=2e5){const t=c(this._tmp1,_,M);let e=o(t,i)/n(t);e<.08&&(e=1e-4),f/=e}return f}}getDistance(t,e){return this.engineSR===p(this.engineSR)?this.getDistanceGlobeMode(t,e):this.getDistancePlanarMode(t,e)}_updateMinMaxDistance(t){t>0?(this.minDistance=Math.min(this.minDistance,t),this.maxDistance=Math.max(this.maxDistance,t)):(this.minDistance=0,this.maxDistance=Math.max(this.maxDistance,-t))}getLodLevel(t){if(0===t.lodMetric||!t.resources.hasFeatureData)return 0;if(0===t.childCount)return this.maxLodLevel;if(this.progressiveLoadFactor<1){const e=this.progressiveLoadFactor*this.screenspaceErrorBias,s=this.screenspaceErrorBias;return this.evaluateLODmetric(t,e)?this.evaluateLODmetric(t,s)?2:1:0}return this.evaluateLODmetric(t,this.screenspaceErrorBias)?this.maxLodLevel:0}evaluateLODmetric(t,e){switch(t.lodMetric){case 2:{const s=this.getRenderMbs(t),i=this.getDistance(this._camPos,s),r=2*i/this._screenSizeFactor,n=i+s[3];return this._updateMinMaxDistance(n),t.maxError*e<=r}case 1:{let s=this.screenSpaceDiameterMbs(t,t.mbs[3]*e);return this.options.angleDependentLoD&&(s*=this.calcAngleDependentLoD(t)),s<t.maxError}case 3:return this.screenSpaceDiameterMbs(t,t.maxError)*e<10;case 4:return this.calcCameraDistance(t)>t.maxError*e}return!1}distToPOI(t){const e=this.getRenderMbs(t);return r(e,this._poi)-e[3]}distCameraToPOI(){return r(this._camPos,this._poi)}}
