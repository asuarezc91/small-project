/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import"../../../core/has.js";import{unwrap as t}from"../../../core/maybe.js";import e from"../../../geometry/SpatialReference.js";import{g as s}from"../../../chunks/vec3.js";import{getReferenceEllipsoid as o}from"../../../geometry/projectionEllipsoid.js";import{getMetersPerUnitForSR as i}from"../../../core/unitUtils.js";import{d as r}from"../../../chunks/mat4.js";import{projectPointToVector as n,projectVectorToVector as a,projectVectorToDehydratedPoint as c,projectVectorToPoint as m}from"../../../geometry/projection.js";import{isDehydratedPoint as d}from"../../../layers/graphics/dehydratedFeatures.js";import{sv3d as h}from"./stack.js";import{plane as l,sphere as f,boundedPlane as u}from"./geometryUtils.js";import{create as y,setExtent as p,altitudeAt as S,setAltitudeAt as g,setAltitudeOfTransformation as j,normalAt as w,axisAt as M,elevate as R,intersectRayClosestSilhouette as A,intersectRay as _,fromValues as P}from"./geometryUtils/coordinateSystem.js";class b{constructor(t,e,s,o){this.viewingMode=t,this.spatialReference=e,this.unitInMeters=s,this.coordinateSystem=o,this._coordinateSystem=y(o)}set extent(t){t&&p(this.coordinateSystem,t,this.coordinateSystem)}getAltitude(t){return S(this.coordinateSystem,t)}setAltitude(t,e){g(this.coordinateSystem,e,t,e)}setAltitudeOfTransformation(t,e){j(this.coordinateSystem,e,t,e)}worldUpAtPosition(t,e){return w(this.coordinateSystem,t,e)}worldBasisAtPosition(t,e,s){return M(this.coordinateSystem,t,e,s)}basisMatrixAtPosition(t,e){const s=this.worldBasisAtPosition(t,0,h.get()),o=this.worldBasisAtPosition(t,1,h.get()),i=this.worldBasisAtPosition(t,2,h.get());return r(e,s[0],s[1],s[2],0,o[0],o[1],o[2],0,i[0],i[1],i[2],0,0,0,0,1),e}intersectManifoldClosestSilhouette(t,e,s){return R(this.coordinateSystem,e,this._coordinateSystem),A(this._coordinateSystem,t,s),s}intersectManifold(t,e,o){R(this.coordinateSystem,e,this._coordinateSystem);const i=h.get();return!!_(this._coordinateSystem,t,i)&&(s(o,i),!0)}intersectInfiniteManifold(t,e,o){if(1===this.viewingMode)return this.intersectManifold(t,e,o);R(this.coordinateSystem,e,this._coordinateSystem);const i=this._coordinateSystem.value,r=h.get();return!!l.intersectRay(i.plane,t,r)&&(s(o,r),!0)}toRenderCoords(t,e,s){return d(t)?n(t,e,this.spatialReference):a(t,e,s,this.spatialReference)}fromRenderCoords(s,o,i){return d(o)?c(s,this.spatialReference,o,i):o instanceof e?m(s,this.spatialReference,o):a(s,this.spatialReference,o,t(i))}static createGlobal(t){const e=P(f,f.fromValues(o(t).radius,[0,0,0]));return new b(1,t,1,e)}static createLocal(t){const e=P(u,u.fromValues([0,0,0],[v,0,0],[0,v,0])),s=i(t);return new b(2,t,s,e)}static createMode(t,e){switch(t){case 2:return b.createLocal(e);case 1:return b.createGlobal(e);default:return}}}const v=Math.pow(2,50);export{b as RenderCoordsHelper};
