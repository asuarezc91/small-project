/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{neverReached as t}from"../../../core/compilerUtils.js";import{lerp as e}from"../../../core/mathUtils.js";import{c as i}from"../../../chunks/vec3f64.js";import{b as n,a as r,i as o,s,d as a}from"../../../chunks/vec3.js";import{directionFromTo as c}from"./mathUtils.js";import{getReferenceEllipsoid as h}from"../../../geometry/projectionEllipsoid.js";import{a as l}from"../../../chunks/mat4.js";import{center as p}from"../../../geometry/support/aaBoundingRect.js";import{computeLinearTransformation as d,projectVectorToVector as m}from"../../../geometry/projection.js";import{a as g}from"../../../chunks/mat4f64.js";import{empty as x,expandWithVec3 as f,create as u}from"../../../geometry/support/aaBoundingBox.js";import{plane as y,ray as j,lineSegment as b}from"./geometryUtils.js";import{frustumLineSegment as R}from"./intersectionUtils.js";const S=.5*Math.PI,w=S/Math.PI*180;class B{constructor(t){this.renderCoordsHelper=t.renderCoordsHelper,this.extent=new Array(4),this.planes=new Array(6),this.maxSpan=0,this.center={origin:i(),direction:i()};for(let t=0;t<4;t++)this.extent[t]={origin:i(),direction:i(),cap:{next:null,direction:i()}},this.planes[t]=y.create();this.planes[4]=y.create(),this.planes[5]=y.create(),this.planesWithoutFar=this.planes.slice(0,5)}update(t,e,i,o=!0){const s=this.extent;this.toRenderBoundingExtent(t,e,i),n(this.center.origin,s[0].origin,s[2].origin),r(this.center.origin,this.center.origin,.5),this.renderCoordsHelper.worldUpAtPosition(this.center.origin,this.center.direction),o||r(this.center.direction,this.center.direction,-1);for(let t=0;t<4;t++){const e=s[t];this.renderCoordsHelper.worldUpAtPosition(e.origin,e.direction);const i=s[3===t?0:t+1];e.cap.next=i.origin,c(e.cap.direction,e.origin,i.origin),y.fromVectorsAndPoint(e.direction,e.cap.direction,e.origin,this.planes[t]),o||r(e.direction,e.direction,-1)}y.fromVectorsAndPoint(s[0].cap.direction,s[1].cap.direction,s[0].origin,this.planes[4]),o?y.negate(this.planes[4],this.planes[5]):(y.copy(this.planes[4],this.planes[5]),y.negate(this.planes[4],this.planes[4])),this.maxSpan=Math.max(Math.abs(t[0]-t[2]),Math.abs(t[1]-t[3])),this.maxSpanSpatialReference=e,this.minGlobalAltitude=.9*h(this.maxSpanSpatialReference).radius}isVisibleInFrustum(t,e,i=!1){if(null==t)return!1;if(1===this.renderCoordsHelper.viewingMode){const i=this.maxSpanSpatialReference.isGeographic?w:S*e;if(this.maxSpan>i)return!0;if(t.altitude>=this.minGlobalAltitude)return this.isVisibleInFrustumGlobal(t)}if(0===this.maxSpan){const e=this.extent[0];return!(i||!t.intersectsRay(j.wrap(e.origin,e.direction)))}for(let e=0;e<this.extent.length;e++){const n=this.extent[e];if(!i&&t.intersectsRay(j.wrap(n.origin,n.direction)))return!0;if(t.intersectsLineSegment(b.fromPoints(n.origin,n.cap.next,G),n.cap.direction))return!0}const n=i?this.planes:this.planesWithoutFar;for(let e=0;e<t.lines.length;e++){const i=t.lines[e];if(R(n,i.origin,i.endpoint,i.direction))return!0}return!1}toRenderBoundingExtentGlobal(t,i,n){p(t,H),H[2]=n,d(i,H,A,this.renderCoordsHelper.spatialReference),l(M,A),x(E);for(const{x0:r,x1:s,y0:a,y1:c}of C)for(let h=0;h<5;h++){const l=h/4;H[0]=e(t[r],t[s],l),H[1]=e(t[a],t[c],l),H[2]=n,m(H,i,H,this.renderCoordsHelper.spatialReference),o(H,H,M),f(E,H)}s(this.extent[0].origin,E[0],E[1],E[2]),s(this.extent[1].origin,E[3],E[1],E[2]),s(this.extent[2].origin,E[3],E[4],E[2]),s(this.extent[3].origin,E[0],E[4],E[2]);for(let t=0;t<4;++t)o(this.extent[t].origin,this.extent[t].origin,A)}toRenderBoundingExtentLocal(t,e){s(this.extent[0].origin,t[0],t[1],e),s(this.extent[1].origin,t[2],t[1],e),s(this.extent[2].origin,t[2],t[3],e),s(this.extent[3].origin,t[0],t[3],e)}toRenderBoundingExtent(e,i,n){switch(this.renderCoordsHelper.viewingMode){case 1:this.toRenderBoundingExtentGlobal(e,i,n);break;case 2:this.toRenderBoundingExtentLocal(e,n);break;default:t(this.renderCoordsHelper.viewingMode)}}isVisibleInFrustumGlobal(t){if(a(this.center.direction,t.direction)<0)return!0;for(let e=0;e<4;e++){const i=this.extent[e];if(a(i.direction,t.direction)<0)return!0}return!1}}const C=[{x0:0,y0:1,x1:2,y1:1},{x0:0,y0:3,x1:2,y1:3},{x0:0,y0:1,x1:0,y1:3},{x0:2,y0:1,x1:2,y1:3}],H=i(),A=g(),M=g(),E=u(),G=b.create();export default B;export{B as FrustumExtentIntersection};
