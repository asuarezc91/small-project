/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import"../../../core/has.js";import{isSome as e,isNone as t}from"../../../core/maybe.js";import n from"../../../core/Error.js";import{eachAlways as r}from"../../../core/promiseUtils.js";import a from"../../../geometry/SpatialReference.js";import o from"../../../geometry/Geometry.js";import{canProject as i,project as s}from"../../../geometry/support/webMercatorUtils.js";import c from"../../../geometry/Point.js";import l from"../../../geometry/Extent.js";import"../../../geometry.js";import m from"../../../Graphic.js";import{result as f}from"../../../core/asyncUtils.js";import{c as u}from"../../../chunks/vec3f64.js";import{a as p,b as g,k as h,g as y,f as d,s as x,t as w}from"../../../chunks/vec3.js";import{cyclicalDeg as v}from"./mathUtils.js";import b from"../../../Camera.js";import j from"../../../Viewpoint.js";import{isPoint as R,create as G}from"../../../geometry/support/aaBoundingRect.js";import{projectVectorToPoint as z,projectPointToVector as S,projectBuffer as k,computeLinearTransformation as B,projectVectorToVector as M}from"../../../geometry/projection.js";import{a as Z}from"../../../chunks/mat3f64.js";import{a as F}from"../../../chunks/mat4f64.js";import{f as A,t as U}from"../../../chunks/mat3.js";import{empty as E,center as P,toRect as T,isPoint as I,create as N,expandWithVec3 as O,expandWithAABB as V,width as q,height as W,depth as C}from"../../../geometry/support/aaBoundingBox.js";import{getElevationAtPoint as D}from"./ElevationProvider.js";import{frustum as Y}from"./geometryUtils.js";import{cameraOnContentAlongViewDirection as $}from"../camera/intersectionUtils.js";import{internalToExternal as X,scaleToDistance as _,fromCenterDistance as H,fromExtent as J,scaleToResolution as K,zoomToScale as L,externalToInternal as Q,computeScale as ee,AsyncContext as te,distanceToScale as ne,fromCenterScale as re,directionToHeadingTilt as ae}from"./cameraUtils.js";function oe(e){return 360-v.normalize(e)}function ie(e){return v.normalize(360-e)}function se(t){return e(t)&&t.resolver&&t.resolver.reject(),null}function ce(n,r,o,c=null){if(!r)return se(c);const l=n.spatialReference||a.WGS84;if(e(r.camera)){const t=r.get("camera.position.spatialReference");if(!i(t,l))return se(c);const n=r.camera.clone();return t.equals(l)||(n.position=s(n.position,l)),function(t,n){return e(t)&&t.resolver&&t.resolver.resolve(n),n}(c,n)}if(t(r.targetGeometry))return se(c);const m=r.get("targetGeometry.spatialReference");if(m&&!i(m,l))return se(c);const f=X(n,n.state.camera);let u=1;if(null!=r.rotation&&(f.heading=oe(r.rotation),u=0),null!=o&&(f.tilt=o),"point"===r.targetGeometry.type){const e=r.targetGeometry;let t;const a=r.targetGeometry.clone();return t=null!=r.scale?_(n,r.scale,e.latitude):n.state.camera.distance,H(n,a,t,f,u,c)}const p=r.targetGeometry.extent;return J(n,p,f.heading,f.tilt,u,c)}function le(e,n,r=null){return t(r)&&(r=new j),pe(e,null,n.clone(),r)}async function me(t,r,a){const o=function(e,t){if(!t||!e.spatialReference)return null;const n={target:null};if("declaredClass"in t||Array.isArray(t))n.target=t;else{for(const e in t)n[e]=t[e];t.center&&!n.target&&(n.target=t.center)}return n}(t,r);if(!o)throw new n("viewpointutils-create:no-target","Missing target for creating viewpoint");const i=new b({fov:t.camera.fov}),s=new j({camera:i});if(o.target instanceof j){return xe(await async function(t,n,r,a,o){if(e(n.camera))return ye(t,n.camera,o);o.scale=n.scale,o.rotation=n.rotation,o.targetGeometry=e(n.targetGeometry)?n.targetGeometry.clone():null,o.camera=null,null!=r.heading?o.rotation=ie(r.heading):null!=r.rotation&&(o.rotation=r.rotation);const i=fe(t,r);null!=i&&(o.scale=i);const s=new te(a);return ce(t,o,r.tilt,s),o.camera=await s.resolver.promise,o}(t,o.target,o,a,s))}if(o.target instanceof b)return xe(ye(t,o.target,s));const m=null!=o.scale||null!=o.zoom;if(o.target instanceof l){const e=o.target.xmin===o.target.xmax||o.target.ymin===o.target.ymax;return xe(m||e?await de(t,o,o.target.center,i,a,s):await async function(e,t,n,r,a,o){o.targetGeometry=n.clone();const i=$(e);X(e,i,r);const s=ue(r,t)?0:1,c=new te(a);return J(e,n,r.heading,r.tilt,s,c),o.camera=await c.resolver.promise,o}(t,o,o.target,i,a,s))}const f={boundingBox:E(),hasZ:!1,screenSpaceObjects:[]},u=m?function(e,t){return K(e,fe(e,t))}(t,o):void 0;if(await he(t,o.target,u,f),isFinite(f.boundingBox[0])){let e;if(P(f.boundingBox,we),Be.x=we[0],Be.y=we[1],Be.z=we[2],Be.spatialReference=t.spatialReference,isFinite(Be.z)&&f.hasZ?e=I(f.boundingBox):(Be.z=void 0,e=R(T(f.boundingBox,Re))),m||e)return xe(await de(t,o,Be,i,a,s));const n=function(e,t){const n=.66;if(!t.length)return n;let r=Number.NEGATIVE_INFINITY;for(let e=0;e<t.length;e++){const n=t[e].screenSpaceBoundingRect;r=Math.max(r,Math.abs(n[0]),Math.abs(n[1]),Math.abs(n[2]),Math.abs(n[3]))}const a=Math.min(e.width,e.height);return n-r/a*2}(t,f.screenSpaceObjects);return xe(await async function(e,t,n,r,a,o,i,s){s.targetGeometry=n.clone();const c=$(e),l=function(e,t,n,r,a){let o=0;n.hasZ?o=n.z:e.basemapTerrain&&(o=D(e.elevationProvider,n));x(we,n.x,n.y,o),B(e.spatialReference,we,ve,e.renderSpatialReference),A(be,ve),U(be,be),E(je);const i=[[0,1,2],[3,1,2],[0,4,2],[3,4,2],[0,1,5],[3,1,5],[0,4,5],[3,4,5]];for(let t=0;t<i.length;t++){const n=i[t];let a=r[n[2]];isFinite(a)||(a=o),x(we,r[n[0]],r[n[1]],a),M(we,e.spatialReference,we,e.renderSpatialReference),O(je,w(we,we,be))}const s=q(je),c=W(je),l=C(je),m=1/Math.tan(t.fovX/2),f=1/Math.tan(t.fovY/2),u=.5*Math.sqrt(s*s+l*l)*Math.max(f,m)+.5*c,p=.5*c*f+.5*Math.max(s,l);return Math.max(u,p)/a}(e,c,n,r,a);X(e,c,o);const m=ue(o,t)?0:1;s.scale=ne(e,l,s.targetGeometry.latitude);const f=new te(i);return re(e,s.targetGeometry,s.scale,o,m,f),s.camera=await f.resolver.promise,s}(t,o,Be,f.boundingBox,n,i,a,s))}return o.position?xe(function(e,t,n,r){const a=$(e);return y(Ge,a.viewForward),ae(e,a.eye,Ge,a.up,ke),n.position=new c(t.position),n.heading=null!=t.heading?t.heading:ke.heading,n.tilt=null!=t.tilt?t.tilt:ke.tilt,pe(e,null,n,r)}(t,o,i,s)):xe(await async function(e,t,n,r,a){const o=$(e),i=z(o.center,e.renderSpatialReference,e.spatialReference,Be);return de(e,t,i,n,r,a)}(t,o,i,a,s))}function fe(e,t){return null==t.scale&&null!=t.zoom?L(e,t.zoom):t.scale}function ue(e,t){let n=!1;return null!=t.heading?(e.heading=t.heading,n=!0):null!=t.rotation&&(e.heading=oe(t.rotation),n=!0),null!=t.tilt&&(e.tilt=t.tilt,n=!0),null!=t.fov&&(e.fov=t.fov),n}function pe(t,n,r,o){const i=t.spatialReference||a.WGS84;return n=e(n)?n:Q(t,r),o.targetGeometry=z(n.center,t.renderSpatialReference,i),o.scale=ee(t,n),o.rotation=ie(r.heading),o.camera=r,o}function ge(e,t,r){if(!t)return;if(!i(t.spatialReference,e.spatialReference))throw new n("viewpointutils:incompatible-spatialreference",`Spatial reference (${t.spatialReference?t.spatialReference.wkid:"unknown"}) is incompatible with the view (${e.spatialReference.wkid})`,{geometry:t});const a=[];if(!t.hasZ&&e.basemapTerrain){let n;switch(t.type){case"point":n=t;break;case"multipoint":case"polyline":case"mesh":n=t.extent.center;break;case"extent":n=t.center;break;case"polygon":n=t.centroid}n&&i(n,e.basemapTerrain.spatialReference)?we[2]=D(e.elevationProvider,n)||0:we[2]=0}(0,Me[t.type])(t,(e=>{a.push(e[0],e[1],e[2])}),we);const o=a.length/3;if(0===o)return;const s=new Array(a.length);if(k(a,t.spatialReference,0,s,e.spatialReference,0,o)){t.hasZ&&(r.hasZ=!0);for(let e=0;e<s.length;e+=3)t.hasZ?(we[0]=s[e+0],we[1]=s[e+1],we[2]=s[e+2]):(we[0]=s[e+0],we[1]=s[e+1]),O(r.boundingBox,we)}}async function he(e,n,i,s){if(Array.isArray(n)&&2===n.length){const t=n[0],r=n[1];if("number"==typeof t&&"number"==typeof r)return Be.x=t,Be.y=r,Be.z=void 0,Be.spatialReference=e.spatialReference.isGeographic?e.spatialReference:a.WGS84,void ge(e,Be,s)}n&&"function"==typeof n.map?await r(n.map((t=>he(e,t,i,s)))):n instanceof o?ge(e,n,s):n instanceof m&&await async function(e,n,r,a){const o=await f(e.whenViewForGraphic(n));if(!1===o.ok||t(o.value)||!("whenGraphicBounds"in o.value))return void ge(e,n.geometry,a);const i=o.value,s=await f(i.whenGraphicBounds(n,{minDemResolution:r}));if(!1===s.ok)return void ge(e,n.geometry,a);const{screenSpaceObjects:c,boundingBox:l}=s.value;V(a.boundingBox,l),c&&c.forEach((e=>{a.screenSpaceObjects.push(e)})),isFinite(l[2])&&(a.hasZ=!0)}(e,n,i,s)}function ye(e,t,n){const r=e.spatialReference,a=t.position.spatialReference;return i(a,r)?((t=t.clone()).fov=e.camera.fov,a.equals(r)||(t.position=s(t.position,r)),pe(e,null,t,n)):null}async function de(e,r,a,o,i,s){if(t(a))throw new n("createfromcenter","invalid point");s.targetGeometry=a.clone();const l=$(e);if(r.position)return function(e,t,n,r,a,o){const i=e.renderSpatialReference;return S(n.position,ze,i),S(t,Se,i),o.targetGeometry=new c(t),a.position=new c(n.position),d(Ge,Se,ze),ae(e,ze,Ge,r.up,a),o.scale=ne(e,h(ze,Se),o.targetGeometry.latitude),o.rotation=ie(a.heading),o.camera=a,o}(e,s.targetGeometry,r,l,o,s);if(r.zoomFactor){const t=l.distance/r.zoomFactor,n=p(we,l.viewForward,-t);g(l.eye,l.center,n),l.markViewDirty(),s.scale=ne(e,t,a.latitude)}X(e,l,o);const m=ue(o,r)?0:1;if(!r.zoomFactor){s.scale=fe(e,r),null==s.scale&&(S(a,we,e.renderSpatialReference),Y.intersectsPoint(l.frustum.planes,we)?s.scale=ne(e,h(l.eye,we),a.latitude):s.scale=ee(e,l));const t=new te(i);re(e,s.targetGeometry,s.scale,o,m,t),s.camera=await t.resolver.promise}return s}function xe(t){return t&&e(t.camera)&&(t.rotation=ie(t.camera.heading)),t}const we=u(),ve=F(),be=Z(),je=N(),Re=G(),Ge=u(),ze=u(),Se=u(),ke={heading:0,tilt:0},Be=new c,Me={point(e,t,n){n[0]=e.x,n[1]=e.y,e.hasZ&&(n[2]=e.z),t(n)},polygon(e,t,n){const r=e.hasZ;for(let a=0;a<e.rings.length;a++){const o=e.rings[a];for(let e=0;e<o.length;e++)n[0]=o[e][0],n[1]=o[e][1],r&&(n[2]=o[e][2]),t(n)}},polyline(e,t,n){const r=e.hasZ;for(let a=0;a<e.paths.length;a++){const o=e.paths[a];for(let e=0;e<o.length;e++)n[0]=o[e][0],n[1]=o[e][1],r&&(n[2]=o[e][2]),t(n)}},multipoint(e,t,n){const r=e.points,a=e.hasZ;for(let e=0;e<r.length;e++)n[0]=r[e][0],n[1]=r[e][1],a&&(n[2]=r[e][2]),t(n)},extent(e,t,n){e.hasZ?(t(x(n,e.xmin,e.ymin,e.zmin)),t(x(n,e.xmax,e.ymin,e.zmin)),t(x(n,e.xmin,e.ymax,e.zmin)),t(x(n,e.xmax,e.ymax,e.zmin)),t(x(n,e.xmin,e.ymin,e.zmax)),t(x(n,e.xmax,e.ymin,e.zmax)),t(x(n,e.xmin,e.ymax,e.zmax)),t(x(n,e.xmax,e.ymax,e.zmax))):(t(x(n,e.xmin,e.ymin,n[2])),t(x(n,e.xmax,e.ymin,n[2])),t(x(n,e.xmin,e.ymax,n[2])),t(x(n,e.xmax,e.ymax,n[2])))},mesh(e,t,n){const r=e.vertexAttributes&&e.vertexAttributes.position;if(r)for(let e=0;e<r.length;e+=3)t(x(n,r[e+0],r[e+1],r[e+2]))}};export{me as create,le as fromCamera,ie as headingToRotation,oe as rotationToHeading,ce as toCamera};
