/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{neverReached as e}from"../../../../core/compilerUtils.js";import{clamp as t,acosClamped as r,asinClamped as n,deg2rad as i}from"../../../../core/mathUtils.js";import{c as s}from"../../../../chunks/vec3f64.js";import{f as a,i as o,a as c,b as u,k as l,d,n as m,l as f,o as p}from"../../../../chunks/vec3.js";import{getReferenceEllipsoid as y}from"../../../../geometry/projectionEllipsoid.js";import{i as h,r as C}from"../../../../chunks/mat4.js";import{a as M}from"../../../../chunks/mat4f64.js";import{sphere as w}from"../../support/geometryUtils.js";import{defaultApplyOptions as I,hasConstraintType as S,adjustRangeForInteraction as D}from"./common.js";import{viewAngle as A}from"../../state/utils/viewUtils.js";function x(t,r,n=I,i=!0){F.eyeCenterDistance=0,F.requiresTwoSteps=!1;const s=P(t,r,n,void 0,F);if(0===s)return!1;switch(h(k),C(k,k,-s,r.viewRight),n.tiltMode){case 1:o(O,r.viewForward,k),c(O,O,F.eyeCenterDistance),u(r.center,r.eye,O);break;case 0:a(O,r.center,r.eye),o(O,O,k),a(r.eye,r.center,O);break;default:e(n.tiltMode)}return o(r.up,r.up,k),r.markViewDirty(),!F.requiresTwoSteps||!i||x(t,r,n,!1)}function P(r,i,s=I,a=I,o){if(!r.state.constraints.tilt)return 0;const c=i.distance,u=r.state.constraints.tilt(c,H);return function(e,t,r){if(0===t.interactionType)return;const{interactionStartCamera:n,interactionFactor:i}=t,{min:s,max:a}=r,o=P(e,n,I,t),c=0===o?0:A(e.renderCoordsHelper,n.center,n.eye);r.min=s,r.max=a,2===t.interactionType?(S(t.selection,2)&&v(e,n,r),D(o,c,!0,i,g,r)):D(o,c,!1,i,g,r)}(r,s,u),2===a.interactionType&&S(a.selection,2)&&v(r,a.interactionStartCamera,u),1===s.tiltMode||1===a.tiltMode?function(r,i,s,a){a&&(a.requiresTwoSteps=!1);switch(r.viewingMode){case"global":return function(e,r,i,s){const a=R(e,r,b),o=t(a.tiltAtCenter,i.min,i.max);if(!T(a.tiltAtCenter-o))return 0;let c,u;a.centerIsOnSurface?(c=function(e){const{constraints:t,eyeCenterDistance:r,tiltAtCenter:n}=e;let i=n,s=t.clampTilt(r,n);const a=j(e,s);if(t.clampTilt(a,n)===s)return s;let o=0;for(;o<10&&T(s-i);){const r=(i+s)/2,n=j(e,r);T(t.clampTilt(n,r)-r)?i=r:s=r,o++}return s}(a),u=function(e,t){const r=n(e.radius/e.eyeRadius*Math.sin(e.tiltAtCenter)),i=n(e.radius/e.eyeRadius*Math.sin(t));if(e.eyeRadius>e.radius)return r-i;return i-r}(a,c)):(c=a.constraints.clampTilt(a.eyeCenterDistance,a.tiltAtCenter),s&&c<Math.PI/2&&(s.requiresTwoSteps=!0,c=Math.PI/2-1e-5),u=function(e,t){const r=e.tiltAtCenter-Math.PI/2,n=t-Math.PI/2;return r-n}(a,c));s&&(s.eyeCenterDistance=j(a,c));return u}(r,i,s,a);case"local":return function(e,r,n,i){const s=A(e.renderCoordsHelper,r.center,r.eye),a=t(s,n.min,n.max),o=s-a;if(!T(o))return 0;if(i){const t=e.pointsOfInterest.centerOnSurfaceFrequent.estimatedSurfaceAltitude,n=e.renderCoordsHelper.getAltitude(r.eye)-t,s=Math.cos(a);Math.abs(s)>1e-4?i.eyeCenterDistance=n/s:i.eyeCenterDistance=r.distance}return o}(r,i,s,a);default:return void e(r.viewingMode)}}(r,i,u,o):function(e,r,n){const i=A(e.renderCoordsHelper,r.center,r.eye),s=t(i,n.min,n.max),a=i-s;if(!T(a))return 0;return a}(r,i,u)}function R(e,t,n){const i=e.pointsOfInterest.centerOnSurfaceFrequent.estimatedSurfaceAltitude,s=i+y(e.spatialReference).radius,a=e.renderCoordsHelper.intersectManifold(t.ray,i,q);return n.eyeCenterDistance=t.distance,a?(n.eyeCenterDistance=l(t.eye,q),n.tiltAtCenter=A(e.renderCoordsHelper,q,t.eye)):e.state.isLocal?n.tiltAtCenter=A(e.renderCoordsHelper,t.center,t.eye):(w.closestPointOnSilhouette(w.wrap(s),t.ray,q),n.eyeCenterDistance=l(t.eye,q),n.tiltAtCenter=r(-d(t.viewForward,m(q,q)))),n.radius=s,n.eyeRadius=f(t.eye),n.constraints=e.state.constraints,n.centerIsOnSurface=a,n}function T(e){return Math.abs(e)>1e-9}function j(e,r){if(!e.centerIsOnSurface)return e.eyeCenterDistance;const i=Math.PI-t(r,0,Math.PI),s=n(e.radius/e.eyeRadius*Math.sin(i)),a=Math.PI-i-s,o=Math.sin(a)/Math.sin(i);if(e.eyeRadius<e.radius&&o>1){const t=Math.PI-s,r=Math.PI-i-t;return Math.sin(r)/Math.sin(i)*e.eyeRadius}return o*e.eyeRadius}function v(e,t,n){if(e.state.isLocal)return;const i=e.state.constraints;if(!i.altitude)return;const s=p(t.center),a=Math.sqrt(s),o=t.distance,c=y(e.spatialReference).radius,u=i.altitude.min+c,l=i.altitude.max+c,d=(u*u-o*o-s)/(-2*a*o),m=(l*l-o*o-s)/(-2*a*o);n.min=Math.max(n.min,Math.min(Math.PI-r(m),n.max)),n.max=Math.min(n.max,Math.PI-r(d))}const O=s(),k=M(),q=s(),g=i(5),H={min:0,max:0},b={constraints:null,radius:0,eyeRadius:0,centerIsOnSurface:!0,eyeCenterDistance:0,tiltAtCenter:0},F={eyeCenterDistance:0,requiresTwoSteps:!1};export{x as applyTiltConstraint,P as getTiltConstraintError};
