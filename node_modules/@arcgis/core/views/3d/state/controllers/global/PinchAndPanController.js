/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../../chunks/tslib.es6.js";import"../../../../../core/has.js";import"../../../../../core/Logger.js";import"../../../../../core/accessorSupport/ensureType.js";import{property as i}from"../../../../../core/accessorSupport/decorators/property.js";import{subclass as e}from"../../../../../core/accessorSupport/decorators/subclass.js";import"../../../../../core/urlUtils.js";import"../../../../../core/uuid.js";import"../../../../../portal/support/resourceExtension.js";import{deg2rad as n}from"../../../../../core/mathUtils.js";import{createScreenPointArray as s,screenPointObjectToArray as o,createRenderScreenPointArray3 as r}from"../../../../../core/screenUtils.js";import{c as a}from"../../../../../chunks/vec3f64.js";import{g as m,p as h,l as c,f as p,n as u,b as l,a as g,d}from"../../../../../chunks/vec3.js";import{cyclicalPI as P}from"../../../support/mathUtils.js";import{getReferenceEllipsoid as v}from"../../../../../geometry/projectionEllipsoid.js";import{disableContextNavigation as C}from"../../../../../support/featureFlags.js";import{c as M}from"../../../../../chunks/vec2.js";import{plane as S,sphere as b,axisAngle as w}from"../../../support/geometryUtils.js";import{pixelDistanceToInteractionFactor as f,applyAll as j}from"../../../camera/constraintUtils.js";import A from"../../../webgl-engine/lib/Camera.js";import{NavigationMode as E,pickPointAndInitSphere as k,decideNavigationMode as y,sphereOrPlanePointFromScreenPoint as O,intersectPlaneFromScreenPoint as x,applyZoomOnSphere as z,preserveHeadingThreshold as R,applyPanSphericalPreserveHeading as H,applyPanSphericalDirectRotation as F,normalizeRotationDelta as D,applyRotation as T,applyPanPlanar as U,applyZoomToPoint as I}from"../../utils/navigationUtils.js";import{InteractiveController as _}from"../InteractiveController.js";import{ExponentialFalloff as G}from"../../../input/util.js";import{PanPlanarMomentumController as N}from"../momentum/PanPlanarMomentumController.js";import{PanSphericalMomentumController as V}from"../momentum/PanSphericalMomentumController.js";import{RotationMomentumController as Z}from"../momentum/RotationMomentumController.js";import{ZoomPlanarMomentumController as L}from"../momentum/ZoomPlanarMomentumController.js";import{ZoomSphericalMomentumController as q}from"../momentum/ZoomSphericalMomentumController.js";import{PanPlanarMomentumEstimator as B}from"../../../../navigation/PanPlanarMomentumEstimator.js";import{PanSphericalMomentumEstimator as J}from"../../../../navigation/PanSphericalMomentumEstimator.js";import{RotationMomentumEstimator as K}from"../../../../navigation/RotationMomentumEstimator.js";import{ZoomMomentumEstimator as Q}from"../../../../navigation/ZoomMomentumEstimator.js";let W=class extends _{constructor(t){super(t),this.view=null,this.smoothRotation=new G(.05),this.rotationAxis=a(),this.panningPlane=S.create(),this.smoothScaling=new G(.05),this.zoomCenterScreen=s(),this.zoomMomentumEstimator=new Q,this.rotationMomentumEstimator=new K,this.panSphericalMomentumEstimator=new J,this.panPlanarMomentumEstimator=new B,this.adjustedSphere=b.create(),this.tmp3d=a(),this.tmpScreenPointArray=s(),this.beginScreenPoint=s(),this.beginScenePoint=a(),this.screenPickPoint=s(),this.navMode=E.Horizontal,this.tmpInteractionDirection=a(),this.constraintOptions={selection:15,interactionType:0,interactionFactor:0,interactionStartCamera:new A,interactionDirection:null,tiltMode:0}}get intersectionHelper(){return this.view.sceneIntersectionHelper}begin(t){if(!this.active)return;const i=this.view.navigation.momentumEnabled;this.zoomMomentumEstimator.enabled=i,this.rotationMomentumEstimator.enabled=i,this.panPlanarMomentumEstimator.enabled=i,this.panSphericalMomentumEstimator.enabled=i,this.beginHeading=-P.normalize(n(this.view.camera.heading)),this.beginRadius=t.radius,this.pointerCount=t.pointers.size,this.beginAngle=t.angle,this.smoothRotation.reset(),o(t.center,this.screenPickPoint),M(this.beginScreenPoint,this.screenPickPoint);const e=v(this.view.spatialReference),s=k(this.intersectionHelper,this.beginCamera,this.screenPickPoint,!0,e);this.scenePickPoint=s.scenePickPoint,this.sphere=s.sphere,m(this.beginScenePoint,this.scenePickPoint),this.navMode=y(this.beginCamera,this.screenPickPoint,s.hasGeometryIntersection,e),this.navMode===E.Vertical&&this.preparePlanarPanMode(t),this.constraintOptions.interactionStartCamera.copyFrom(this.beginCamera)}preparePlanarPanMode(t){const i=h(this.tmp3d,this.beginCamera.viewForward);S.fromPositionAndNormal(this.scenePickPoint,i,this.panningPlane);const e=s(this.screenPickPoint[0],0),n=a(),P=c(this.beginCamera.eye);this.adjustedSphere.radius=P<this.sphere.radius?P-100:this.sphere.radius,O(this.adjustedSphere,this.beginCamera,e,n);const v=r();this.beginCamera.projectToRenderScreen(n,v);const M=.9*v[1];if(this.screenPickPoint[1]=Math.min(this.screenPickPoint[1],M),this.intersectionHelper.intersectScreen(this.screenPickPoint,this.scenePickPoint)&&S.fromPositionAndNormal(this.scenePickPoint,S.normal(this.panningPlane),this.panningPlane),!C()&&this.view._stage.getCamera()._contextNavigation){const t=a(),i=a(),e=a(),n=80,s=5,o=50;p(t,this.scenePickPoint,this.currentCamera.eye),u(t,t);const r=s*Math.max(Math.abs(this.view.camera.position.z),o),h=this.view._stage.renderView.getMinimalDepthForArea(this.screenPickPoint[0],this.screenPickPoint[1],this.view._stage.getCamera(),n),c=h?Math.min(h,r):r;m(e,l(i,this.currentCamera.eye,g(i,t,c))),this.panningPlane[3]=-d(this.panningPlane,e)}const b=o(t.center,this.tmpScreenPointArray);x(this.panningPlane,this.beginCamera,b,this.beginScenePoint)}update(t){if(!this.active)return;this.currentCamera.copyFrom(this.beginCamera);const i=t.pointers.size>1;this.navMode===E.Horizontal?(i&&this.zoomSpherical(t),this.panningSpherical(t),i&&this.rotateSpherical(t)):(i&&this.zoomPlanar(t),this.panningPlanar(t),i&&this.rotatePlanar(t)),this.currentCamera.markViewDirty()}end(t){t.pointers.size===this.pointerCount&&this.update(t),this.finishController();const i=this.zoomMomentumEstimator.evaluateMomentum();if(i)return this.navMode===E.Horizontal?new q({view:this.view,momentum:i,screenCenter:this.zoomCenterScreen,sceneCenter:this.beginScenePoint,radius:this.sphere.radius}):new L({view:this.view,momentum:i,zoomCenter:this.beginScenePoint});const e=this.rotationMomentumEstimator.evaluateMomentum();if(e)return new Z({view:this.view,momentum:e,center:this.sphere.center,axis:this.rotationAxis});if(this.navMode===E.Horizontal){const t=this.panSphericalMomentumEstimator.evaluateMomentum();if(t)return new V({view:this.view,momentum:t})}else{const t=this.panPlanarMomentumEstimator.evaluateMomentum();if(t)return new N({view:this.view,momentum:t})}return null}zoomSpherical(t){const i=this.beginRadius/t.radius,e=.001875*Math.min(Math.max(t.radius,40),120);this.smoothScaling.gain=e,this.smoothScaling.update(i),z(this.sphere,this.currentCamera,this.smoothScaling.value),o(t.center,this.zoomCenterScreen),this.zoomMomentumEstimator.add(this.smoothScaling.value,.001*t.timestamp),this.constraintOptions.interactionType=1,this.constraintOptions.interactionFactor=f(t.radius-this.beginRadius),j(this.view,this.currentCamera,this.constraintOptions)}panningSpherical(t){const i=o(t.center,this.tmpScreenPointArray);O(this.sphere,this.currentCamera,i,this.tmp3d),R(this.beginScenePoint,d(this.currentCamera.up,this.beginScenePoint),this.sphere.radius,this.beginHeading,this.view.camera.tilt,this.beginCamera)?(H(this.sphere,this.currentCamera,this.beginScenePoint,this.tmp3d,this.beginHeading,this.view.camera.tilt,!1),this.panSphericalMomentumEstimator.addMomentumPreserveHeading(i,this.tmp3d,.001*t.timestamp,this.beginCamera,this.sphere,this.beginHeading,this.view.camera.tilt)):(F(this.sphere,this.currentCamera,this.beginScenePoint,this.tmp3d,this.view.camera.tilt,!1),this.panSphericalMomentumEstimator.addMomentumDirectRotation(i,this.tmp3d,.001*t.timestamp,this.beginCamera,this.sphere.radius,this.view.camera.tilt)),this.constraintOptions.interactionType=4,this.constraintOptions.interactionFactor=f(this.screenPickPoint,i),j(this.view,this.currentCamera,this.constraintOptions)}rotateSpherical(t){u(this.rotationAxis,this.scenePickPoint),this.currentCamera.aboveGround||h(this.rotationAxis,this.rotationAxis);const i=this.smoothRotation.value,e=i+D(t.angle-i),n=.00125*Math.min(Math.max(t.radius,40),120);this.smoothRotation.gain=n,this.smoothRotation.update(e);const s=this.smoothRotation.value-this.beginAngle;this.rotationMomentumEstimator.add(s,.001*t.timestamp),T(this.currentCamera,this.sphere.center,w.wrapAxisAngle(this.rotationAxis,s)),this.constraintOptions.interactionType=2,this.constraintOptions.interactionFactor=f(t.radius*e),j(this.view,this.currentCamera,this.constraintOptions)}panningPlanar(t){const i=o(t.center,this.tmpScreenPointArray);x(this.panningPlane,this.currentCamera,i,this.tmp3d)&&(U(this.currentCamera,this.beginScenePoint,this.tmp3d),this.panPlanarMomentumEstimator.add(i,this.tmp3d,.001*t.timestamp),this.constraintOptions.interactionType=4,this.constraintOptions.interactionFactor=f(this.beginScreenPoint,i),this.constraintOptions.interactionDirection=this.view.renderCoordsHelper.worldUpAtPosition(this.currentCamera.eye,this.tmpInteractionDirection),j(this.view,this.currentCamera,this.constraintOptions),this.constraintOptions.interactionDirection=null)}zoomPlanar(t){const i=this.beginRadius/t.radius,e=.001875*Math.min(Math.max(t.radius,40),120);this.smoothScaling.gain=e,this.smoothScaling.update(i),this.zoomMomentumEstimator.add(this.smoothScaling.value,.001*t.timestamp),I(this.currentCamera,this.beginScenePoint,this.smoothScaling.value,this.view.state.constraints.minimumPoiDistance),this.constraintOptions.interactionType=1,this.constraintOptions.interactionFactor=f(t.radius-this.beginRadius),j(this.view,this.currentCamera,this.constraintOptions)}rotatePlanar(t){m(this.rotationAxis,this.beginScenePoint),this.currentCamera.aboveGround||h(this.rotationAxis,this.rotationAxis);const i=this.smoothRotation.value;let e=t.angle-i;e=D(e);const n=i+e,s=.00125*Math.min(Math.max(t.radius,40),120);this.smoothRotation.gain=s,this.smoothRotation.update(n);const o=this.smoothRotation.value-this.beginAngle;this.rotationMomentumEstimator.add(o,.001*t.timestamp),T(this.currentCamera,this.sphere.center,w.wrapAxisAngle(this.rotationAxis,o)),this.constraintOptions.interactionType=2,this.constraintOptions.interactionFactor=f(t.radius*o),j(this.view,this.currentCamera,this.constraintOptions)}};t([i({constructOnly:!0})],W.prototype,"view",void 0),W=t([e("esri.views.3d.state.controllers.global.PinchAndPanController")],W);export{W as PinchAndPanController};
