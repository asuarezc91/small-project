/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../../chunks/tslib.es6.js";import i from"../../../../../core/has.js";import"../../../../../core/Logger.js";import"../../../../../core/accessorSupport/ensureType.js";import{property as e}from"../../../../../core/accessorSupport/decorators/property.js";import{subclass as r}from"../../../../../core/accessorSupport/decorators/subclass.js";import"../../../../../core/urlUtils.js";import"../../../../../core/uuid.js";import"../../../../../portal/support/resourceExtension.js";import{createScreenPointArray as s}from"../../../../../core/screenUtils.js";import{c as n}from"../../../../../chunks/vec3f64.js";import{n as a,a as o,b as c,f as h,l as m}from"../../../../../chunks/vec3.js";import{getReferenceEllipsoid as p}from"../../../../../geometry/projectionEllipsoid.js";import{a as l}from"../../../../../chunks/vec2f64.js";import{c as u}from"../../../../../chunks/vec2.js";import{axisAngle as g,sphere as C,ray as y}from"../../../support/geometryUtils.js";import{applySurfaceCollisionConstraint as P}from"../../../camera/constraintUtils/surfaceCollision.js";import{pixelDistanceToInteractionFactor as d,applyAll as f}from"../../../camera/constraintUtils.js";import{normalizeCoordinate as v,pickPointAndInitSphere as j,decideNavigationMode as R,NavigationMode as b,sphereOrPlanePointFromScreenPoint as k,applyRotation as w}from"../../utils/navigationUtils.js";import{InteractiveController as D}from"../InteractiveController.js";let A=class extends D{constructor(t){super(t),this.view=null,this.pickPoint=n(),this.tmpP0=l(),this.panAxisAngle=g.create(),this.tmpRayDir=n(),this.targetOnSphere=n(),this.tmpRay={origin:n(),direction:n()},this.dragBeginPoint=s(),this.normalizedAnchorPoint=l(),this.constraintOptions={selection:7,interactionType:1,interactionFactor:0,interactionStartCamera:null,interactionDirection:null,tiltMode:0},this.sphere=C.create(),this.hasPickPoint=!1}get intersectionHelper(){return this.view.sceneIntersectionHelper}begin(t){if(!this.active)return;u(this.dragBeginPoint,t),v(this.beginCamera,t,this.normalizedAnchorPoint);const e=p(this.view.spatialReference),r=j(this.intersectionHelper,this.beginCamera,t,!1,e);if(this.navMode=R(this.beginCamera,t,r.hasGeometryIntersection,e),this.navMode===b.Horizontal||i("disable-feature:context-navigation"))this.hasPickPoint=!!r.scenePickPoint,this.pickPoint=r.scenePickPoint,this.sphere=r.sphere;else{let i;y.fromScreenAtEye(this.beginCamera,t,this.tmpRay),a(this.tmpRay.direction,this.tmpRay.direction),this.view.camera.position.hasZ&&(i=Math.abs(this.view.camera.position.z));let e=30*i;const r=this.view._stage.renderView.getMinimalDepthForArea(t[0],t[1],this.view._stage.getCamera(),70);e=e>r?r:e,this.hasPickPoint=!0,o(this.tmpRay.direction,this.tmpRay.direction,e),c(this.pickPoint,this.tmpRay.origin,this.tmpRay.direction)}this.constraintOptions.interactionStartCamera=this.beginCamera}update(t){if(this.active){if(this.currentCamera.eye=this.beginCamera.eye,this.currentCamera.center=this.beginCamera.center,this.currentCamera.up=this.beginCamera.up,this.navMode===b.Horizontal||i("disable-feature:context-navigation")){h(this.tmpRayDir,this.currentCamera.center,this.currentCamera.eye);const i=m(this.tmpRayDir);v(this.currentCamera,t,this.tmpP0);const e=12*(this.normalizedAnchorPoint[1]-this.tmpP0[1]);let r=i*Math.pow(2,e);const s=this.view.state.constraints.minimumPoiDistance;if(e<0&&r<s&&(r=s),Math.abs(i-r)<1e-6)return;if(this.hasPickPoint&&r<i){const t=1-(1-r/i)*(1-this.sphere.radius/m(this.currentCamera.center));o(this.currentCamera.center,this.currentCamera.center,t)}o(this.tmpRayDir,this.tmpRayDir,-r/i),c(this.currentCamera.eye,this.currentCamera.center,this.tmpRayDir),this.constraintOptions.interactionFactor=d(this.dragBeginPoint,t),f(this.view,this.currentCamera,this.constraintOptions),this.hasPickPoint&&(k(this.sphere,this.currentCamera,this.dragBeginPoint,this.targetOnSphere),g.fromPoints(this.pickPoint,this.targetOnSphere,this.panAxisAngle),w(this.currentCamera,this.sphere.center,this.panAxisAngle))}else{const i=m(this.tmpRay.direction);v(this.currentCamera,t,this.tmpP0);const e=12*(this.normalizedAnchorPoint[1]-this.tmpP0[1]);let r=i*Math.pow(2,e);const s=this.view.state.constraints.minimumPoiDistance;if(e<0&&r<s&&(r=s),Math.abs(i-r)<1e-6)return;o(this.tmpRayDir,this.tmpRay.direction,1-r/i),c(this.currentCamera.eye,this.currentCamera.eye,this.tmpRayDir),c(this.currentCamera.center,this.currentCamera.center,this.tmpRayDir)}P(this.view,this.currentCamera)}}end(){this.active&&this.finishController()}};t([e({constructOnly:!0})],A.prototype,"view",void 0),A=t([r("esri.views.3d.state.controllers.global.ZoomController")],A);export{A as ZoomController};
