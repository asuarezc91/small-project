/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../../chunks/tslib.es6.js";import"../../../../../core/has.js";import"../../../../../core/Logger.js";import"../../../../../core/accessorSupport/ensureType.js";import{property as i}from"../../../../../core/accessorSupport/decorators/property.js";import{subclass as e}from"../../../../../core/accessorSupport/decorators/subclass.js";import"../../../../../core/urlUtils.js";import"../../../../../core/uuid.js";import"../../../../../portal/support/resourceExtension.js";import{asinClamped as n}from"../../../../../core/mathUtils.js";import{createScreenPointArray as o,screenPointObjectToArray as s}from"../../../../../core/screenUtils.js";import{c as r,f as a}from"../../../../../chunks/vec3f64.js";import{p as m,g as h,d as c,a as l,f as p,n as u,b as d}from"../../../../../chunks/vec3.js";import{disableContextNavigation as g}from"../../../../../support/featureFlags.js";import{plane as C,axisAngle as f}from"../../../support/geometryUtils.js";import{pixelDistanceToInteractionFactor as v,applyAll as b}from"../../../camera/constraintUtils.js";import M from"../../../webgl-engine/lib/Camera.js";import{NavigationMode as w,centroid as P,applyZoomToPoint as j,applyPanPlanar as V,normalizeRotationDelta as S,applyRotation as z,intersectPlaneFromScreenPoint as E}from"../../utils/navigationUtils.js";import{InteractiveController as y}from"../InteractiveController.js";import{ExponentialFalloff as H}from"../../../input/util.js";import{PanPlanarMomentumController as O}from"../momentum/PanPlanarMomentumController.js";import{RotationMomentumController as F}from"../momentum/RotationMomentumController.js";import{ZoomPlanarMomentumController as x}from"../momentum/ZoomPlanarMomentumController.js";import{PanPlanarMomentumEstimator as A}from"../../../../navigation/PanPlanarMomentumEstimator.js";import{RotationMomentumEstimator as U}from"../../../../navigation/RotationMomentumEstimator.js";import{ZoomMomentumEstimator as k}from"../../../../navigation/ZoomMomentumEstimator.js";const R=a(0,0,1),T=16/180*Math.PI;let _=class extends y{constructor(t){super(t),this.view=null,this.rotationValueSmooth=new H(.05),this.scalingValueSmooth=new H(.05),this.planeHorizontal=C.create(),this.planeVertical=C.create(),this.rotationMomentumEstimator=new U,this.panMomentumEstimator=new A(300,12,.9),this.zoomMomentumEstimator=new k,this.beginCenter=r(),this.tmpPoints=[],this.beginCenterScreen=o(),this.tmpCentroid3d=r(),this.tmpCentroid2d=o(),this.tmp2d=o(),this.constraintOptions={selection:15,interactionType:0,interactionFactor:0,interactionStartCamera:new M,interactionDirection:null,tiltMode:0}}get intersectionHelper(){return this.view.sceneIntersectionHelper}begin(t){if(!this.active)return;const i=this.view.navigation.momentumEnabled;this.zoomMomentumEstimator.enabled=i,this.rotationMomentumEstimator.enabled=i,this.panMomentumEstimator.enabled=i,this.beginRadius=t.radius,this.pointerCount=t.pointers.size,this.beginAngle=t.angle,this.rotationValueSmooth.reset(),this.scalingValueSmooth.reset(),s(t.center,this.beginCenterScreen),C.fromNormalAndOffset(R,0,this.planeHorizontal);const e=r();this.intersectionHelper.intersectScreenFreePointFallback(this.beginCenterScreen,e);const o=r();m(o,this.beginCamera.viewForward);const a=r();h(a,R);const f=c(o,a),v=n(f<0?-f:f);if(this.panMode=v>=T?w.Horizontal:w.Vertical,C.setOffsetFromPoint(this.planeHorizontal,e,this.planeHorizontal),this.beginCamera.aboveGround||C.negate(this.planeHorizontal,this.planeHorizontal),this.panMode===w.Vertical){if(l(a,a,f),p(this.planeVertical,o,a),u(this.planeVertical,this.planeVertical),C.setOffsetFromPoint(this.planeVertical,e,this.planeVertical),!g()&&this.view._stage.getCamera()._contextNavigation){const t=r(),i=r(),n=r();p(t,e,this.currentCamera.eye),u(t,t);const o=5*Math.max(Math.abs(this.view.camera.position.z),50),s=this.view._stage.renderView.getMinimalDepthForArea(this.beginCenterScreen[0],this.beginCenterScreen[1],this.view._stage.getCamera(),80),a=s?Math.min(s,o):o;h(n,d(i,this.currentCamera.eye,l(i,t,a))),this.planeVertical[3]=-c(this.planeVertical,n)}this.computePlanePoints(t.pointers,this.planeVertical,this.beginCamera,this.tmpPoints),P(this.tmpPoints,this.beginCenter)}else this.computePlanePoints(t.pointers,this.planeHorizontal,this.beginCamera,this.tmpPoints),P(this.tmpPoints,this.beginCenter);this.constraintOptions.interactionStartCamera.copyFrom(this.beginCamera)}update(t){if(!this.active)return;this.currentCamera.copyFrom(this.beginCamera);const i=t.pointers.size>1,e=this.panMode===w.Horizontal?this.planeHorizontal:this.planeVertical,n=this.beginCenter;if(i){const i=this.beginRadius/t.radius,e=.001875*Math.min(Math.max(t.radius,40),120);this.scalingValueSmooth.gain=e,this.scalingValueSmooth.update(i),j(this.currentCamera,n,this.scalingValueSmooth.value,this.view.state.constraints.minimumPoiDistance),this.zoomMomentumEstimator.add(this.scalingValueSmooth.value,.001*t.timestamp),this.constraintOptions.interactionType=1,this.constraintOptions.interactionFactor=v(Math.abs(t.radius-this.beginRadius)),b(this.view,this.currentCamera,this.constraintOptions)}if(this.computePlanePoints(t.pointers,e,this.currentCamera,this.tmpPoints),P(this.tmpPoints,this.tmpCentroid3d),s(t.center,this.tmpCentroid2d),V(this.currentCamera,n,this.tmpCentroid3d),this.panMomentumEstimator.add(this.tmpCentroid2d,this.tmpCentroid3d,.001*t.timestamp),this.constraintOptions.interactionType=4,this.constraintOptions.interactionFactor=v(this.beginCenterScreen,this.tmpCentroid2d),b(this.view,this.currentCamera,this.constraintOptions),i){const i=this.planeHorizontal,e=n,o=this.rotationValueSmooth.value,s=o+S(t.angle-o),r=.00125*Math.min(Math.max(t.radius,40),120);this.rotationValueSmooth.gain=r,this.rotationValueSmooth.update(s);const a=this.rotationValueSmooth.value-this.beginAngle;this.rotationMomentumEstimator.add(a,.001*t.timestamp),z(this.currentCamera,e,f.wrapAxisAngle(i,a)),this.constraintOptions.interactionType=2,this.constraintOptions.interactionFactor=v(Math.abs(t.radius*a)),b(this.view,this.currentCamera,this.constraintOptions)}this.currentCamera.markViewDirty()}end(t){t.pointers.size===this.pointerCount&&this.update(t),this.finishController();const i=this.zoomMomentumEstimator.evaluateMomentum();if(i)return new x({view:this.view,momentum:i,zoomCenter:this.beginCenter});const e=this.rotationMomentumEstimator.evaluateMomentum();if(e)return new F({view:this.view,momentum:e,center:this.beginCenter,axis:C.normal(this.planeHorizontal)});const n=this.panMomentumEstimator.evaluateMomentum();return n?new O({view:this.view,momentum:n}):null}computePlanePoints(t,i,e,n){n.length=t.size;const o=this.tmp2d;let s=0;return t.forEach((t=>{o[0]=t.x,o[1]=t.y,void 0===n[s]&&(n[s]=r()),E(i,e,o,n[s]),s+=1})),n}};t([i({constructOnly:!0})],_.prototype,"view",void 0),_=t([e("esri.views.3d.state.controllers.local.PinchAndPanController")],_);export{_ as PinchAndPanController};
