/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{isSome as t,isNone as i}from"../../../core/maybe.js";import e from"../../../core/Error.js";import{create as a,createAbortController as n,onAbort as r,createAbortError as s}from"../../../core/promiseUtils.js";import o from"../../../Camera.js";import l from"../../../Viewpoint.js";import{whenOnce as c}from"../../../core/watchUtils.js";import{applySurfaceCollisionConstraint as m}from"../camera/constraintUtils/surfaceCollision.js";import{named as h}from"../../animation/easing.js";import{applyAll as w}from"../camera/constraintUtils.js";import{State as p}from"./controllers/CameraController.js";import{PointToPointAnimationController as v}from"./controllers/PointToPointAnimationController.js";import{externalToInternal as f}from"../support/cameraUtils.js";import{SurfaceCollisionCorrectionController as g}from"./controllers/SurfaceCollisionCorrectionController.js";import{create as u}from"../support/viewpointUtils.js";class d{constructor(i,e,s){this.target=i,this.options=e,this.view=s,this.state="pending",this.abortController=null,this.animationController=null,this.promise=a(((i,e)=>{this.resolveCallback=i,this.rejectCallback=e;const a=n();t(this.options.signal)&&r(this.options.signal,(()=>{this.abort()})),this.abortController=a,this.waitForReady()}))}then(t,i){return this.promise.then(t,i)}catch(t){return this.promise.catch(t)}resolve(t){return this.state="finished",this.resolveCallback(t)}reject(t){return this.state="finished",this.rejectCallback(t)}goTo(t,i){switch(this.state){case"pending":case"wait-for-ready":case"wait-for-viewpoint":case"wait-for-animation-finish":i.animate&&this.options.animate?this.reject(new e("AbortError")):this.abort()}return new d(t,i,this.view)}waitForReady(){this.state="wait-for-ready",this.view.stateManager.view.ready?this.createViewPoint():c(this.view.stateManager.view,"ready",this.abortController.signal).then((()=>{this.createViewPoint()}),(t=>{this.reject(t)}))}createViewPoint(){"finished"!==this.state&&(this.state="wait-for-viewpoint",this.animationController=this.options.animate?this.getAnimationController():null,u(this.view.stateManager.view,this.target,this.abortController.signal).then((t=>{if("finished"===this.state)return;const e=this.getCameraFromViewpoint(t);if(!i(e))if(this.options.animate){if(i(this.animationController))return;this.startAnimation(e,this.animationController)}else this.view.stateManager.setStateCamera(e.camera,{applyConstraints:!e.isFullySpecified,positionAndOrientationOnly:!0,doNotCancelGoToOperation:!0}),this.resolve()}),(t=>{this.reject(t)})))}internalAnimateOptions(t){const i={};return t&&(null!=t.speedFactor&&(i.speedFactor=t.speedFactor),null!=t.duration&&(i.duration=t.duration/1e3),null!=t.maxDuration&&(i.maxDuration=t.maxDuration/1e3),null!=t.easing&&("string"==typeof t.easing?i.easing=h[t.easing]:i.easing=t.easing)),i}getCameraFromViewpoint(t){const a=!!(this.target instanceof l&&this.target.camera||this.target instanceof o),n=t.camera;if(i(n))return null;if(!this.view.stateManager.isCompatible(n)){const t=n.position,i=t&&t.spatialReference,a=i?i.wkid:"none",r=this.view.stateManager.view.spatialReference.wkid;return this.reject(new e("GotoAnimation:incompatible-spatialreference",`Resulting camera has an incompatible spatial reference (camera: ${a}, view: ${r})`,{camera:n})),null}const r=f(this.view.stateManager.view,n);return r?{viewpoint:t,camera:r,isFullySpecified:a}:(this.reject(new e("GotoAnimation:invalid-camera","Resulting camera is invalid")),null)}startAnimation(a,n){this.state="wait-for-animation-finish";const r=n.viewAnimation;if(i(r))return void this.reject(new e("GotoAnimation:missing-animation","Unreachable code in view.stateManager"));if(r.update(a.viewpoint,"running"),!n.active||i(n.viewAnimation)||n.viewAnimation.target!==a.viewpoint||this.view.stateManager.view.state.cameraController!==n)return this.abort();let s;a.isFullySpecified?(s=new g({view:this.view.stateManager.view,desiredCamera:a.camera}),m(this.view.stateManager.view,a.camera,1)):w(this.view.stateManager.view,a.camera),n.begin(a.camera,this.internalAnimateOptions(this.options));const o=t=>{if(!i(this.view.stateManager.view.state))switch(n.state){case p.Finished:switch(this.state){case"pending":case"wait-for-ready":case"wait-for-viewpoint":case"wait-for-animation-finish":this.resolve()}break;case p.Ready:case p.Rejected:case p.Running:case p.Stopped:switch(this.state){case"pending":case"wait-for-ready":case"wait-for-viewpoint":case"wait-for-animation-finish":this.reject(t)}}};r.when((()=>{const i=this.view.stateManager.view.state.cameraController;s&&(i&&i.active?i instanceof v&&t(i.viewAnimation)&&i.viewAnimation.target===a.viewpoint&&(this.view.stateManager.view.state.cameraController=s):t(n.viewAnimation)&&n.viewAnimation.target===a.viewpoint&&"finished"===n.state&&(this.view.stateManager.view.state.cameraController=s))}),(t=>o(t))),n.asyncResult={resolve:()=>o(),reject:t=>o(t)}}getAnimationController(){let i,a=null;const n=this.view.stateManager.view.state.cameraController;return n instanceof v&&(n.updateStateFromViewAnimation(),n.active&&(i=n,a=i.viewAnimation)),null!=i||(i=new v({view:this.view.stateManager.view,mode:"animation"}),a=i.viewAnimation,this.view.stateManager.view.state.switchCameraController(i))?i:(t(a)&&a.stop(),this.reject(new e("GotoAnimation:goto-cannot-interrupt","Cannot start an animation while interacting")),null)}abort(){switch(this.state){case"pending":case"wait-for-ready":case"wait-for-viewpoint":this.reject(s());break;case"wait-for-animation-finish":t(this.animationController)&&this.view.stateManager.view.state.cameraController===this.animationController&&this.animationController.active&&this.animationController.stopController(),this.reject(s())}}}export{d as GoToOperation};
