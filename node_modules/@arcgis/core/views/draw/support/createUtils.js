/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{clone as t}from"../../../core/lang.js";import{isSome as e}from"../../../core/maybe.js";import{equals as r}from"../../../core/arrayUtils.js";import{isValid as s}from"../../../geometry/support/spatialReferenceUtils.js";import o from"../../../geometry/Point.js";import a from"../../../geometry/Multipoint.js";import{unnormalizeGeometryOnDatelineCrossing as n,isClockwise as i,unnormalizeVerticesOnDatelineCrossing as l}from"../../../geometry/support/coordsUtils.js";import c from"../../../geometry/Polygon.js";import h from"../../../geometry/Polyline.js";import"../../../geometry.js";import{c as m}from"../../../chunks/vec3f64.js";import{a as p,d as f,f as u,n as y,c as d,q as x}from"../../../chunks/vec3.js";import{getMetersPerUnitForSR as g}from"../../../core/unitUtils.js";import{a as R}from"../../../chunks/quatf64.js";import M from"../../../geometry/Circle.js";import{r as w,i as T}from"../../../chunks/quat.js";import{simplify as W,distance as v}from"../../../geometry/geometryEngine.js";import{a as S}from"../../../chunks/mat2d.js";import{c as F,a as j}from"../../../chunks/mat2df64.js";function U(t,r,s=null){return e(s)?[t,r,s]:[t,r]}function C(t,r,s=null){return e(s)?{x:t,y:r,z:s}:{x:t,y:r}}class L{constructor(t){this.spatialReference=t}mapToLocalMultiple(t){return t.map((t=>this.mapToLocal(t)))}get doUnnormalization(){return!1}}class P extends L{constructor(t,e,r=null){super(e),this.defaultZ=r,this.transform=F(),this.transformInv=F(),this.transform=j(t),S(this.transformInv,this.transform)}makeMapPoint(t,e){return U(t,e,this.defaultZ)}mapToLocal(t){return C(this.transform[0]*t[0]+this.transform[2]*t[1]+this.transform[4],this.transform[1]*t[0]+this.transform[3]*t[1]+this.transform[5])}localToMap(t){return U(this.transformInv[0]*t.x+this.transformInv[2]*t.y+this.transformInv[4],this.transformInv[1]*t.x+this.transformInv[3]*t.y+this.transformInv[5],this.defaultZ)}}class b extends L{constructor(t,e){super(t.spatialReference),this.view=t,this.defaultZ=null,this.pWS=m(),this.tangentFrameUpWS=m(),this.tangentFrameRightWS=m(),this.tangentFrameForwardWS=m(),this.localFrameRightWS=m(),this.localFrameUpWS=m(),this.worldToLocalTransform=R(),this.localToWorldTransform=R(),this.scale=1,this.scale=t.resolution,this.referenceMapPoint=e,this.defaultZ=e.hasZ?e.z:null;const r=t.state.camera.viewRight;this.view.renderCoordsHelper.toRenderCoords(this.referenceMapPoint,this.pWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,0,this.tangentFrameRightWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,1,this.tangentFrameUpWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,2,this.tangentFrameForwardWS);const s=m();p(s,this.tangentFrameForwardWS,f(r,this.tangentFrameForwardWS)),u(this.localFrameRightWS,r,s),y(this.localFrameRightWS,this.localFrameRightWS),d(this.localFrameUpWS,this.tangentFrameForwardWS,this.localFrameRightWS),w(this.worldToLocalTransform,this.localFrameRightWS,this.tangentFrameRightWS),T(this.localToWorldTransform,this.worldToLocalTransform)}get doUnnormalization(){return"global"===this.view.viewingMode}makeMapPoint(t,e){return U(t,e,this.defaultZ)}mapToLocal(t){const e=m();this.view.renderCoordsHelper.toRenderCoords(new o({x:t[0],y:t[1],spatialReference:this.spatialReference}),e),x(e,e,this.worldToLocalTransform);const r=this.view.renderCoordsHelper.fromRenderCoords(e,this.view.spatialReference);return C(r.x/this.scale,r.y/this.scale)}localToMap(t){const e=m();this.view.renderCoordsHelper.toRenderCoords(new o({x:t.x*this.scale,y:t.y*this.scale,spatialReference:this.spatialReference}),e),x(e,e,this.localToWorldTransform);const r=this.view.renderCoordsHelper.fromRenderCoords(e,this.view.spatialReference);return U(r.x,r.y,this.defaultZ)}}function z(t,e){if("2d"===t.type)return new P(t.state.transform,t.spatialReference,e.length>2?e[2]:null);if("3d"===t.type){const r=e.length>2?new o({x:e[0],y:e[1],z:e[2],spatialReference:t.spatialReference}):new o({x:e[0],y:e[1],spatialReference:t.spatialReference});return new b(t,r)}return null}function I(t,e){const r=new o({x:t[0],y:t[1],spatialReference:e});return t.length>2&&(r.z=t[2]),r}function k(t,e){return new a({points:t,spatialReference:e})}function H(t,e,r){const s=new h({paths:t,spatialReference:e});return r&&n(s),s}function Z(e,o,a,l=!0){const h=t(e);h.forEach((t=>{const e=t[0],s=t[t.length-1];r(e,s)&&1!==t.length||t.push(t[0])}));let m=new c({rings:h,spatialReference:o});return m.rings.forEach((t=>{i(t,!1,!1)||t.reverse()})),a&&n(m),l&&m.isSelfIntersecting&&s(o)&&(m=W(m)),m}function q(t,e,r){const s=e.mapToLocalMultiple(t),o=[],a={x:s[0].x,y:s[0].y},n=s[1].x,i=s[1].y,l=Math.round(n-a.x),c=Math.round(i-a.y),h=Math.max(Math.abs(l),Math.abs(c));if(r){const t={x:a.x+h,y:a.y+h},e={x:a.x-h,y:a.y-h};o.push(C(t.x,e.y),C(e.x,e.y),C(e.x,t.y),C(t.x,t.y))}else{const t={x:l>0?a.x+h:a.x-h,y:c>0?a.y+h:a.y-h};o.push(C(a.x,a.y),C(t.x,a.y),C(t.x,t.y),C(a.x,t.y))}return Z([o.map((t=>e.localToMap(t)))],e.spatialReference,e.doUnnormalization,!0)}function A(t,e,r){let s=e.mapToLocalMultiple(t);if(1===s.length){const t=48,e=s[0];s=[C(e.x-t,e.y+t),C(e.x+t,e.y-t),C(e.x+t,e.y-t),C(e.x-t,e.y+t)]}const o=[],a={x:s[0].x,y:s[0].y},n={x:s[1].x,y:s[1].y};if(r){const t=Math.round(n.x-a.x),e=Math.round(n.y-a.y);o.push(C(a.x-t,a.y-e),C(n.x,a.y-e),C(n.x,n.y),C(a.x-t,n.y))}else o.push(C(a.x,a.y),C(n.x,a.y),C(n.x,n.y),C(a.x,n.y));return Z([o.map((t=>e.localToMap(t)))],e.spatialReference,e.doUnnormalization,!0)}function B(t,e,r,o){const a=e.mapToLocalMultiple(t);let n=null,i=null;if(r)n=a[0],i=a[1];else{const t=a[0],e=a[1],r=Math.round(e.x-t.x),s=Math.round(e.y-t.y),o=Math.max(Math.abs(r),Math.abs(s));n=C(r>0?t.x+o/2:t.x-o/2,s>0?t.y+o/2:t.y-o/2),i=C(Math.abs(r)>Math.abs(s)?n.x-o/2:n.x,Math.abs(r)>Math.abs(s)?n.y:n.y-o/2)}const c=e.localToMap(n),h=e.localToMap(i);e.doUnnormalization&&l([[c,h]],e.spatialReference);const m=I(c,e.spatialReference),p=I(h,e.spatialReference),f=g(e.spatialReference);let u=0;if(s(e.spatialReference))u=f*v(m,p,null);else{const t=n.x-i.x,e=n.y-i.y;u=f*Math.sqrt(t*t+e*e)*(o||1)}const y=new M({center:m,radius:u,radiusUnit:"meters",spatialReference:e.spatialReference});return Z(y.rings,y.spatialReference,!1)}function E(t,e,r){const s=e.mapToLocalMultiple(t),o=s[0],a=s[1],n=Math.round(a.x-o.x),i=Math.round(a.y-o.y),l=C(r?o.x:o.x+n/2,r?o.y:o.y+i/2),c=r?n:n/2,h=r?i:i/2,m=[],p=2*Math.PI/60;for(let t=0;t<60;t++){const e=Math.cos(t*p),r=Math.sin(t*p),s=C(c*e+l.x,h*r+l.y);m.push(s)}return m.push(m[0]),Z([m.map((t=>e.localToMap(t)))],e.spatialReference,e.doUnnormalization,!1)}export{P as AffineCoordinateSystem,b as SceneViewCoordinateSystem,L as SurfaceCoordinateSystem,B as createCircle,E as createEllipse,k as createMultipoint,I as createPoint,Z as createPolygon,H as createPolyline,A as createRectangle,q as createSquare,z as createViewAlignedCoordinateSystem,U as makeMapPoint,C as makeSurfacePoint};
