/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{clone as t}from"../../core/lang.js";import{isSome as n,isNone as e,unwrap as r}from"../../core/maybe.js";import{handlesGroup as a}from"../../core/handleUtils.js";import{project as o,canProject as c}from"../../geometry/support/webMercatorUtils.js";import{clamp as s}from"../../core/mathUtils.js";import{createScreenPoint as l}from"../../core/screenUtils.js";import{move as u}from"../draw/support/drawUtils.js";function i(t,r){let a=null,o=null;return c=>{if("cancel"===c.action)return void(n(o)&&(o.execute({action:"cancel"}),a=null,o=null));const s={action:c.action,screenStart:c.start,screenEnd:c.screenPoint};"start"===c.action&&e(a)&&(a=new R,o=new R,r(t,a,o,c.pointerType,s)),n(a)&&a.execute(s),"end"===c.action&&n(a)&&(a=null,o=null)}}function p(t,n){return t.events.on("drag",i(t,n))}function m(t,n){const e=[];for(const r of t)e.push(p(r,n));return a(e)}function f(t,n){const e=[t.x,t.y,t.z],r=n,a=[Math.cos(r),Math.sin(r)],o=Math.sqrt(a[0]*a[0]+a[1]*a[1]);if(0===o)return null;a[0]/=o,a[1]/=o;const c=t=>{const n=(t.x-e[0])*a[0]+(t.y-e[1])*a[1];t.x=e[0]+n*a[0],t.y=e[1]+n*a[1]};return t=>(c(t.mapStart),c(t.mapEnd),t)}function d(t,r){let a=null;const s=n(t[r])?t[r].spatialReference:null;return l=>{var i,p;if("start"===l.action&&n(t[r])&&(i=t[r],p=l.mapStart.spatialReference,a=e(i)||"mesh"===i.type?null:i.spatialReference.equals(p)?i.clone():c(i,p)?o(i,p):null),e(a))return null;const m=l.mapEnd.x-l.mapStart.x,f=l.mapEnd.y-l.mapStart.y,d=l.mapEnd.z-l.mapStart.z,y=u(a.clone(),m,f,d);return y.spatialReference.equals(s)?t[r]=y:t[r]=o(y,s),{...l,translationX:m,translationY:f,translationZ:d}}}function y(t){return d(t,"geometry")}function x(t,r=null,a){let c=null;const s=n(r)&&!t.spatialReference.equals(r)?t=>n(t)?o(t,r):t:t=>t,l={exclude:[],...a};return r=>{if("start"===r.action&&(c=s(t.toMap(r.screenStart,l))),e(c))return null;const a=s(t.toMap(r.screenEnd,l));return n(a)?{...r,mapStart:c,mapEnd:a}:null}}function E(t){const e=t.map((t=>r(y(t)))).filter((t=>n(t)));return t=>{const n=t.mapEnd.x-t.mapStart.x,r=t.mapEnd.y-t.mapStart.y,a=t.mapEnd.z-t.mapStart.z;return e.forEach((n=>n(t))),{...t,translationX:n,translationY:r,translationZ:a}}}function S(n,e){const r=new Map;for(const a of e)r.set(a,t(n[a]));return t=>(r.forEach(((t,e)=>{n[e]=t})),t)}function h(t){return S(t,["geometry"])}function w(t){const e=t.map((t=>r(h(t)))).filter((t=>n(t)));return t=>(e.forEach((n=>n(t))),t)}function z(t){const e=n(t.symbol)?t.symbol.clone():null;return n=>(t.symbol=e,n)}function g(){let t=0,n=0,e=0;return r=>{"start"===r.action&&(t=r.mapStart.x,n=r.mapStart.y,e=r.mapStart.z);const a=r.mapEnd.x-t,o=r.mapEnd.y-n,c=r.mapEnd.z-e;return t=r.mapEnd.x,n=r.mapEnd.y,e=r.mapEnd.z,{...r,mapDeltaX:a,mapDeltaY:o,mapDeltaZ:c,mapDeltaSpatialReference:r.mapStart.spatialReference}}}function j(){let t=0,n=0;return e=>{"start"===e.action&&(t=e.screenStart.x,n=e.screenStart.y);const r=e.screenEnd.x-t,a=e.screenEnd.y-n;return t=e.screenEnd.x,n=e.screenEnd.y,{...e,screenDeltaX:r,screenDeltaY:a}}}function M(t,n){let e=null,r=0,a=0;return o=>{if("start"===o.action&&(e=t.toScreen(n),e.x<0||e.x>t.width||e.y<0||e.y>t.height?e=null:(r=o.screenStart.x-e.x,a=o.screenStart.y-e.y)),null==e)return null;const c=s(o.screenEnd.x-r,0,t.width),u=s(o.screenEnd.y-a,0,t.height),i=l(c,u);return o.screenStart=e,o.screenEnd=i,o}}class R{constructor(){this.execute=()=>{}}next(t,e=new R){return n(t)&&(this.execute=r=>{const a=t(r);n(a)&&e.execute(a)}),e}}export{R as EventPipeline,g as addMapDelta,j as addScreenDelta,f as constrainToMapAxis,i as createDragEventPipelineCallback,p as createManipulatorDragEventPipeline,m as createManipulatorDragEventPipelineMany,M as dragAtLocation,d as dragGeometry,y as dragGraphic,E as dragGraphicMany,h as resetGraphic,w as resetGraphicMany,S as resetProperties,z as resetSymbol,x as screenToMap};
