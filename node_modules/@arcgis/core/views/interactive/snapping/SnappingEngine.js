/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{isSome as t}from"../../../core/maybe.js";import{makeHandle as e,handlesGroup as n}from"../../../core/handleUtils.js";import i from"../../../core/Collection.js";import{watch as r}from"../../../core/watchUtils.js";import{a as o}from"../../../chunks/vec2f64.js";import{i as a,d as s,p}from"../../../chunks/vec2.js";import{defaults as c}from"./Settings.js";import{squareDistance as d,anyMapPointToScreenPoint as l}from"./snappingUtils.js";import{cross as h}from"../../3d/support/geometryUtils/vector2d.js";import{LineConstraint as f,LineLikeConstraint as u}from"./SnappingConstraint.js";import{IntersectionSnappingCandidate as g}from"./IntersectionSnappingCandidate.js";import{LineSnapper as m}from"./LineSnapper.js";import{ParallelLineSnapper as S}from"./ParallelLineSnapper.js";import{RightAngleSnapper as _}from"./RightAngleSnapper.js";import{RightAngleTriangleSnapper as v}from"./RightAngleTriangleSnapper.js";class P{constructor(t){this._snapper=new i,this._currentSnappingCandidate=null,this._visualElementHandles=e(),this._optionsHandle=e(),this._squaredMouseProximityTreshold=c.pointProximityThreshold*c.pointProximityThreshold,this._squaredTouchProximityThreshold=c.pointProximityThreshold*c.pointProximityThreshold*c.touchSensitivityMultiplier*c.touchSensitivityMultiplier,this._snapper.push(new S({enabled:t.effectiveSelfEnabled})),this._snapper.push(new m({enabled:t.effectiveSelfEnabled})),this._snapper.push(new _({enabled:t.effectiveSelfEnabled})),this._snapper.push(new v({enabled:t.effectiveSelfEnabled})),this._optionsHandle=r(t,"effectiveSelfEnabled",(()=>{for(const e of this._snapper)e.enabled=t.effectiveSelfEnabled;this.doneSnapping()}))}snap(t,e){const n=[];for(const i of this._snapper.items)n.push(...i.snap(t,e));return this._aggregateSnappingCandidates(n,t,e)}destroy(){this.doneSnapping(),this._optionsHandle.remove()}doneSnapping(){this._visualElementHandles.remove(),this._currentSnappingCandidate=null}_aggregateSnappingCandidates(e,n,i){const r=e.length,o=i.geometry.data.coordinateHelper.fromPoint(n);if(t(this._currentSnappingCandidate)){if(this.isCurrentIntersectionConstraintStillActive(e)&&a(o,this._currentSnappingCandidate.targetPoint)<this.squaredPointProximityThreshold(i.pointer))return i.geometry.data.coordinateHelper.createDehydratedPoint(this._currentSnappingCandidate.targetPoint);const n=y(e,this._currentSnappingCandidate);if(this.doneSnapping(),n>=0){const a=e[n],s=[];if(a.constraint instanceof u){for(let p=0;p<r;++p){if(p===n)continue;const r=e[p];if(r.constraint instanceof u){const e=this._intersectRaysAndLines(a,r,i);if(t(e)){const t=d(l(o,i.geometry.data.coordinateHelper,i.elevationInfo,i.view),l(e.targetPoint,i.geometry.data.coordinateHelper,i.elevationInfo,i.view));s.push([e,t])}}}if(s.length>0&&(s.sort(((t,e)=>t[1]-e[1])),s[0][1]<this.squaredPointProximityThreshold(i.pointer)))return this.updateSnappingCandidate(s[0][0],e,i)}return this.updateSnappingCandidate(a,e,i)}}if(r>0){let t=0,n=a(o,e[0].targetPoint);for(let i=1;i<r;++i){const r=a(o,e[i].targetPoint);r<n&&(n=r,t=i)}return this.updateSnappingCandidate(e[t],e,i)}return n}_intersectRaysAndLines(t,e,n){const i=t.constraint.start,r=t.constraint.end,a=e.constraint.start,d=e.constraint.end,l=s(o(),r,i),u=s(o(),d,a),m=h(l,u);if(Math.abs(m)<=c.intersectionParallelLineThreshold)return null;const S=s(o(),i,a),_=h(u,S)/m,v=h(l,S)/m,P=n.geometry.data.coordinateHelper;if(_>=0){if(v>=0||e.constraint instanceof f){const n=P.clone(t.targetPoint);return p(n,i,l,_),new g(P,n,t,e)}}else if(t.constraint instanceof f&&(v>=0||e.constraint instanceof f)){const n=P.clone(t.targetPoint);return p(n,i,l,_),new g(P,n,t,e)}return null}isCurrentIntersectionConstraintStillActive(t){if(this._currentSnappingCandidate instanceof g){const e=this._currentSnappingCandidate.left,n=this._currentSnappingCandidate.right,i=y(t,e),r=y(t,n);return i>=0&&r>=0}return!1}updateSnappingCandidate(t,e,i){this._currentSnappingCandidate=t;const r=this._currentSnappingCandidate.targetPoint,o=[t.visualize(i.view,i.elevationInfo,r)];for(const n of e){if(t instanceof g){if(n.constraint.objectEqual(t.left.constraint)||n.constraint.objectEqual(t.right.constraint))continue}else if(n.constraint.objectEqual(t.constraint))continue;n.constraint.check(r)&&o.push(n.visualizeReferenceHints(i.view,i.elevationInfo,r))}return this._visualElementHandles=n(o),i.geometry.data.coordinateHelper.createDehydratedPoint(r)}squaredPointProximityThreshold(t){return"touch"===t?this._squaredTouchProximityThreshold:this._squaredMouseProximityTreshold}}function y(t,e){let n=-1;for(let i=0;i<t.length;++i)if(e.constraint.objectEqual(t[i].constraint)){n=i;break}return n}export{P as SnappingEngine};
