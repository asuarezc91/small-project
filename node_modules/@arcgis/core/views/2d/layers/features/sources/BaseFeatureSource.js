/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import e from"../../../../../core/has.js";import{isSome as t,isNone as s}from"../../../../../core/maybe.js";import r from"../../../../../core/Logger.js";import i from"../../../../../core/Error.js";import{throwIfAborted as o,isAbortError as n,all as u}from"../../../../../core/promiseUtils.js";import a from"../../../../../request.js";import c from"../../../../../tasks/support/Query.js";import{QueueProcessor as l}from"../../../../support/QueueProcessor.js";import{createSourceAdapter as d}from"../controllers/support/sources.js";import{DataTileSource as h}from"./DataTileSource.js";const p=r.getLogger("esri.views.2d.layers.features.sources.BaseFeatureSource");class y extends h{constructor(t){super(t),this.type="feature",this._adapter=d(t.serviceInfo),this._queue=new l({concurrency:8,process:async t=>{o(t);const s=t.tile.key.id,{tile:r,signal:i}=t,n={query:e("esri-tiles-debug")?{tile:s.replace(/\//g,"."),depth:t.depth}:void 0,signal:i,transform:r.transform};return this._adapter.executeQuery(t.query,n)}}),this._patchQueue=new l({concurrency:8,process:async t=>{o(t);const s=t.tile.key.id,{tile:r,signal:i}=t,n={query:e("esri-tiles-debug")?{tile:s.replace(/\//g,"."),depth:t.depth}:void 0,signal:i,transform:r.transform};return this._adapter.executeQuery(t.query,n)}})}destroy(){this._adapter.destroy(),this._queue.destroy(),this._patchQueue.destroy()}setViewState(e){}get updating(){return!!this._queue.length}subscribe(e){super.subscribe(e),this._fetchDataTile(e).catch((t=>{n(t)||p.error(new i("mapview-query-error","Encountered error when fetching tile",{tile:e,error:t}))}))}unsubscribe(e){super.unsubscribe(e)}pause(){this._queue.pause()}resume(){this._queue.resume()}async query(e,t){return this._adapter.executeQuery(e,t)}async queryLastEditDate(){const e=this._serviceInfo.source,t={...e.query,f:"json"};return(await a(e.path,{query:t,responseType:"json"})).data.editingInfo.lastEditDate}forEachRequest(e,t){const s=this._subscriptions.get(e),{requests:r,signal:i}=s;for(const e of r.done)t(e.request,{signal:i})}async _executePatchQuery(e,s,r,i){const o=s.clone();o.outFields=[this._serviceInfo.objectIdField,...r],o.returnCentroid=!1,o.returnGeometry=!1;const n=t(o.start)?o.start/8e3:0,u=i.signal;return this._patchQueue.push({tile:e,query:o,signal:u,depth:n})}async _resendRequest(e,r){const{query:i,request:n}=e,u=t(i.outFields)?i.outFields:[],a=this._sourceQueryInfo.outFields,c=a.filter((e=>-1===u.indexOf(e)));if(!s(n.features))if(c.length)try{const e=await this._executePatchQuery(n.tile,i,c,r);o(r),i.outFields=a,n.features.joinAttributes(e),this._onRequest({...n,end:n.end||r.end},"new",r)}catch(e){}else this._onRequest({...n,end:n.end||r.end},"new",r)}async resend({dataTileOnly:e}){let t=0,s=!1;const r=[];for(this._subscriptions.forEach((e=>{if(!e.requests.done.length){const t=e.tile;this._onRequest({tile:t,id:t.id,features:null,noData:!0,end:!1},"new",{dataTileOnly:!0})}}));!s;)s=!0,this._subscriptions.forEach((({requests:i,signal:o})=>{if(i.done.length>t){s=!1;const n=i.done.length===t+1;r.push(this._resendRequest(i.done[t],{signal:o,dataTileOnly:e,end:n}))}})),t++;await u(r)}_createQuery(e,t){const s=new c({...this._serviceQueryInfo,...this._sourceQueryInfo,...t});return this._serviceInfo.capabilities.query.supportsQuantization||(t.quantizationParameters=null,s.maxAllowableOffset=e.resolution),t.quantizationParameters&&"esriGeometryPolyline"===this.geometryType&&(s.maxAllowableOffset=e.resolution),s.resultType="tile",s.geometry=e.extent,s}}export{y as BaseFeatureSource};
