/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import e from"../../../../../core/has.js";import{isNone as t,isSome as s,andThen as r}from"../../../../../core/maybe.js";import{getInfo as a}from"../../../../../geometry/support/spatialReferenceUtils.js";import i from"../../../../../geometry/SpatialReference.js";import{earth as o}from"../../../../../geometry/support/Ellipsoid.js";import"../../../../../geometry.js";import h from"../../../../../core/Evented.js";import{diff as l,hasDiff as n}from"../../../../../core/accessorSupport/diffUtils.js";import u from"../../../../../layers/graphics/OptimizedFeature.js";import c from"../../../../../layers/graphics/OptimizedGeometry.js";import{quantizeX as g,quantizeY as d}from"../../../../../layers/graphics/featureConversionUtils.js";import{setGeohashBuf as p,setGeohashXY as f}from"../../../../../geohash/geohashUtils.js";import{FeatureSetReaderJSON as _}from"./FeatureSetReaderJSON.js";import{GeohashTree as m}from"../../../../../geohash/GeohashTree.js";import{checkProjectionSupport as y,project as I}from"../../../../../layers/graphics/data/projectionSupport.js";import{TILE_SIZE as b}from"../../../engine/webgl/definitions.js";import{Store2D as v}from"../Store2D.js";class R extends u{constructor(e,t,s,r,a){super(new c([],[t,s]),r,null,e),this.geohashBoundsInfo=a}get count(){return this.attributes.cluster_count}static create(e,t,s,r,a,i,o,h){const l=new R(t,s,r,i,o);return l.displayId=e.createDisplayId(!0),l.referenceId=h,l.tileLevel=a,l}update(e,t,s,r,a,i){return this.geometry.coords[0]=e,this.geometry.coords[1]=t,this.tileLevel=s,this.attributes=r,this.geohashBoundsInfo=a,this.referenceId=null,this.referenceId=i,this}toJSON(){return{objectId:this.objectId,referenceId:1===this.attributes.cluster_count?this.referenceId:null,attributes:{...this.attributes,clusterId:this.objectId},geometry:{x:this.geometry.coords[0],y:this.geometry.coords[1]}}}}function M(e){return 57.29577951308232*e}class C extends v{constructor(e,t,s){super(e,s),this.events=new h,this._geohashLevel=0,this._aggregateValueRanges={},this._aggregateValueRangesChanged=!1,this._geohashBuf=[],this._clusters=new Map,this._tiles=new Map,this.geometryInfo=e.geometryInfo,this._spatialReference=t,this._projectionSupportCheck=y(t,i.WGS84),this._bitsets.geohash=s.getBitset(s.createBitset()),this._bitsets.inserted=s.getBitset(s.createBitset())}async updateSchema(s,r){const a=this._schema;try{await super.updateSchema(s,r),await this._projectionSupportCheck}catch(e){}const i=l(a,r);s.mesh&&(s.targets.aggregate=!0),r&&(!t(i)||s.source||s.storage.filters)&&((n(i,"params.fields")||!this._tree||s.source)&&(this._tree=new m(this._statisticFields),this._rebuildTree(),e("esri-2d-update-debug")&&console.debug("Aggregate mesh needs update due to tree changing")),e("esri-2d-update-debug")&&console.debug("Applying Update - ClusterStore:",i),s.mesh=!0,s.targets[r.name]=!0,this._aggregateValueRanges={})}sweepFeatures(e,t){this._bitsets.inserted.forEachSet((s=>{if(!e.has(s)){const e=t.lookupByDisplayIdUnsafe(s);this._remove(e)}}))}sweepClusters(e,t,s){this._clusters.forEach(((r,a)=>{r&&r.tileLevel!==s&&(e.releaseDisplayId(r.displayId),t.unsetAttributeData(r.displayId),this._clusters.delete(a))}))}onTileData(e,s,r,a,i){if(!this._schema||t(s.addOrUpdate))return s;const o=this._tree,h=this._getTransforms(e,this._spatialReference);{const e=s.addOrUpdate.getCursor();for(;e.next();)this._update(e,a,o)}if(!i)return s;const l=new Array,n=this._schema.params.clusterRadius;this._getClustersForTile(l,e,n,r,o,h),s.type="replace"===s.type?"replace":"update",s.addOrUpdate=_.fromOptimizedFeatures(l,"esriGeometryPoint"),s.addOrUpdate._storage=r;{const t=s.addOrUpdate.getCursor();for(;t.next();){const s=t.getDisplayId();this._bitsets.computed.unset(s),this.setComputedAttributes(r,t,s,e.scale)}}return this._aggregateValueRangesChanged&&s.end&&(this.events.emit("valueRangesChanged",{valueRanges:this._aggregateValueRanges}),this._aggregateValueRangesChanged=!1),s}onTileUpdate({added:e,removed:t}){if(e.length){const t=e[0].level;this._setGeohashLevel(t)}if(!this._schema)return;const s=this._schema.params.clusterRadius;t.forEach((e=>{this._tiles.delete(e.key.id),this._markTileClustersForDeletion(e,s)}))}getAggregate(e){let t=null;return this._clusters.forEach((s=>{s&&s.displayId===e&&(t=s.toJSON())})),t}getDisplayId(e){const t=this._clusters.get(e);return t?t.displayId:null}getFeatureDisplayIdsForAggregate(e){const t=this._clusters.get(e);if(!t)return[];const s=t.geohashBoundsInfo;return this._tree.getRegionDisplayIds(s.xLL,s.yLL,s.xTR,s.yTR,s.level)}getDisplayIdForReferenceId(e){let t;return this._clusters.forEach((s=>{s&&s.referenceId===e&&(t=s.displayId)})),t}getAggregateValueRanges(){return this._aggregateValueRanges}forEach(e){this._clusters.forEach(((t,s)=>{t&&e(t,s)}))}size(){let e=0;return this.forEach((t=>e++)),e}_rebuildTree(){this._bitsets.computed.clear(),this._bitsets.inserted.clear(),this._bitsets.geohash.clear(),this._tree&&this._tree.clear()}_remove(e){const t=e.getDisplayId(),s=e.getXHydrate(),r=e.getYHydrate(),a=this._geohashBuf[2*t],i=this._geohashBuf[2*t+1];this._bitsets.inserted.has(t)&&(this._bitsets.inserted.unset(t),this._tree.removeCursor(e,s,r,a,i,this._geohashLevel))}_update(e,t,s){const r=e.getDisplayId(),a=this._bitsets.inserted,i=t.isVisible(r);if(i===a.has(r))return;if(!i)return void this._remove(e);const o=e.getXHydrate(),h=e.getYHydrate();if(!this._setGeohash(r,o,h))return;const l=this._geohashBuf[2*r],n=this._geohashBuf[2*r+1];s.insertCursor(e,r,o,h,l,n,this._geohashLevel),a.set(r)}_setGeohash(e,t,s){if(this._bitsets.geohash.has(e))return!0;const r=this._geohashBuf;if(this._spatialReference.isWebMercator){const a=M(t/o.radius),i=a-360*Math.floor((a+180)/360),h=M(Math.PI/2-2*Math.atan(Math.exp(-1*s/o.radius)));p(r,e,h,i,12)}else{const a=I({x:t,y:s},this._spatialReference,i.WGS84);if(!a)return!1;p(r,e,a.y,a.x,12)}return this._bitsets.geohash.set(e),!0}_getClustersForTile(e,a,i,o,h,l,n=!0){const c=this._schema.params.clusterPixelBuffer,p=2*i,f=this._getGeohashLevel(a.key.level),_=Math.ceil(Math.pow(2,a.key.level)*b/p),m=Math.ceil(c/p)+0,y=Math.ceil(b/p),{row:I,col:v}=a.key,R=v*b,M=I*b,C=Math.floor(R/p)-m,x=Math.floor(M/p)-m,w=C+y+2*m,L=x+y+2*m,j=a.tileInfoView.getLODInfoAt(a.key.level);for(let i=C;i<=w;i++)for(let c=x;c<=L;c++){let p=i;j.wrap&&(p=i<0?i+_:i%_);const m=j.wrap&&i<0,y=j.wrap&&i%_!==i,I=this._lookupCluster(o,j,a.key.level,p,c,f,h);if(s(I)){const a=r(l,(e=>m?e.left:y?e.right:e.tile));if(n&&t(a))continue;if(!I.count)continue;if(s(a)&&n){const t=I.geometry.clone();let r=I.attributes;t.coords[0]=g(a,t.coords[0]),t.coords[1]=d(a,t.coords[1]),1===I.count&&s(I.referenceId)&&(r={...I.attributes,referenceId:I.referenceId});const i=new u(t,r);i.displayId=I.displayId,e.push(i)}}}}_getGeohashLevel(e){return Math.min(Math.ceil(e/2+2),12)}_setGeohashLevel(e){const t=this._getGeohashLevel(e),s=1*(Math.floor(t/1)+1)-1;if(this._geohashLevel!==s)return this._geohashLevel=s,void this._rebuildTree()}_getTransforms(e,t){const s={originPosition:"upperLeft",scale:[e.resolution,e.resolution],translate:[e.bounds[0],e.bounds[3]]},r=a(t);if(!r)return{tile:s,left:null,right:null};const[i,o]=r.valid;return{tile:s,left:{...s,translate:[o,e.bounds[3]]},right:{...s,translate:[i-o+e.bounds[0],e.bounds[3]]}}}_getClusterId(e,t,s){return(15&e)<<28|(16383&t)<<14|16383&s}_markForDeletion(e,t,s){const r=this._getClusterId(e,t,s);this._clusters.delete(r)}_getClusterBounds(e,t,s){const r=this._schema.params.clusterRadius,a=2*r;let i=s%2?t*a:t*a-r;const o=s*a;let h=i+a;const l=o-a,n=Math.pow(2,e.level)*b;e.wrap&&i<0&&(i=0),e.wrap&&h>n&&(h=n);const u=i/b,c=o/b,g=h/b,d=l/b;return[e.getXForColumn(u),e.getYForRow(c),e.getXForColumn(g),e.getYForRow(d)]}_lookupCluster(e,t,r,a,h,l,n){const u=this._getClusterId(r,a,h),c=this._clusters.get(u),[g,d,p,_]=this._getClusterBounds(t,a,h),m={x:g,y:d},y={x:p,y:_};let b=0,v=0,C=0,x=0;if(this._spatialReference.isWebMercator){{const e=M(m.x/o.radius);b=e-360*Math.floor((e+180)/360),v=M(Math.PI/2-2*Math.atan(Math.exp(-1*m.y/o.radius)))}{const e=M(y.x/o.radius);C=e-360*Math.floor((e+180)/360),x=M(Math.PI/2-2*Math.atan(Math.exp(-1*y.y/o.radius)))}}else{const e=I(m,this._spatialReference,i.WGS84),t=I(y,this._spatialReference,i.WGS84);if(!e||!t)return null;b=e.x,v=e.y,C=t.x,x=t.y}const w={geohashX:0,geohashY:0},L={geohashX:0,geohashY:0};f(w,v,b,l),f(L,x,C,l);const j=w.geohashX,V=w.geohashY,F=L.geohashX,S=L.geohashY,D={xLL:j,yLL:V,xTR:F,yTR:S,level:l},T=n.getRegionStatistics(j,V,F,S,l),{count:k,xTotal:B,yTotal:G,referenceId:O}=T,U=k?B/k:0,A=k?G/k:0;if(0===k)return this._clusters.set(u,null),null;const E={cluster_count:k,...T.attributes},X=s(c)?c.update(U,A,r,E,D,O):R.create(e,u,U,A,r,E,D,O);return 0===k&&(X.geometry.coords[0]=(g+p)/2,X.geometry.coords[1]=(d+_)/2),this._clusters.set(u,X),this._updateAggregateValueRangeForCluster(X,X.tileLevel),X}_updateAggregateValueRangeForCluster(e,t){const s=this._aggregateValueRanges[t]||{minValue:1/0,maxValue:0},r=s.minValue,a=s.maxValue;s.minValue=Math.min(r,e.count),s.maxValue=Math.max(a,e.count),this._aggregateValueRanges[t]=s,r===s.minValue&&a===s.maxValue||(this._aggregateValueRangesChanged=!0)}_markTileClustersForDeletion(e,t){const s=2*t,r=Math.ceil(b/s),{row:a,col:i}=e.key,o=i*b,h=a*b,l=Math.floor(o/s),n=Math.floor(h/s);for(let t=l;t<l+r;t++)for(let s=n;s<n+r;s++)this._markForDeletion(e.key.level,t,s)}}export{R as ClusterInfo,C as ClusterStore};
