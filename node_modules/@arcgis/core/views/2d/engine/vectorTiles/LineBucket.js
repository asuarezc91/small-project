/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import"../../../../core/has.js";import{getLimitCosine as e}from"../webgl/mesh/templates/util.js";import{splitVertex as t,cleanup as r,tessellate as n}from"../webgl/TurboLine.js";import i from"./BaseBucket.js";const l=e=>t=>{t.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(t.currentVertex.x,t.currentVertex.y,t.prevNormal.x,t.prevNormal.y,0,-1,t.distance,e._ddValues),t.entry2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(t.currentVertex.x,t.currentVertex.y,-t.prevNormal.x,-t.prevNormal.y,0,1,t.distance,e._ddValues),t.exit0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(t.currentVertex.x,t.currentVertex.y,t.nextNormal.x,t.nextNormal.y,0,-1,t.distance,e._ddValues),t.exit2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(t.currentVertex.x,t.currentVertex.y,-t.nextNormal.x,-t.nextNormal.y,0,1,t.distance,e._ddValues)},s=e=>t=>{e._lineIndexBuffer.add(t.leftExit0,t.rightEntry0,t.leftExit2),e._lineIndexBuffer.add(t.rightEntry0,t.rightEntry2,t.leftExit2)},x=e=>r=>{const n=2===e._joinType?e._miterLimitCosine:e._roundLimitCosine,i=r.isCap&&0!==e._capType;let l=!1;r.cosine>.97?(r.exit0=r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.bisector.x/r.cosine,r.bisector.y/r.cosine,0,-1,r.distance,e._ddValues),r.exit2=r.entry2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.bisector.x/r.cosine,-r.bisector.y/r.cosine,0,1,r.distance,e._ddValues)):r.cosine<1-.97?(r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.prevNormal.x,r.prevNormal.y,0,-1,r.distance,e._ddValues),r.entry2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.prevNormal.x,-r.prevNormal.y,0,1,r.distance,e._ddValues),r.exit0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.nextNormal.x,r.nextNormal.y,0,-1,r.distance,e._ddValues),r.exit2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.nextNormal.x,-r.nextNormal.y,0,1,r.distance,e._ddValues)):r.canSplit?(t(),r.sign>0?(r.splitInner?(r.exit0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.leftInner.x,r.leftInner.y,0,-1,r.distance,e._ddValues),r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.rightInner.x,r.rightInner.y,0,-1,r.distance,e._ddValues)):(r.exit0=r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.bisector.x/r.cosine,r.bisector.y/r.cosine,0,-1,r.distance,e._ddValues)),r.cosine<n?(l=!r.isCap,r.entry2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.prevNormal.x,-r.prevNormal.y,0,1,r.distance,e._ddValues),r.exit2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.nextNormal.x,-r.nextNormal.y,0,1,r.distance,e._ddValues)):r.splitOuter?(l=l||r.gapOuter,r.entry2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.leftOuter.x,-r.leftOuter.y,0,1,r.distance,e._ddValues),r.exit2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.rightOuter.x,-r.rightOuter.y,0,1,r.distance,e._ddValues)):(r.entry2=r.exit2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.bisector.x/r.cosine,-r.bisector.y/r.cosine,0,1,r.distance,e._ddValues))):(r.splitInner?(r.exit2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.leftInner.x,-r.leftInner.y,0,1,r.distance,e._ddValues),r.entry2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.rightInner.x,-r.rightInner.y,0,1,r.distance,e._ddValues)):(r.exit2=r.entry2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.bisector.x/r.cosine,-r.bisector.y/r.cosine,0,1,r.distance,e._ddValues)),r.cosine<n?(l=!r.isCap,r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.prevNormal.x,r.prevNormal.y,0,-1,r.distance,e._ddValues),r.exit0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.nextNormal.x,r.nextNormal.y,0,-1,r.distance,e._ddValues)):r.splitOuter?(l=l||r.gapOuter,r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.leftOuter.x,r.leftOuter.y,0,-1,r.distance,e._ddValues),r.exit0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.rightOuter.x,r.rightOuter.y,0,-1,r.distance,e._ddValues)):(r.exit0=r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.bisector.x/r.cosine,r.bisector.y/r.cosine,0,-1,r.distance,e._ddValues)))):r.sign>0?(r.exit0=r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.bisector.x/r.cosine,r.bisector.y/r.cosine,0,-1,r.distance,e._ddValues),r.cosine<n?(l=!r.isCap,r.entry2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.prevNormal.x,-r.prevNormal.y,0,1,r.distance,e._ddValues),r.exit2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.nextNormal.x,-r.nextNormal.y,0,1,r.distance,e._ddValues)):(r.entry2=r.exit2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.bisector.x/r.cosine,-r.bisector.y/r.cosine,0,1,r.distance,e._ddValues))):(r.exit2=r.entry2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.bisector.x/r.cosine,-r.bisector.y/r.cosine,0,1,r.distance,e._ddValues),r.cosine<n?(l=!r.isCap,r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.prevNormal.x,r.prevNormal.y,0,-1,r.distance,e._ddValues),r.exit0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.nextNormal.x,r.nextNormal.y,0,-1,r.distance,e._ddValues)):(r.exit0=r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.bisector.x/r.cosine,r.bisector.y/r.cosine,0,-1,r.distance,e._ddValues)));let s;if(r.canSplit&&(r.splitInner||r.splitOuter)||l||i?(s=r.entry1=r.exit1=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,0,0,0,0,r.distance,e._ddValues)):s=r.entry1=r.exit1=null,l&&1!==e._joinType)e._lineIndexBuffer.add(s,r.sign>0?r.exit2:r.entry0,r.sign>0?r.entry2:r.exit0);else if(i&&1===e._capType||l&&1===e._joinType){let t,n,i,l,x,a;if(r.isCap){const e=Math.PI;x=Math.ceil(e/.8),a=e/x,r.isFirstVertex?(t=r.prevNormal.x,n=r.prevNormal.y,i=r.entry0,l=r.entry2):r.isLastVertex&&(t=-r.nextNormal.x,n=-r.nextNormal.y,i=r.exit2,l=r.exit0)}else{const e=2*Math.acos(r.cosine);x=Math.ceil(e/.8),a=e/x,t=r.sign>0?-r.prevNormal.x:r.nextNormal.x,n=r.sign>0?-r.prevNormal.y:r.nextNormal.y,i=r.sign>0?r.entry2:r.exit0,l=r.sign>0?r.exit2:r.entry0}const d=Math.cos(a),u=Math.sin(a),f=u*t+d*n;let o,c;t=d*t-u*n,n=f;for(let a=0;a<x;++a){if(o=c,a<x-1)if(r.isCap){const i=r.isFirstVertex?-1:1;c=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,t,n,i,0,r.distance,e._ddValues)}else c=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,t,n,0,r.sign,r.distance,e._ddValues);e._lineIndexBuffer.add(0===a?i:o,s,a===x-1?l:c);const f=u*t+d*n;t=d*t-u*n,n=f}}else if(i&&2===e._capType){const t=r.isFirstVertex?1:-1;let n,i;e._hasPattern?(n=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.prevNormal.x-t*r.inbound.x,r.prevNormal.y-t*r.inbound.y,-t,-1,r.distance,e._ddValues),i=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.prevNormal.x-t*r.inbound.x,-r.prevNormal.y-t*r.inbound.y,-t,1,r.distance,e._ddValues)):(n=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.prevNormal.x-t*r.inbound.x,r.prevNormal.y-t*r.inbound.y,0,-1,r.distance,e._ddValues),i=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.prevNormal.x-t*r.inbound.x,-r.prevNormal.y-t*r.inbound.y,0,1,r.distance,e._ddValues)),t>0?(e._lineIndexBuffer.add(s,r.entry2,i),e._lineIndexBuffer.add(s,i,n),e._lineIndexBuffer.add(s,n,r.entry0)):(e._lineIndexBuffer.add(s,i,r.exit2),e._lineIndexBuffer.add(s,n,i),e._lineIndexBuffer.add(s,r.exit0,n))}},a=e=>t=>{e._lineIndexBuffer.add(t.leftExit0,t.rightEntry0,null!=t.leftExit1?t.leftExit1:t.leftExit2),e._lineIndexBuffer.add(t.rightEntry0,null!=t.rightEntry1?t.rightEntry1:t.rightEntry2,null!=t.leftExit1?t.leftExit1:t.leftExit2),null!=t.leftExit1&&null!=t.rightEntry1?(e._lineIndexBuffer.add(t.leftExit1,t.rightEntry1,t.leftExit2),e._lineIndexBuffer.add(t.rightEntry1,t.rightEntry2,t.leftExit2)):null!=t.leftExit1?e._lineIndexBuffer.add(t.leftExit1,t.rightEntry2,t.leftExit2):null!=t.rightEntry1&&e._lineIndexBuffer.add(t.rightEntry1,t.rightEntry2,t.leftExit2)};export default class extends i{constructor(e,t,r,n){if(super(e,t),this.type=2,this._tessellationOptions={},this.tessellationProperties={_lineVertexBuffer:null,_lineIndexBuffer:null,_hasPattern:null,_ddValues:null,_capType:null,_joinType:null,_miterLimitCosine:null,_roundLimitCosine:null},e.hasDataDrivenLine!==r.isDataDriven())throw new Error("incompatible line buffer");this.tessellationProperties._lineVertexBuffer=r,this.tessellationProperties._lineIndexBuffer=n,this.tessellationProperties._hasPattern=e.getPaintValue("line-pattern",this.zoom)||e.getPaintValue("line-dasharray",this.zoom).length>0,this._isThinLine=e.isThinLine,this._isThinLine?this._tessellationCallbacks={vertex:l(this.tessellationProperties),bridge:s(this.tessellationProperties)}:this._tessellationCallbacks={vertex:x(this.tessellationProperties),bridge:a(this.tessellationProperties)}}get lineIndexStart(){return this._lineIndexStart}get lineIndexCount(){return this._lineIndexCount}processFeatures(t){this._lineIndexStart=3*this.tessellationProperties._lineIndexBuffer.index,this._lineIndexCount=0;const n=this.layer,i=this.zoom,l=n.hasDataDrivenLine;t&&t.setExtent(this.layerExtent);let s=[1,1,1,1],x=1,a=1;for(const r of this._features){let d;if(!this.tessellationProperties._hasPattern&&n.hasDataDrivenColor&&(s=n.getPaintValue("line-color",i,r)),n.hasDataDrivenOpacity&&(x=n.getPaintValue("line-opacity",i,r)),n.hasDataDrivenWidth&&(a=n.getPaintValue("line-width",i,r)),l&&(d={color:s,opacity:x,size:Math.max(Math.min(a,256),0)},d.size<=0||d.opacity<=0||d.color[3]<=0))continue;this.tessellationProperties._capType=n.getLayoutValue("line-cap",i,r),this.tessellationProperties._joinType=n.getLayoutValue("line-join",i,r),this.tessellationProperties._miterLimitCosine=e(n.getLayoutValue("line-miter-limit",i,r)),this.tessellationProperties._roundLimitCosine=e(n.getLayoutValue("line-round-limit",i,r));const u=r.getGeometry(t);this._processFeature(u,d)}r()}serialize(){let e=7;e+=this.layerUIDs.length,e+=this.tessellationProperties._lineVertexBuffer.array.length,e+=this.tessellationProperties._lineIndexBuffer.array.length;let t=0;const r=new Uint32Array(e),n=new Int32Array(r.buffer);r[t++]=this.type,r[t++]=this.layerUIDs.length;for(let e=0;e<this.layerUIDs.length;e++)r[t++]=this.layerUIDs[e];r[t++]=this._lineIndexStart,r[t++]=this._lineIndexCount,r[t++]=this.tessellationProperties._lineVertexBuffer.isDataDriven()?1:0,r[t++]=this.tessellationProperties._lineVertexBuffer.array.length;for(let e=0;e<this.tessellationProperties._lineVertexBuffer.array.length;e++)n[t++]=this.tessellationProperties._lineVertexBuffer.array[e];r[t++]=this.tessellationProperties._lineIndexBuffer.array.length;for(let e=0;e<this.tessellationProperties._lineIndexBuffer.array.length;e++)r[t++]=this.tessellationProperties._lineIndexBuffer.array[e];return r.buffer}_processFeature(e,t){if(!e)return;const r=e.length;for(let n=0;n<r;n++)this._processGeometry(e[n],t)}_processGeometry(e,t){if(e.length<2)return;let r,i,l=e[0],s=1;for(;s<e.length;)r=e[s].x-l.x,i=e[s].y-l.y,r*r+i*i<1e-6?e.splice(s,1):(l=e[s],++s);if(e.length<2)return;const x=3*this.tessellationProperties._lineIndexBuffer.index;this._tessellationOptions.trackDistance=this.tessellationProperties._hasPattern,this._tessellationOptions.initialDistance=0,this._tessellationOptions.thin=this._isThinLine,this._tessellationOptions.wrapDistance=65535,this._tessellationOptions.outerBisectorAutoSplitThreshold=.2631578947368421,this._tessellationOptions.enableOuterBisectorSplit=this.tessellationProperties._hasPattern,this._tessellationOptions.innerBisectorAutoSplitThreshold=.2631578947368421,this._tessellationOptions.enableInnerBisectorSplit=this.tessellationProperties._hasPattern,this.tessellationProperties._ddValues=t,n(e,this._tessellationOptions,this._tessellationCallbacks),this._lineIndexCount+=3*this.tessellationProperties._lineIndexBuffer.index-x}}
