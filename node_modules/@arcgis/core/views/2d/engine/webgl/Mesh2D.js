/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{isSome as e}from"../../../../core/maybe.js";import t from"../../../../core/Logger.js";import r from"../../../../core/Error.js";import o from"../../../../layers/graphics/OptimizedGeometry.js";import{convertFromNestedArray as n,convertFromPolygon as s}from"../../../../layers/graphics/featureConversionUtils.js";import{a as c}from"../../../../chunks/vec2f64.js";import{earcut as i}from"../../../../core/libs/earcut/earcut.js";import{s as a}from"../../../../chunks/vec2.js";import f from"../../../webgl/BufferObject.js";import{i1616to32 as h}from"./number.js";const m=t.getLogger("esri.views.2d.engine.webgl.Mesh2D"),u=(e,t,r,o)=>{let n=0;for(let o=1;o<r;o++){const r=e[2*(t+o-1)],s=e[2*(t+o-1)+1];n+=(e[2*(t+o)]-r)*(e[2*(t+o)+1]+s)}return o?n>0:n<0},y=({coords:e,lengths:t},r)=>{const o=[];for(let n=0,s=0;n<t.length;s+=t[n],n+=1){const c=s,a=[];for(;n<t.length-1&&u(e,s+t[n],t[n+1],r);n+=1,s+=t[n])a.push(s+t[n]-c);const f=e.slice(2*c,2*(s+t[n])),h=i(f,a,2);for(const e of h)o.push(e+c)}return o};class x{constructor(e,t,r,o=!1){this._cache={},this.vertices=e,this.indices=t,this.primitiveType=r,this.isMapSpace=o}static fromRect({x:e,y:t,width:r,height:o}){const n=e,s=t,c=n+r,i=s+o;return x.fromScreenExtent({xmin:n,ymin:s,xmax:c,ymax:i})}static fromPath(e){const t=n(new o,e.path,!1,!1),r=t.coords,s=new Uint32Array(y(t,!0)),c=new Uint32Array(r.length/2);for(let e=0;e<c.length;e++)c[e]=h(Math.floor(r[2*e]),Math.floor(r[2*e+1]));return new x({geometry:c},s,4)}static fromGeometry(e,t){const o=t.geometry.type;switch(o){case"polygon":return x.fromPolygon(e,t.geometry);case"extent":return x.fromMapExtent(e,t.geometry);default:return m.error(new r("mapview-bad-type",`Unable to create a mesh from type ${o}`,t)),x.fromRect({x:0,y:0,width:1,height:1})}}static fromPolygon(e,t){const r=s(new o,t,!1,!1),n=r.coords,i=new Uint32Array(y(r,!1)),f=new Uint32Array(n.length/2),m=c(),u=c();for(let t=0;t<f.length;t++)a(m,n[2*t],n[2*t+1]),e.toScreen(u,m),f[t]=h(Math.floor(u[0]),Math.floor(u[1]));return new x({geometry:f},i,4,!0)}static fromScreenExtent({xmin:e,xmax:t,ymin:r,ymax:o}){const n={geometry:new Uint32Array([h(e,r),h(t,r),h(e,o),h(e,o),h(t,r),h(t,o)])},s=new Uint32Array([0,1,2,3,4,5]);return new x(n,s,4)}static fromMapExtent(e,t){const[r,o]=e.toScreen([0,0],[t.xmin,t.ymin]),[n,s]=e.toScreen([0,0],[t.xmax,t.ymax]),c={geometry:new Uint32Array([h(r,o),h(n,o),h(r,s),h(r,s),h(n,o),h(n,s)])},i=new Uint32Array([0,1,2,3,4,5]);return new x(c,i,4)}destroy(){e(this._cache.indexBuffer)&&this._cache.indexBuffer.dispose();for(const t in this._cache.vertexBuffers)e(this._cache.vertexBuffers[t])&&this._cache.vertexBuffers[t].dispose()}get elementType(){return(e=>{switch(e.BYTES_PER_ELEMENT){case 1:return 5121;case 2:return 5123;case 4:return 5125;default:throw new r("Cannot get DataType of array")}})(this.indices)}getIndexBuffer(e,t=35044){return this._cache.indexBuffer||(this._cache.indexBuffer=f.createIndex(e,t,this.indices)),this._cache.indexBuffer}getVertexBuffers(e,t=35044){return this._cache.vertexBuffers||(this._cache.vertexBuffers=Object.keys(this.vertices).reduce(((r,o)=>({...r,[o]:f.createVertex(e,t,this.vertices[o])})),{})),this._cache.vertexBuffers}}export default x;
