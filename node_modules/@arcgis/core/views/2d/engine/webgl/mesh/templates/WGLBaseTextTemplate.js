/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{andThen as t,isSome as e,isNone as i,unwrap as s}from"../../../../../../core/maybe.js";import{pt2px as r}from"../../../../../../core/screenUtils.js";import{deltaDecodeGeometry as o,convertFromGeometry as n}from"../../../../../../layers/graphics/featureConversionUtils.js";import{MAGIC_LABEL_LINE_HEIGHT as h}from"../../definitions.js";import{i8888to32 as a,i1616to32 as l}from"../../number.js";import{shapeGlyphs as m}from"./shapingUtils.js";import{WGLGeometryType as p}from"../../enums.js";import{MaterialKeyBase as c}from"../../materialKey/MaterialKey.js";import{CIMMarkerPlacementHelper as u}from"../../../../../../symbols/cim/placements/CIMMarkerPlacementHelper.js";export default f=>class extends f{constructor(...t){super(...t),this._isCIM=!1,this.geometryType=p.TEXT,this._aux=a(0,0,this._referenceSize,this._bitset)}bindTextInfo(e,i){e&&e.length?this._shapingInfo=t(e,(t=>m(t,i,{scale:this._scale,angle:this._angle,xOffset:this._xOffset,yOffset:this._yOffset,hAlign:this._xAlignD,vAlign:this._yAlignD,maxLineWidth:Math.max(32,Math.min(this._lineWidth,512)),lineHeight:h*Math.max(.25,Math.min(this._lineHeight,4)),decoration:this._decoration,isCIM:this._isCIM}))):this._shapingInfo=null}writeMeshWithGeometry(t,i,s,r,h,a){if(e(this._textPlacement)){const e=null!=a?a:s.readLegacyGeometry();return this._writePlacedText(t,i,h,e)}const l=a?o(n(a),2):"esriGeometryPolygon"===r?s.readCentroid():s.readUnquantizedGeometry();if(l){if(l.isPoint){const[e,s]=l.coords;return this._writeGlyphs(t,i,h,{x:e,y:s})}l.forEachVertex(((e,s)=>this._writeGlyphs(t,i,h,{x:e,y:s})))}}_writePlacedText(t,e,o,n){const h=this._shapingInfo;if(i(h))return;const a=c.load(this._materialKey),m=s(this._textPlacement),p=u.getPlacement(n,m,r(1));if(!p)return;let f,_,g=p.next();for(;null!=g;){_=l(Math.round(8*g.tx),Math.round(8*g.ty)),f=g.getAngle(),h.setRotation(f);for(const i of h.glyphs){a.textureBinding=i.textureBinding;const s=e.getVector("geometry").vertexCount,r=e.indexVector.length,n=this._writeIndices(e),h=this._writeVertex(e,o,_,i);t.writeDisplayRecord(this.geometryType,a.data,s,h,r,n)}h.setRotation(-f),g=p.next()}}_writeGlyphs(t,e,s,r){const o=this._shapingInfo;if(i(o))return;const n=c.load(this._materialKey),h=l(Math.round(8*r.x),Math.round(8*r.y));for(const i of o.glyphs){n.textureBinding=i.textureBinding;const r=e.getVector("geometry").vertexCount,o=e.indexVector.length,a=this._writeIndices(e),l=this._writeVertex(e,s,h,i);t.writeDisplayRecord(this.geometryType,n.data,r,l,o,a)}}_writeVertexCommon(t,e,i,s){const r=this._color,o=this._haloColor,n=a(0,0,this._referenceSize,this._bitset),h=a(0,0,this._size,this._haloSize);t.push(i),t.push(e),t.push(r),t.push(o),t.push(h),t.push(n)}_writeVertex(t,e,i,s){const r=t.get("geometry");return this._writeVertexCommon(r,e,i,s),r.push(s.offsets.upperLeft),r.push(s.texcoords.upperLeft),this._writeVertexCommon(r,e,i,s),r.push(s.offsets.upperRight),r.push(s.texcoords.upperRight),this._writeVertexCommon(r,e,i,s),r.push(s.offsets.lowerLeft),r.push(s.texcoords.lowerLeft),this._writeVertexCommon(r,e,i,s),r.push(s.offsets.lowerRight),r.push(s.texcoords.lowerRight),4}_writeIndices(t){const e=t.getVector("geometry").vertexCount,i=t.indexVector;return i.push(e+0),i.push(e+1),i.push(e+2),i.push(e+1),i.push(e+3),i.push(e+2),6}};
