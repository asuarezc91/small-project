/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{s as t,t as s}from"../../../../../../chunks/vec2.js";import{i as e,r as i,m as o,b as h,t as n}from"../../../../../../chunks/mat2d.js";import{c as r,t as a}from"../../../../../../chunks/mat2df32.js";import{c}from"../../../../../../chunks/vec2f32.js";import{VAlign as d}from"../../alignmentUtils.js";import{i1616to32 as f}from"../../number.js";import l from"../../Rect.js";import m from"../../collisions/BoundingBox.js";const g=Math.PI/180;class u{constructor(t,s,e,i){this._rotationT=r(),this._xBounds=0,this._yBounds=0,this.minZoom=0,this.maxZoom=255;const o=e.rect,h=new Float32Array(8);t*=i,s*=i;const n=e.code?o.width*i:e.metrics.width,a=e.code?o.height*i:e.metrics.height;h[0]=t,h[1]=s,h[2]=t+n,h[3]=s,h[4]=t,h[5]=s+a,h[6]=t+n,h[7]=s+a,this._data=h,this._setTextureCoords(o),this._scale=i,this._mosaic=e,this.x=t,this.y=s}get width(){return this._mosaic.metrics.width*this._scale}get mosaic(){return this._mosaic}set angle(t){this._angle=t,e(this._rotationT),i(this._rotationT,this._rotationT,-t),this._setOffsets(this._data)}get angle(){return this._angle}get xTopLeft(){return this._data[0]}get yTopLeft(){return this._data[1]}get xBottomRight(){return this._data[6]}get yBottomRight(){return this._data[7]}get texcoords(){return this._texcoords}get textureBinding(){return this._mosaic.textureBinding}get offsets(){return this._offsets||this._setOffsets(this._data),this._offsets}get char(){return String.fromCharCode(this._mosaic.code)}get code(){return this._mosaic.code}get bounds(){const{height:t,width:s}=this._mosaic.metrics,e=s*this._scale,i=Math.abs(t)*this._scale,h=new Float32Array(8);h[0]=this.x,h[1]=this.y,h[2]=this.x+e,h[3]=this.y,h[4]=this.x,h[5]=this.y+i,h[6]=this.x+e,h[7]=this.y+i;const n=o(r(),this._rotationT,this._T);a(h,h,n);let c=1/0,d=1/0,f=0,l=0;for(let t=0;t<4;t++){const s=h[2*t],e=h[2*t+1];c=Math.min(c,s),d=Math.min(d,e),f=Math.max(f,s),l=Math.max(l,e)}const g=f-c,u=l-d;return new m(c+g/2,d+u/2,g,u)}setTransform(t){this._T=t,this._offsets=null}_setOffsets(t){this._offsets||(this._offsets={upperLeft:0,upperRight:0,lowerLeft:0,lowerRight:0});const s=this._offsets,e=new Float32Array(8),i=o(r(),this._rotationT,this._T);a(e,t,i),s.upperLeft=f(8*e[0],8*e[1]),s.upperRight=f(8*e[2],8*e[3]),s.lowerLeft=f(8*e[4],8*e[5]),s.lowerRight=f(8*e[6],8*e[7])}_setTextureCoords({x:t,y:s,width:e,height:i}){this._texcoords={upperLeft:f(t,s),upperRight:f(t+e,s),lowerLeft:f(t,s+i),lowerRight:f(t+e,s+i)}}}const _=(t,s)=>({code:0,page:0,sdf:!0,rect:new l(0,0,11,8),textureBinding:s,metrics:{advance:0,height:4,width:t,left:0,top:0}});class p{constructor(t,s,e){this._rotation=0,this._decorate(t,s,e),this.glyphs=t,this.bounds=this._createBounds(t),this.isMultiline=s.length>1,this._hasRotation=0!==e.angle,this._T=this._createGlyphTransform(this.bounds,e);for(const s of t)s.setTransform(this._T)}setRotation(t){if(0===t&&0===this._rotation)return;this._rotation=t;const s=this._T,e=h(r(),t);o(s,e,s);for(const t of this.glyphs)t.setTransform(this._T)}_decorate(t,s,e){if(!e.decoration||"none"===e.decoration||!t.length)return;const i=e.scale,o="underline"===e.decoration?30:20,h=t[0].textureBinding;for(const e of s){const s=e.startX*i,n=e.startY*i,r=(e.width+e.glyphWidthEnd)*i;t.push(new u(s,n+o*i,_(r,h),1))}}get boundsT(){const e=this.bounds,i=t(c(),e.x,e.y);if(s(i,i,this._T),this._hasRotation){const t=Math.max(e.width,e.height);return new m(i[0],i[1],t,t)}return new m(i[0],i[1],e.width,e.height)}_createBounds(t){let s=1/0,e=1/0,i=0,o=0;for(const h of t)s=Math.min(s,h.xTopLeft),e=Math.min(e,h.yTopLeft),i=Math.max(i,h.xTopLeft+h.width),o=Math.max(o,h.yBottomRight);const h=i-s,n=o-e;return new m(s+h/2,e+n/2,h,n)}_createGlyphTransform(s,e){const o=g*e.angle,h=r(),a=c();return n(h,h,t(a,e.xOffset,-e.yOffset)),e.isCIM?i(h,h,o):(n(h,h,t(a,s.x,s.y)),i(h,h,o),n(h,h,t(a,-s.x,-s.y))),h}}class x{constructor(t,s,e,i,o,h){this.glyphWidthEnd=0,this.startX=0,this.startY=0,this.start=Math.max(0,Math.min(s,e)),this.end=Math.max(0,Math.max(s,e)),this.end<t.length&&(this.glyphWidthEnd=t[this.end].metrics.width),this.width=i,this.yMin=o,this.yMax=h}}const w=t=>10===t,y=t=>32===t;function T(t,s,e){const i=e.scale,o=new Array,h=function(t,s,e){const i=new Array,o=1/e.scale,h=e.maxLineWidth*o,n=s?t.length-1:0,r=s?-1:t.length,a=s?-1:1;let c=n,d=0,f=0,l=c,m=l,g=0,u=1/0,_=0;for(;c!==r;){const{code:s,metrics:e}=t[c],o=Math.abs(e.top);if(w(s)||y(s)||(u=Math.min(u,o),_=Math.max(_,o+e.height)),w(s))c!==n&&(i.push(new x(t,l,c-a,d,u,_)),u=1/0,_=0),d=0,l=c+a,m=c+a,f=0;else if(y(s))m=c+a,f=0,g=e.advance,d+=e.advance;else if(d>h){if(m!==l){const s=m-2*a;d-=g,i.push(new x(t,l,s,d-f,u,_)),u=1/0,_=0,l=m,d=f}else i.push(new x(t,l,c-a,d,u,_)),u=1/0,_=0,l=c,m=c,d=0;d+=e.advance,f+=e.advance}else d+=e.advance,f+=e.advance;c+=a}const p=new x(t,l,c-a,d,u,_);return p.start>=0&&p.end<t.length&&i.push(p),i}(t,s,e),n=function(t,s){let e=0;for(let s=0;s<t.length;s++){const{width:i}=t[s];e=Math.max(i,e)}const i="underline"===s.decoration?4:0,o=t[0].yMin;return{x:0,y:o,height:t[t.length-1].yMax+s.lineHeight*(t.length-1)+i-o,width:e}}(h,e),{vAlign:r,hAlign:a}=e,c=r===d.Baseline?1:0,f=c?0:r-1,l=(1-c)*-n.y+f*(n.height/2)+-26*(c?1:0);for(let s=0;s<h.length;s++){const{start:n,end:r,width:c}=h[s];let d=-1*(a+1)*(c/2)-3;const f=s*e.lineHeight+l-3;h[s].startX=d,h[s].startY=f;for(let s=n;s<=r;s++){const e=t[s];if(w(e.code))continue;const h=new u(d+e.metrics.left,f-e.metrics.top,e,i);d+=e.metrics.advance,o.push(h)}}return new p(o,h,e)}export{u as ShapedGlyph,p as ShapingInfo,T as shapeGlyphs};
