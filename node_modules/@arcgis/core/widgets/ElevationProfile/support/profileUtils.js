/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{isSome as e}from"../../../core/maybe.js";import{splitIntoChunks as t}from"../../../core/arrayUtils.js";import{throwIfAborted as s,after as r,isAbortError as i}from"../../../core/promiseUtils.js";import n from"../../../geometry/Multipoint.js";import{getMetersPerUnitForSR as o}from"../../../core/unitUtils.js";import{Task as a}from"../../../views/support/Scheduler.js";import{inverseGeodeticSolver as l}from"../../../geometry/support/geodesicUtils.js";import{QueueProcessor as c}from"../../../views/support/QueueProcessor.js";import{isPolyline as p,isValidInputPath as u,densifyPath as m}from"./geometryUtils.js";import{DELAY_AFTER_PREVIEW_MILLIS as f,DEFAULT_ELEVATION_PROFILE_QUERY_OPTIONS as h}from"./constants.js";import{getStatistics as d}from"./statisticsUtils.js";import{getIndices as g}from"./traversal.js";async function*y(e){const i={signal:e.signal},n=e.path;if(!p(n)||!u(n))return null;const o=e.view.spatialReference,a=await m(n,o,e.options,i),l={...e,path:n,densificationResult:a,result:v(a)},c=g(0,a.densifiedPath.paths[0].length),h=c.slice(0,l.provider.numSamplesForPreview);yield await w(l,h,!0),s(i),await r(f),s(i);const d=t(c,l.provider.numSamplesPerChunk);for(const e of d)yield await w(l,e,!1),s(i);l.result.progress=1,yield l.result}async function w({densificationResult:e,result:t,provider:s,queue:r,signal:i,cache:o},a,l){const{densifiedPath:c,pathLength:p}=e,u=c.paths[0],m=a.map((e=>u[e])),f=l?Math.round(p/s.numSamplesForPreview):Math.round(p/u.length);await r.push({geometry:new n({spatialReference:c.spatialReference,points:m,hasZ:c.hasZ}),provider:s,indices:a,result:t,queryOptions:{...h,minDemResolution:f,cache:o}},{signal:i});const g=t.samples.filter((e=>e.processed));return t.progress=l?0:t.progress+a.length/u.length,t.statistics=d(t.samples,t.spatialReference),{...t,samples:g}}function j(e){return new c({task:a.ELEVATION_PROFILE,concurrency:1,scheduler:e,process:async e=>{s(e.queryOptions);try{await async function({geometry:e,provider:t,indices:s,result:r,queryOptions:i}){if(0===s.length)return null;const n=(await t.queryElevation(e,i)).geometry,o=i.noDataValue,a=r.samples;for(let e=0;e<s.length;e++){const t=a[s[e]],{hasZ:r,z:i}=n.getPoint(e);t.z=r&&i!==o?i:null,t.processed=!0}}(e)}catch(e){if(i(e))return}}})}function v(t){const s=t.densifiedPath,r=s.spatialReference,i=t.densifiedPathInMeasurementSR;let n=s.paths[0];const a=n.length;let c=0;const p=new Array(a);if(p[0]=R(n[0],c),e(i)){const e=n;n=i.paths[0];const t=o(r),s={distance:0},u=i.spatialReference;for(let r=1;r<a;r++)l(s,n[r-1],n[r],u),c+=s.distance/t,p[r]=R(e[r],c)}else for(let e=1;e<a;e++){const t=n[e],s=n[e-1],r=t[0]-s[0],i=t[1]-s[1];c+=Math.sqrt(r*r+i*i),p[e]=R(t,c)}return{progress:0,samples:p,statistics:null,spatialReference:r}}function R([e,t],s){return{x:e,y:t,z:null,distance:s,processed:!1}}export{j as createProfileQueue,y as generateProfile};
