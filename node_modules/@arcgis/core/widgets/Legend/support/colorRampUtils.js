/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{all as l}from"../../../core/promiseUtils.js";import e from"../../../Color.js";import{getUnivariateAboveAndBelowStopValues as o,createStopLabel as n}from"./utils.js";const r=new e([64,64,64]);function t(l,e){const o=[],r=l.length-1;return 5===l.length?o.push(0,2,4):o.push(0,r),l.map(((l,t)=>o.indexOf(t)>-1?n(l,t,r,e):null))}async function a(n,a,u,i){let s=!1,c=[],p=[];if(n.stops){const l=null==i?void 0:i.authoringInfo,e="univariate-color-size"===(null==l?void 0:l.type)&&"above-and-below"===(null==l?void 0:l.univariateTheme),r=n.stops;c=e&&"color"===n.type?o(n,l):r.map((l=>l.value)),s=r.some((l=>!!l.label)),s&&(p=r.map((l=>l.label)))}const m=c[0],v=c[c.length-1];if(null==m&&null==v)return null;const f=s?null:t(c,u);return(await l(c.map((async(l,o)=>({value:l,color:"opacity"===n.type?await async function(l,o,n=r){const t=new e(n),a=(await import("../../../renderers/visualVariables/support/visualVariableUtils.js")).getOpacity(o,l);null!=a&&(t.a=a);return t}(l,n,a):(await import("../../../renderers/visualVariables/support/visualVariableUtils.js")).getColor(n,l),label:s?p[o]:f[o]}))))).reverse()}function u(l){let e=!1,o=[],n=[];o=l.map((l=>l.value)),e=l.some((l=>!!l.label)),e&&(n=l.map((l=>l.label)));const r=o[0],a=o[o.length-1];if(null==r&&null==a)return null;const u=e?null:t(o,!1);return o.map(((o,r)=>({value:o,color:i(o,l),label:e?n[r]:u[r]}))).reverse()}function i(l,o){const{startIndex:n,endIndex:r,weight:t}=function(l,e){let o=0,n=e.length-1;return e.some(((e,r)=>l<e.value?(n=r,!0):(o=r,!1))),{startIndex:o,endIndex:n,weight:(l-e[o].value)/(e[n].value-e[o].value)}}(l,o);if(n===r)return o[n].color;const a=e.blendColors(o[n].color,o[r].color,t);return new e(a)}function s(l,o){let n=[];if(l&&"multipart"===l.type)l.colorRamps.reverse().forEach((function(r,t){0===t?n.push({value:o.max,color:new e(r.toColor),label:"high"}):n.push({value:null,color:new e(r.toColor),label:""}),t===l.colorRamps.length-1?n.push({value:o.min,color:new e(r.fromColor),label:"low"}):n.push({value:null,color:new e(r.fromColor),label:""})}));else{let r,t;l&&"algorithmic"===l.type?(r=l.fromColor,t=l.toColor):(r=[0,0,0,1],t=[255,255,255,1]),n=[{value:o.max,color:new e(t),label:"high"},{value:o.min,color:new e(r),label:"low"}]}return n}export{i as getColorFromPointCloudStops,a as getRampStops,u as getRampStopsForPointCloud,s as getStrectchRampStops};
