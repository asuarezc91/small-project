/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{_ as t}from"../chunks/tslib.es6.js";import"../core/has.js";import{clone as e}from"../core/lang.js";import"../core/Logger.js";import"../core/accessorSupport/ensureType.js";import{property as s}from"../core/accessorSupport/decorators/property.js";import{subclass as r}from"../core/accessorSupport/decorators/subclass.js";import{writer as i}from"../core/accessorSupport/decorators/writer.js";import"../core/urlUtils.js";import"../core/uuid.js";import"../portal/support/resourceExtension.js";import o from"./Geometry.js";import n from"./Point.js";import a from"./Extent.js";import{updateSupportFromPoint as p}from"./support/zmUtils.js";var l;function h(t){return(e,s)=>null==e?s:null==s?e:t(e,s)}let c=l=class extends o{constructor(...t){super(...t),this.points=[],this.type="multipoint"}normalizeCtorArgs(t,e){if(!t&&!e)return null;const s={};var r;Array.isArray(t)?(s.points=t,s.spatialReference=e):!(r=t)||"esri.geometry.SpatialReference"!==r.declaredClass&&null==r.wkid?(t.points&&(s.points=t.points),t.spatialReference&&(s.spatialReference=t.spatialReference),t.hasZ&&(s.hasZ=t.hasZ),t.hasM&&(s.hasM=t.hasM)):s.spatialReference=t;const i=s.points&&s.points[0];return i&&(void 0===s.hasZ&&void 0===s.hasM?(s.hasZ=i.length>2,s.hasM=!1):void 0===s.hasZ?s.hasZ=i.length>3:void 0===s.hasM&&(s.hasM=i.length>3)),s}get extent(){const t=this.points;if(!t.length)return null;const e=new a,s=this.hasZ,r=this.hasM,i=s?3:2,o=t[0],n=h(Math.min),p=h(Math.max);let l,c,u,m,[f,d]=o,[y,g]=o;for(let e=0,o=t.length;e<o;e++){const o=t[e],[a,h]=o;if(f=n(f,a),d=n(d,h),y=p(y,a),g=p(g,h),s&&o.length>2){const t=o[2];l=n(l,t),u=p(u,t)}if(r&&o.length>i){const t=o[i];c=n(c,t),m=p(m,t)}}return e.xmin=f,e.ymin=d,e.xmax=y,e.ymax=g,e.spatialReference=this.spatialReference,s?(e.zmin=l,e.zmax=u):(e.zmin=null,e.zmax=null),r?(e.mmin=c,e.mmax=m):(e.mmin=null,e.mmax=null),e}writePoints(t,s){s.points=e(this.points)}addPoint(t){return this.clearCache(),p(this,t),Array.isArray(t)?this.points.push(t):this.points.push(t.toArray()),this}clone(){const t={points:e(this.points),spatialReference:this.spatialReference};return this.hasZ&&(t.hasZ=!0),this.hasM&&(t.hasM=!0),new l(t)}getPoint(t){if(!this._validateInputs(t))return null;const e=this.points[t],s={x:e[0],y:e[1],spatialReference:this.spatialReference};let r=2;return this.hasZ&&(s.z=e[2],r=3),this.hasM&&(s.m=e[r]),new n(s)}removePoint(t){return this._validateInputs(t)?(this.clearCache(),new n(this.points.splice(t,1)[0],this.spatialReference)):null}setPoint(t,e){return this._validateInputs(t)?(this.clearCache(),p(this,e),Array.isArray(e)||(e=e.toArray()),this.points[t]=e,this):this}toJSON(t){return this.write(null,t)}_validateInputs(t){return null!=t&&t>=0&&t<this.points.length}};t([s({dependsOn:["points","hasZ","hasM","spatialReference"],autoTracked:!1})],c.prototype,"cache",void 0),t([s({dependsOn:["cache"],autoTracked:!1})],c.prototype,"extent",null),t([s({type:[[Number]],json:{write:{isRequired:!0}}})],c.prototype,"points",void 0),t([i("points")],c.prototype,"writePoints",null),c=l=t([r("esri.geometry.Multipoint")],c),c.prototype.toJSON.isDefaultToJSON=!0;var u=c;export default u;
