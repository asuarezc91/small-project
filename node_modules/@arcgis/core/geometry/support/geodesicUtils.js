/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import e from"../../core/Error.js";import t from"../SpatialReference.js";import n from"../Point.js";import s from"../Polygon.js";import i from"../Polyline.js";import"../../geometry.js";import{convertUnit as a}from"../../core/unitUtils.js";import{toRadians as r,spheroids as o,WKT_SPHEROID_REGEX as c}from"./geodesicConstants.js";function l(e){if(!e)return null;if(e.isGeographic&&e.wkid){const t=o[e.wkid];if(t)return t}if(e.wkt){const t=c.exec(e.wkt);if(!t||2!==t.length)return null;const n=t[1].split(",");if(!n||n.length<3)return null;const s=parseFloat(n[1]),i=parseFloat(n[2]);if(isNaN(s)||isNaN(i))return null;return{a:s,f:0===i?0:1/i}}return null}function h(e){const n=l(e||t.WGS84);if(function(e){return"b"in e&&"eSq"in e&&"radius"in e}(n))return n;const s=n.a*(1-n.f);return Object.assign(n,{b:s,eSq:1-(s/n.a)**2,radius:(2*n.a+s)/3,densificationRatio:1e4/((2*n.a+s)/3)})}function p(e,t,n){const{a:s,eSq:i}=h(n),a=Math.sqrt(i),o=Math.sin(t[1]*r),c=s*t[0]*r;let l;if(i>0){l=s*((1-i)*(o/(1-i*(o*o))-1/(2*a)*Math.log((1-a*o)/(1+a*o))))*.5}else l=s*o;return e[0]=c,e[1]=l,e}function f(e){return null!==l(e)}function u(t,n="square-meters"){if(t.some((e=>!f(e.spatialReference))))throw new e("geodesic-areas:invalid-spatial-reference","the input geometries spatial reference is not supported");const s=[];for(let e=0;e<t.length;e++){const n=t[e],i=n.spatialReference,{radius:a,densificationRatio:r}=h(i),o=a*r;s.push(m(n,o))}const i=[],r=[0,0],o=[0,0];for(let e=0;e<s.length;e++){const{rings:t,spatialReference:c}=s[e];let l=0;for(let e=0;e<t.length;e++){const n=t[e];p(r,n[0],c),p(o,n[n.length-1],c);let s=o[0]*r[1]-r[0]*o[1];for(let e=0;e<n.length-1;e++)p(r,n[e+1],c),p(o,n[e],c),s+=o[0]*r[1]-r[0]*o[1];l+=s}l=a(l,"square-meters",n),i.push(l/-2)}return i}function d(t,n="meters"){const s=t,i=t;if(!s&&!i)throw new e("geodesic-lengths:invalid-geometries","the input geometries type is not supported");if(s?s.some((e=>!f(e.spatialReference))):i.some((e=>!f(e.spatialReference))))throw new e("geodesic-lengths:invalid-spatial-reference","the input geometries spatial reference is not supported");const r=[];for(let e=0;e<t.length;e++){const s=t[e],{spatialReference:i}=s,o="polyline"===s.type?s.paths:s.rings;let c=0;for(let e=0;e<o.length;e++){const t=o[e];let n=0;for(let e=1;e<t.length;e++){const s=t[e-1][0],a=t[e][0],r=t[e-1][1],o=t[e][1];if(r!==o||s!==a){const e={distance:null};M(e,[s,r],[a,o],i),n+=e.distance}}c+=n}c=a(c,"meters",n),r.push(c)}return r}function m(t,n){if("polyline"!==t.type&&"polygon"!==t.type)throw new e("geodesic-densify:invalid-geometry","the input geometry is neither polyline nor polygon");const{spatialReference:a}=t;if(!f(a))throw new e("geodesic-densify:invalid-spatial-reference","the input geometry spatial reference is not supported");const{radius:r}=h(a),o=r/1e4;n<o&&(n=o);const c="polyline"===t.type?t.paths:t.rings,l=[],p=[0,0],u={distance:null};for(const e of c){const t=[];l.push(t),t.push([e[0][0],e[0][1]]);let s,i,r=e[0][0],o=e[0][1];for(let c=0;c<e.length-1;c++){if(s=e[c+1][0],i=e[c+1][1],r===s&&o===i)continue;const l=[r,o];M(u,[r,o],[s,i],a);const{azimuth:h,distance:f}=u,d=f/n;if(d>1){for(let e=1;e<=d-1;e++){g(p,l,h,e*n,a),t.push(p.slice(0))}g(p,l,h,(f+Math.floor(d-1)*n)/2,a),t.push(p.slice(0))}g(p,l,h,f,a),t.push(p.slice(0)),r=p[0],o=p[1]}}return"polyline"===t.type?new i({paths:l,spatialReference:a}):new s({rings:l,spatialReference:a})}function g(e,t,n,s,i){const a=t[0],o=t[1],c=a*r,l=o*r,p=n*r,{a:f,b:u,f:d}=h(i),m=Math.sin(p),g=Math.cos(p),M=(1-d)*Math.tan(l),w=1/Math.sqrt(1+M*M),y=M*w,R=Math.atan2(M,g),b=w*m,q=b*b,v=1-q,j=v*(f*f-u*u)/(u*u),z=1+j/16384*(4096+j*(j*(320-175*j)-768)),x=j/1024*(256+j*(j*(74-47*j)-128));let N,S,k,P,A=s/(u*z),F=2*Math.PI;for(;Math.abs(A-F)>1e-12;)k=Math.cos(2*R+A),N=Math.sin(A),S=Math.cos(A),P=x*N*(k+x/4*(S*(2*k*k-1)-x/6*k*(4*N*N-3)*(4*k*k-3))),F=A,A=s/(u*z)+P;const G=y*N-w*S*g,C=Math.atan2(y*S+w*N*g,(1-d)*Math.sqrt(q+G*G)),E=Math.atan2(N*m,w*S-y*N*g),I=d/16*v*(4+d*(4-3*v)),O=C/r,U=(c+(E-(1-I)*d*b*(A+I*N*(k+I*S*(2*k*k-1)))))/r;return e.splice(0,e.length),e.push(U,O),e}function M(e,t,n,s){const i=t[0]*r,a=t[1]*r,o=n[0]*r,c=n[1]*r,{a:l,b:p,f:f,radius:u}=h(s),d=o-i,m=Math.atan((1-f)*Math.tan(a)),g=Math.atan((1-f)*Math.tan(c)),M=Math.sin(m),w=Math.cos(m),y=Math.sin(g),R=Math.cos(g);let b,q,v,j,z,x,N,S,k,P,A=1e3,F=d;do{if(N=Math.sin(F),S=Math.cos(F),v=Math.sqrt(R*N*(R*N)+(w*y-M*R*S)*(w*y-M*R*S)),0===v)return{distance:0};z=M*y+w*R*S,x=Math.atan2(v,z),k=w*R*N/v,q=1-k*k,j=z-2*M*y/q,isNaN(j)&&(j=0),P=f/16*q*(4+f*(4-3*q)),b=F,F=d+(1-P)*f*k*(x+P*v*(j+P*z*(2*j*j-1)))}while(Math.abs(F-b)>1e-12&&--A>0);if(0===A){const e=u,t=Math.acos(Math.sin(a)*Math.sin(c)+Math.cos(a)*Math.cos(c)*Math.cos(o-i))*e,n=o-i,s=Math.sin(n)*Math.cos(c),l=Math.cos(a)*Math.sin(c)-Math.sin(a)*Math.cos(c)*Math.cos(n);return{azimuth:Math.atan2(s,l)/r,distance:t}}const G=q*(l*l-p*p)/(p*p),C=G/1024*(256+G*(G*(74-47*G)-128)),E=p*(1+G/16384*(4096+G*(G*(320-175*G)-768)))*(x-C*v*(j+C/4*(z*(2*j*j-1)-C/6*j*(4*v*v-3)*(4*j*j-3)))),I=Math.atan2(R*Math.sin(F),w*y-M*R*Math.cos(F)),O=Math.atan2(w*Math.sin(F),w*y*Math.cos(F)-M*R);return e.azimuth=I/r,e.distance=E,e.reverseAzimuth=O/r,e}function w(t,n,s="meters"){if(!t||!n)throw new e("geodesic-distance:missing-parameters","one or both input parameters are missing");if(!t.spatialReference||!n.spatialReference)throw new e("geodesic-distance:invalid-parameters","one or both input points do not have a spatial reference");if(!t.spatialReference.equals(n.spatialReference))throw new e("geodesic-distance:invalid-parameters","spatial references of input parameters do not match");const{spatialReference:i}=t;if(!f(i))throw new e("geodesic-distance:not-supported","input geometry spatial reference is not supported");if(t.equals(n))return{distance:0,azimuth:0,reverseAzimuth:0};const r={distance:null};return M(r,[t.x,t.y],[n.x,n.y],i),r.distance=a(r.distance,"meters",s),r}function y(t,s,i){if(!t||null==s||null==i)throw new e("point-from-distance:missing-parameters","one or more input parameters are missing or undefined");if(i<0||i>360)throw new e("point-from-distance:-of-bounds","azimuth is restricted to angles between, and including, 0° to 360° degrees");if(!t.spatialReference)throw new e("point-from-distance:missing-spatial-reference","the input point must have a spatial reference");const{spatialReference:a}=t;if(!f(a))throw new e("geodesic-distance:not-supported","input geometry spatial reference is not supported");const r=[0,0];return g(r,[t.x,t.y],i,s,a),new n({x:r[0],y:r[1],spatialReference:a})}export{g as directGeodeticSolver,u as geodesicAreas,m as geodesicDensify,w as geodesicDistance,d as geodesicLengths,M as inverseGeodeticSolver,f as isSupported,y as pointFromDistance};
