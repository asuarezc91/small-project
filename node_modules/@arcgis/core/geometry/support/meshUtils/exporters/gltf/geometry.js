/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import t from"../../../../Point.js";import"../../../../../geometry.js";import{isNaN as e}from"../../../../../core/mathUtils.js";import{c as r}from"../../../../../chunks/vec3f64.js";import{s as o,f as s,c as i,n}from"../../../../../chunks/vec3.js";function x(t){if(t.components){for(const e of t.components)"smooth"===e.shading&&e.faces&&a(t,e);t.vertexAttributesChanged()}}function a(t,r){t.vertexAttributes.normal||(t.vertexAttributes.normal=new Float32Array(t.vertexAttributes.position.length));const x=r.faces.length/3;for(let n=0;n<x;++n){const x=r.faces[3*n+0],a=r.faces[3*n+1],m=r.faces[3*n+2],b=o(u,t.vertexAttributes.position[3*x+0],t.vertexAttributes.position[3*x+1],t.vertexAttributes.position[3*x+2]),l=o(v,t.vertexAttributes.position[3*a+0],t.vertexAttributes.position[3*a+1],t.vertexAttributes.position[3*a+2]),c=o(A,t.vertexAttributes.position[3*m+0],t.vertexAttributes.position[3*m+1],t.vertexAttributes.position[3*m+2]),f=s(l,l,b),p=s(c,c,b),h=i(f,f,p);e(t.vertexAttributes.normal[3*x+0])&&(t.vertexAttributes.normal[3*x+0]=0),e(t.vertexAttributes.normal[3*x+1])&&(t.vertexAttributes.normal[3*x+1]=0),e(t.vertexAttributes.normal[3*x+2])&&(t.vertexAttributes.normal[3*x+2]=0),e(t.vertexAttributes.normal[3*a+0])&&(t.vertexAttributes.normal[3*a+0]=0),e(t.vertexAttributes.normal[3*a+1])&&(t.vertexAttributes.normal[3*a+1]=0),e(t.vertexAttributes.normal[3*a+2])&&(t.vertexAttributes.normal[3*a+2]=0),e(t.vertexAttributes.normal[3*m+0])&&(t.vertexAttributes.normal[3*m+0]=0),e(t.vertexAttributes.normal[3*m+1])&&(t.vertexAttributes.normal[3*m+1]=0),e(t.vertexAttributes.normal[3*m+2])&&(t.vertexAttributes.normal[3*m+2]=0),t.vertexAttributes.normal[3*x+0]+=h[0],t.vertexAttributes.normal[3*x+1]+=h[1],t.vertexAttributes.normal[3*x+2]+=h[2],t.vertexAttributes.normal[3*a+0]+=h[0],t.vertexAttributes.normal[3*a+1]+=h[1],t.vertexAttributes.normal[3*a+2]+=h[2],t.vertexAttributes.normal[3*m+0]+=h[0],t.vertexAttributes.normal[3*m+1]+=h[1],t.vertexAttributes.normal[3*m+2]+=h[2]}for(let e=0;e<t.vertexAttributes.normal.length;e+=3)o(b,t.vertexAttributes.normal[e],t.vertexAttributes.normal[e+1],t.vertexAttributes.normal[e+2]),n(b,b),t.vertexAttributes.normal[e+0]=b[0],t.vertexAttributes.normal[e+1]=b[1],t.vertexAttributes.normal[e+2]=b[2]}function m(e){const r=e.extent.xmax-e.extent.width/2,o=e.extent.ymax-e.extent.height/2,s=e.extent.zmin;return new t({x:r,y:o,z:s,spatialReference:e.extent.spatialReference})}const u=r(),v=r(),A=r(),b=r();export{m as computeOrigin,x as smoothNormalsMesh};
