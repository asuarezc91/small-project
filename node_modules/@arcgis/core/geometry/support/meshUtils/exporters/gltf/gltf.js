/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{Z as t,b as e,O as s}from"../../../../../chunks/vec3f64.js";import{m as r}from"../../../../../chunks/vec3.js";import{I as i,b as a}from"../../../../../chunks/quatf64.js";import o from"../../../MeshMaterialMetallicRoughness.js";import{ungeoreference as n}from"../../georeference.js";import{j as l}from"../../../../../chunks/quat.js";import{BufferOutputType as h,ImageOutputType as c,ComponentType as u,DataType as d,TargetBuffer as f,AlphaMode as p}from"./types.js";import{Buffer as m}from"./buffer.js";import{computeOrigin as g,smoothNormalsMesh as x}from"./geometry.js";import{imageToArrayBuffer as A,imageToDataURI as b}from"./imageutils.js";class T{constructor(t,e,s){this.params={},this.materialMap=new Array,this.gltf={asset:{version:"2.0",copyright:t.copyright,generator:t.generator},extras:{options:e,binChunkBuffer:null,promises:[]}},s&&(this.params=s),this.addScenes(t)}addScenes(t){this.gltf.scene=t.defaultScene;const e=this.gltf.extras.options.bufferOutputType===h.GLB||this.gltf.extras.options.imageOutputType===c.GLB;e&&(this.gltf.extras.binChunkBuffer=new m(this.gltf)),t.forEachScene((t=>{this.addScene(t)})),e&&this.gltf.extras.binChunkBuffer.finalize()}addScene(t){this.gltf.scenes||(this.gltf.scenes=[]);const e={};t.name&&(e.name=t.name),t.forEachNode((t=>{e.nodes||(e.nodes=[]);const s=this.addNode(t);e.nodes.push(s)})),this.gltf.scenes.push(e)}addNode(o){this.gltf.nodes||(this.gltf.nodes=[]);const n={};o.name&&(n.name=o.name);const h=o.translation;r(h,t)||(n.translation=e(h));const c=o.rotation;l(c,i)||(n.rotation=a(c));const u=o.scale;r(u,s)||(n.scale=e(u)),o.mesh&&o.mesh.vertexAttributes.position?n.mesh=this.addMesh(o.mesh):o.forEachNode((t=>{n.children||(n.children=[]);const e=this.addNode(t);n.children.push(e)}));const d=this.gltf.nodes.length;return this.gltf.nodes.push(n),d}addMesh(t){this.gltf.meshes||(this.gltf.meshes=[]);const e={primitives:[]},s=this.gltf.extras.options.bufferOutputType===h.GLB;let r;r=s?this.gltf.extras.binChunkBuffer:new m(this.gltf);const i=t.clone();this.params.origin||(this.params.origin=g(i)),i.rotate(-90,0,0,{origin:this.params.origin}),x(i);const a=n(i.vertexAttributes,this.params.origin,{geographic:this.params.geographic,unit:"meters"});i.vertexAttributes.position=a.position,i.vertexAttributes.normal=a.normal,i.vertexAttributes.tangent=a.tangent;const o=r.addBufferView(u.FLOAT,d.VEC3,f.ARRAY_BUFFER);let l,c,p,A;i.vertexAttributes.normal&&(l=r.addBufferView(u.FLOAT,d.VEC3,f.ARRAY_BUFFER)),i.vertexAttributes.uv&&(c=r.addBufferView(u.FLOAT,d.VEC2,f.ARRAY_BUFFER)),i.vertexAttributes.tangent&&(p=r.addBufferView(u.FLOAT,d.VEC4,f.ARRAY_BUFFER)),i.vertexAttributes.color&&(A=r.addBufferView(u.UNSIGNED_BYTE,d.VEC4,f.ARRAY_BUFFER)),o.startAccessor("POSITION"),l&&l.startAccessor("NORMAL"),c&&c.startAccessor("TEXCOORD_0"),p&&p.startAccessor("TANGENT"),A&&A.startAccessor("COLOR_0");const b=i.vertexAttributes.position.length/3;for(let t=0;t<b;++t)o.push(i.vertexAttributes.position[3*t+0]),o.push(i.vertexAttributes.position[3*t+1]),o.push(i.vertexAttributes.position[3*t+2]),l&&(l.push(i.vertexAttributes.normal[3*t+0]),l.push(i.vertexAttributes.normal[3*t+1]),l.push(i.vertexAttributes.normal[3*t+2])),c&&(c.push(i.vertexAttributes.uv[2*t+0]),c.push(i.vertexAttributes.uv[2*t+1])),p&&(p.push(i.vertexAttributes.tangent[4*t+0]),p.push(i.vertexAttributes.tangent[4*t+1]),p.push(i.vertexAttributes.tangent[4*t+2]),p.push(i.vertexAttributes.tangent[4*t+3])),A&&(A.push(i.vertexAttributes.color[4*t+0]),A.push(i.vertexAttributes.color[4*t+1]),A.push(i.vertexAttributes.color[4*t+2]),A.push(i.vertexAttributes.color[4*t+3]));const T=o.endAccessor(),R=this.addAccessor(o.index,T);let v,O,M,N,E;if(l){const t=l.endAccessor();v=this.addAccessor(l.index,t)}if(c){const t=c.endAccessor();O=this.addAccessor(c.index,t)}if(p){const t=p.endAccessor();M=this.addAccessor(p.index,t)}if(A){const t=A.endAccessor();N=this.addAccessor(A.index,t)}i.components&&i.components.length>0&&i.components[0].faces?(E=r.addBufferView(u.UNSIGNED_INT,d.SCALAR,f.ELEMENT_ARRAY_BUFFER),this.addMeshVertexIndexed(E,i.components,e,R,v,O,M,N)):this.addMeshVertexNonIndexed(i.components,e,R,v,O,M,N),o.finalize(),l&&l.finalize(),c&&c.finalize(),p&&p.finalize(),E&&E.finalize(),A&&A.finalize(),s||r.finalize();const C=this.gltf.meshes.length;return this.gltf.meshes.push(e),C}addMaterial(t){if(null===t)return;const e=this.materialMap.indexOf(t);if(-1!==e)return e;this.gltf.materials||(this.gltf.materials=[]);const s={};switch(t.alphaMode){case"mask":s.alphaMode=p.MASK;break;case"auto":case"blend":s.alphaMode=p.BLEND}.5!==t.alphaCutoff&&(s.alphaCutoff=t.alphaCutoff),t.doubleSided&&(s.doubleSided=t.doubleSided),s.pbrMetallicRoughness={};const r=t=>Math.pow(t,2.1),i=t=>{const e=t.toRgba();return e[0]=r(e[0]/255),e[1]=r(e[1]/255),e[2]=r(e[2]/255),e};if(t.color&&(s.pbrMetallicRoughness.baseColorFactor=i(t.color)),t.colorTexture&&(s.pbrMetallicRoughness.baseColorTexture={index:this.addTexture(t.colorTexture)}),t.normalTexture&&(s.normalTexture={index:this.addTexture(t.normalTexture)}),t instanceof o){if(t.emissiveTexture&&(s.emissiveTexture={index:this.addTexture(t.emissiveTexture)}),t.emissiveColor){const e=i(t.emissiveColor);s.emissiveFactor=[e[0],e[1],e[2]]}t.occlusionTexture&&(s.occlusionTexture={index:this.addTexture(t.occlusionTexture)}),t.metallicRoughnessTexture&&(s.pbrMetallicRoughness.metallicRoughnessTexture={index:this.addTexture(t.metallicRoughnessTexture)}),s.pbrMetallicRoughness.metallicFactor=t.metallic,s.pbrMetallicRoughness.roughnessFactor=t.roughness}else s.pbrMetallicRoughness.metallicFactor=1,s.pbrMetallicRoughness.roughnessFactor=1;const a=this.gltf.materials.length;return this.gltf.materials.push(s),this.materialMap.push(t),a}addTexture(t){this.gltf.textures||(this.gltf.textures=[]);const e={sampler:this.addSampler(t),source:this.addImage(t)},s=this.gltf.textures.length;return this.gltf.textures.push(e),s}addImage(t){this.gltf.images||(this.gltf.images=[]);const e={};if(t.url)e.uri=t.url;else{e.extras=t.data;for(let e=0;e<this.gltf.images.length;++e)if(t.data===this.gltf.images[e].extras)return e;switch(this.gltf.extras.options.imageOutputType){case c.GLB:{const s=this.gltf.extras.binChunkBuffer.addBufferView(u.UNSIGNED_BYTE,d.SCALAR);s.writeAsync(A(t.data)).then((()=>{s.finalize()})),e.bufferView=s.index,e.mimeType="image/png";break}case c.DataURI:e.uri=b(t.data);break;default:this.gltf.extras.promises.push(A(t.data).then((t=>{e.uri=t})))}}const s=this.gltf.images.length;return this.gltf.images.push(e),s}addSampler(t){this.gltf.samplers||(this.gltf.samplers=[]);let e=10497,s=10497;if("string"==typeof t.wrap)switch(t.wrap){case"clamp":e=33071,s=33071;break;case"mirror":e=33648,s=33648}else{switch(t.wrap.vertical){case"clamp":s=33071;break;case"mirror":s=33648}switch(t.wrap.horizontal){case"clamp":e=33071;break;case"mirror":e=33648}}const r={wrapS:e,wrapT:s};for(let t=0;t<this.gltf.samplers.length;++t)if(JSON.stringify(r)===JSON.stringify(this.gltf.samplers[t]))return t;const i=this.gltf.samplers.length;return this.gltf.samplers.push(r),i}addAccessor(t,e){this.gltf.accessors||(this.gltf.accessors=[]);const s={bufferView:t,byteOffset:e.byteOffset,componentType:e.componentType,count:e.count,type:e.type,min:e.min,max:e.max,name:e.name};e.normalized&&(s.normalized=!0);const r=this.gltf.accessors.length;return this.gltf.accessors.push(s),r}addMeshVertexIndexed(t,e,s,r,i,a,o,n){for(const l of e){t.startAccessor("INDICES");for(let e=0;e<l.faces.length;++e)t.push(l.faces[e]);const e=t.endAccessor(),h={attributes:{POSITION:r},indices:this.addAccessor(t.index,e),material:this.addMaterial(l.material)};i&&"flat"!==l.shading&&(h.attributes.NORMAL=i),a&&(h.attributes.TEXCOORD_0=a),o&&"flat"!==l.shading&&(h.attributes.TANGENT=o),n&&(h.attributes.COLOR_0=n),s.primitives.push(h)}}addMeshVertexNonIndexed(t,e,s,r,i,a,o){const n={attributes:{POSITION:s}};r&&(n.attributes.NORMAL=r),i&&(n.attributes.TEXCOORD_0=i),a&&(n.attributes.TANGENT=a),o&&(n.attributes.COLOR_0=o),t&&(n.material=this.addMaterial(t[0].material)),e.primitives.push(n)}}export{T as GLTF};
