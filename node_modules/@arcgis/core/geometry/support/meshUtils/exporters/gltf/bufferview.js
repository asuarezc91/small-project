/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{resolve as e,create as t,eachAlways as s}from"../../../../../core/promiseUtils.js";import{TargetBuffer as i,ComponentType as r,DataType as n}from"./types.js";class a{constructor(e,t,s,r,n){this.buffer=e,this.componentType=s,this.dataType=r,this.data=[],this.isFinalized=!1,this.accessorIndex=-1,this.accessorAttribute=null,this.accessorMin=null,this.accessorMax=null,t.bufferViews||(t.bufferViews=[]),this.index=t.bufferViews.length,this.bufferView={buffer:e.index,byteLength:-1,target:n};const a=this.getElementSize();a>=4&&n!==i.ELEMENT_ARRAY_BUFFER&&(this.bufferView.byteStride=a),t.bufferViews.push(this.bufferView)}push(e){const t=this.data.length;if(this.data.push(e),this.accessorIndex>=0){const s=t%this.numComponentsForDataType(),i=this.accessorMin[s];this.accessorMin[s]="number"!=typeof i?e:Math.min(i,e);const r=this.accessorMax[s];this.accessorMax[s]="number"!=typeof r?e:Math.max(r,e)}}get dataSize(){return this.data.length*this.sizeComponentType()}get size(){return e=this.dataSize,(t=4)*Math.ceil(e/t);var e,t}getByteOffset(){if(!this.isFinalized)throw new Error("Cannot get BufferView offset until it is finalized");return this.buffer.getByteOffset(this)}get byteOffset(){if(!this.isFinalized)throw new Error("Cannot get BufferView offset until it is finalized");return this.buffer.getByteOffset(this)}writeOutToBuffer(e,t=this.size){const s=new DataView(e,t),i=this.sizeComponentType();for(let e=0;e<this.data.length;++e)this.writeValue(s,e*i,this.data[e])}writeAsync(e){if(this.asyncWritePromise)throw new Error("Can't write multiple bufferView vlaues asynchronously");return this.asyncWritePromise=e.then((e=>{const t=new Uint8Array(e);for(let e=0;e<t.byteLength;++e)this.data.push(t[e]);delete this.asyncWritePromise})),this.asyncWritePromise}startAccessor(e){if(this.accessorIndex>=0)throw new Error("Accessor was started without ending the previous one");this.accessorIndex=this.data.length,this.accessorAttribute=e;const t=this.numComponentsForDataType();this.accessorMin=new Array(t),this.accessorMax=new Array(t)}endAccessor(){if(this.accessorIndex<0)throw new Error("An accessor was not started, but was attempted to be ended");const e=this.getElementSize(),t=this.numComponentsForDataType(),s=(this.data.length-this.accessorIndex)/t;if(s%1)throw new Error("An accessor was ended with missing component values");for(let e=0;e<this.accessorMin.length;++e)"number"!=typeof this.accessorMin[e]&&(this.accessorMin[e]=0),"number"!=typeof this.accessorMax[e]&&(this.accessorMax[e]=0);const i={byteOffset:e*(this.accessorIndex/t),componentType:this.componentType,count:s,type:this.dataType,min:this.accessorMin,max:this.accessorMax,name:this.accessorAttribute};switch(this.accessorAttribute){case"TEXCOORD_0":case"TEXCOORD_1":case"COLOR_0":case"WEIGHTS_0":switch(this.componentType){case r.UNSIGNED_BYTE:case r.UNSIGNED_SHORT:i.normalized=!0}}return this.accessorIndex=-1,this.accessorAttribute=null,this.accessorMin=null,this.accessorMax=null,i}get finalized(){return this.finalizedPromise?this.finalizedPromise:this.isFinalized?this.finalizedPromise=e():this.finalizedPromise=t((e=>this.finalizedPromiseResolve=e))}finalize(){const e=this.bufferView;return t((e=>{const t=this.buffer.getViewFinalizePromises(this);this.asyncWritePromise&&t.push(this.asyncWritePromise),e(s(t))})).then((()=>{this.isFinalized=!0,e.byteOffset=this.getByteOffset(),e.byteLength=this.dataSize,this.finalizedPromiseResolve&&this.finalizedPromiseResolve()}))}getElementSize(){return this.sizeComponentType()*this.numComponentsForDataType()}sizeComponentType(){switch(this.componentType){case r.BYTE:case r.UNSIGNED_BYTE:return 1;case r.SHORT:case r.UNSIGNED_SHORT:return 2;case r.UNSIGNED_INT:case r.FLOAT:return 4}}numComponentsForDataType(){switch(this.dataType){case n.SCALAR:return 1;case n.VEC2:return 2;case n.VEC3:return 3;case n.VEC4:case n.MAT2:return 4;case n.MAT3:return 9;case n.MAT4:return 16}}writeValue(e,t,s){switch(this.componentType){case r.BYTE:e.setInt8(t,s);break;case r.UNSIGNED_BYTE:e.setUint8(t,s);break;case r.SHORT:e.setInt16(t,s,!0);break;case r.UNSIGNED_SHORT:e.setUint16(t,s,!0);break;case r.UNSIGNED_INT:e.setUint32(t,s,!0);break;case r.FLOAT:e.setFloat32(t,s,!0);break;default:throw new Error(`Unsupported data type: ${this.componentType}`)}}}export{a as BufferView};
