/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{_ as e}from"../chunks/tslib.es6.js";import"../core/has.js";import"../core/Logger.js";import"../core/accessorSupport/ensureType.js";import{property as r}from"../core/accessorSupport/decorators/property.js";import{subclass as t}from"../core/accessorSupport/decorators/subclass.js";import"../core/urlUtils.js";import"../core/uuid.js";import"../portal/support/resourceExtension.js";import s from"./support/WKIDUnitConversion.js";import{webMercatorToGeographic as o,geographicToWebMercator as i}from"./support/webMercatorUtils.js";import c from"./Point.js";import n from"./Polygon.js";import{getReferenceEllipsoid as a}from"./projectionEllipsoid.js";import{convertUnit as p,lengthToDegrees as l}from"../core/unitUtils.js";import{directGeodeticSolver as u}from"./support/geodesicUtils.js";var d;let h=d=class extends n{constructor(...e){super(...e),this.center=null,this.geodesic=!1,this.numberOfPoints=60,this.radius=1e3,this.radiusUnit="meters"}normalizeCtorArgs(e,r){let t;if(e&&e.center)t=e;else{if(e&&e.rings)return super.normalizeCtorArgs(e,r);t={center:e}}return{...super.normalizeCtorArgs(),...t,...r}}initialize(){const e=this.center,r=this.numberOfPoints;if(this.hasZ=e&&e.hasZ,0!==this.rings.length||!e)return;const t=p(this.radius,this.radiusUnit,"meters"),c=e.spatialReference;let n,u="geographic";if(c.isWebMercator?u="webMercator":(null!=s[c.wkid]||c.wkt&&0===c.wkt.indexOf("PROJCS"))&&(u="projected"),this.geodesic){let s;switch(u){case"webMercator":s=o(e);break;case"projected":console.error("Creating a geodesic circle requires the center to be specified in web mercator or geographic coordinate system");break;case"geographic":s=e}n=this._createGeodesicCircle(s,t,r),"webMercator"===u&&(n=i(n))}else{let s;"webMercator"===u||"projected"===u?s=t/this._convert2Meters(1,e.spatialReference):"geographic"===u&&(s=l(t,"meters",a(e.spatialReference).radius)),n=this._createPlanarCircle(e,s,r)}this.spatialReference=n.spatialReference,this.addRing(n.rings[0])}clone(){const{center:e,numberOfPoints:r,radius:t,radiusUnit:s,geodesic:o}=this;return new d({center:e.clone(),numberOfPoints:r,radius:t,radiusUnit:s,geodesic:o})}_createGeodesicCircle(e,r,t){let s=0;const o=[];for(;s<360;){const i=[0,0],c=[e.x,e.y];u(i,c,s,r),this.hasZ&&i.push(e.z),o.push(i),s+=360/t}return o.push(o[0]),new n(o)}_createPlanarCircle(e,r,t){let s=0;const o=[];for(;s<2*Math.PI;){const i=[e.x+Math.cos(-s)*r,e.y+Math.sin(-s)*r];this.hasZ&&i.push(e.z),o.push(i),s+=Math.PI/(t/2)}return o.push(o[0]),new n({spatialReference:e.spatialReference,rings:[o]})}_convert2Meters(e,r){let t;if(null!=s[r.wkid])t=s.values[s[r.wkid]];else{const e=r.wkt,s=e.lastIndexOf(",")+1,o=e.lastIndexOf("]]");t=parseFloat(e.substring(s,o))}return e*t}};e([r({type:c})],h.prototype,"center",void 0),e([r()],h.prototype,"geodesic",void 0),e([r()],h.prototype,"numberOfPoints",void 0),e([r()],h.prototype,"radius",void 0),e([r()],h.prototype,"radiusUnit",void 0),h=d=e([t("esri.geometry.Circle")],h);var m=h;export default m;
