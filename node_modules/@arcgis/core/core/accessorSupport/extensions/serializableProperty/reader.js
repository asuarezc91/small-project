/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{setDeepValue as t}from"../../../object.js";import e from"../../../Logger.js";import{getOwnClassMetadata as r}from"../../metadata.js";import n from"../../../Warning.js";import{isCollection as o}from"./type.js";const i=e.getLogger("esri.core.accessorSupport.extensions.serializableProperty.reader");function p(e,r,n){var o,i;e&&(!n&&!r.read||null!=(o=r.read)&&o.reader||!1===(null==(i=r.read)?void 0:i.enabled)||function(t){if("types"in t)return l(t.types);return a(t.type)}(e)&&t("read.reader",u(e),r))}function u(t){var e;const r=null!=(e=t.ndimArray)?e:0;if(r>1)return function(t){var e;const r=s(t),n=y.bind(null,r),o=null!=(e=t.ndimArray)?e:0;return(t,e,r)=>{if(null==t)return t;t=n(t,r,o);let i=o,p=t;for(;i>0&&Array.isArray(p);)i--,p=p[0];if(void 0!==p)for(let e=0;e<i;e++)t=[t];return t}}(t);if(1===r)return f(t);if("type"in t&&c(t.type)){var n,o;const e=null==(n=t.type.prototype)||null==(o=n.itemType)?void 0:o.Type,r=f("function"==typeof e?{type:e}:{types:e});return(e,n,o)=>{const i=r(e,n,o);return i?new t.type(i):i}}return s(t)}function s(t){return"type"in t?function(t){if(t.prototype.read)return(e,r,n)=>{if(null==e)return e;const o=typeof e;if("object"!==o)return void i.error(`Expected JSON value of type 'object' to deserialize type '${t.prototype.declaredClass}', but got '${o}'`);const p=new t;return p.read(e,n),p};return t.fromJSON}(t.type):function(t){var e;let o=null;const p=null!=(e=t.errorContext)?e:"type";return(e,u,s)=>{if(null==e)return e;const y=typeof e;if("object"!==y)return void i.error(`Expected JSON value of type 'object' to deserialize, but got '${y}'`);o||(o=function(t){const e={};for(const i in t.typeMap){var n,o;const p=t.typeMap[i],u=r(p.prototype);if("function"==typeof t.key)continue;const s=u.properties[t.key];if(!s)continue;null!=(n=s.json)&&n.type&&Array.isArray(s.json.type)&&1===s.json.type.length&&"string"==typeof s.json.type[0]&&(e[s.json.type[0]]=p);const y=null==(o=s.json)?void 0:o.write;if(!y||!y.writer){e[i]=p;continue}const f=y.target,c="string"==typeof f?f:t.key,a={};y.writer(i,a,c),a[c]&&(e[a[c]]=p)}return e}(t));const f=t.key;if("string"!=typeof f)return;const c=e[f],a=c?o[c]:t.defaultKeyValue?t.typeMap[t.defaultKeyValue]:void 0;if(!a){const t=`Type '${c||"unknown"}' is not supported`;return s&&s.messages&&e&&s.messages.push(new n(`${p}:unsupported`,t,{definition:e,context:s})),void i.error(t)}const l=new a;return l.read(e,s),l}}(t.types)}function y(t,e,r,n){return 0!==n&&Array.isArray(e)?e.map((e=>y(t,e,r,n-1))):t(e,void 0,r)}function f(t){const e=s(t);return(t,r,n)=>{if(null==t)return t;if(Array.isArray(t)){const r=[];for(const o of t){const t=e(o,void 0,n);void 0!==t&&r.push(t)}return r}const o=e(t,void 0,n);return void 0!==o?[o]:void 0}}function c(t){if(!o(t))return!1;const e=t.prototype.itemType;return!(!e||!e.Type)&&("function"==typeof e.Type?a(e.Type):l(e.Type))}function a(t){return!Array.isArray(t)&&(!!t&&t.prototype&&("read"in t.prototype||"fromJSON"in t||c(t)))}function l(t){for(const e in t.typeMap){if(!a(t.typeMap[e]))return!1}return!0}export{p as create,u as createTypeReader};
